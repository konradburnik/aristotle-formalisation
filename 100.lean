/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: f6befefe-c19c-421c-94d1-aa4645f5344a
-/

/-
We define the set of numbers reachable from 3 and 5 using multiplication and division. We then prove that 100 is not in this set by showing that all reachable numbers are of the form 3^a * 5^b, whereas 100 has a factor of 2.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
The number 100 cannot be formed by starting with 3 and 5 and applying multiplication and division.
-/
inductive Reachable : ℚ → Prop where
  | three : Reachable 3
  | five : Reachable 5
  | mul {x y} : Reachable x → Reachable y → Reachable (x * y)
  | div {x y} : Reachable x → Reachable y → Reachable (x / y)

theorem not_reachable_100 : ¬ Reachable 100 := by
  -- Prove that $100$ is not reachable by showing that the set of reachable numbers is closed under multiplication and division, and $100$ is not of the form $3^a * 5^b$.
  have h_reachable : ∀ r : ℚ, Reachable r → ∃ (a b : ℤ), r = 3 ^ a * 5 ^ b := by
    intro r hr
    induction' hr with r hr' h_ind;
    · exact ⟨ 1, 0, by norm_num ⟩;
    · exact ⟨ 0, 1, by norm_num ⟩;
    · case mul => rename_i h₁ h₂; obtain ⟨ a₁, b₁, rfl ⟩ := h₁; obtain ⟨ a₂, b₂, rfl ⟩ := h₂; exact ⟨ a₁ + a₂, b₁ + b₂, by rw [ zpow_add₀ ( by norm_num ), zpow_add₀ ( by norm_num ) ] ; ring ⟩ ;
    · rename_i hx hy ihx ihy; obtain ⟨ a, b, rfl ⟩ := ihx; obtain ⟨ c, d, rfl ⟩ := ihy; exact ⟨ a - c, b - d, by norm_num [ zpow_sub₀ ] ; ring ⟩ ;
  contrapose! h_reachable;
  use 100;
  refine ⟨ h_reachable, ?_ ⟩;
  intro a b H; rcases a with ( _ | a ) <;> rcases b with ( _ | b ) <;> norm_num [ zero_ne_one, pow_succ', mul_assoc ] at *;
  · norm_cast at H ; have := congr_arg ( · % 2 ) H ; norm_num [ Nat.mul_mod, Nat.pow_mod ] at this;
  · field_simp at H;
    norm_cast at H ; have := congr_arg ( · % 5 ) H ; norm_num [ Nat.mul_mod, Nat.pow_mod ] at this;
    rename_i k; rw [ eq_comm ] at this; rw [ ← Nat.dvd_iff_mod_eq_zero ] at this; norm_num [ Nat.Prime.dvd_iff_one_le_factorization ] at this;
  · field_simp at H;
    norm_cast at H ; have := congr_arg ( · % 2 ) H ; norm_num [ Nat.mul_mod, Nat.pow_mod ] at this;
  · -- Simplify the equation from the assumption.
    field_simp at H;
    norm_cast at H ; have := congr_arg ( · % 3 ) H ; norm_num [ Nat.add_mod, Nat.mul_mod ] at this