/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: a10de263-57a2-4169-9961-09a356e9d376

Aristotle's budget for this request has been reached.
If there is partial progress, it will appear in this file.
If you would like to continue working off of this partial progress,
please submit the same prompt, and add this .lean file in "Optional: Attach a Lean file as context" field.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
Check the definition of ConvexIndependent
-/
#check ConvexIndependent

/-
If two vertices u, v are on the same side of the line through i, j and have the same distances to i and j, then u = v.
-/
open Classical

theorem convex_dist_pair_unique_on_side
  (n : ℕ) (p : Fin n → EuclideanSpace ℝ (Fin 2))
  (hinj : Function.Injective p)
  (i j : Fin n)
  (u v : Fin n)
  (h_side : (p u - p i) 1 * (p j - p i) 0 - (p u - p i) 0 * (p j - p i) 1 > 0)
  (h_side' : (p v - p i) 1 * (p j - p i) 0 - (p v - p i) 0 * (p j - p i) 1 > 0)
  (h_dist_i : dist (p i) (p u) = dist (p i) (p v))
  (h_dist_j : dist (p j) (p u) = dist (p j) (p v)) :
  u = v := by
    norm_num [ dist_eq_norm, EuclideanSpace.norm_eq ] at *;
    rw [ Real.sqrt_inj ( by positivity ) ( by positivity ) ] at *;
    -- Since $p_u$ and $p_v$ are on the same side of the line $p_i p_j$, they must be the same intersection point.
    have h_same_point : (p u 0 - p v 0) * (p j 0 - p i 0) + (p u 1 - p v 1) * (p j 1 - p i 1) = 0 := by
      linarith;
    -- Since $p_u$ and $p_v$ are on the same side of the line $p_i p_j$, they must be the same intersection point by the uniqueness of the intersection of two circles.
    have h_unique : (p u 0 - p v 0) * (p j 1 - p i 1) - (p u 1 - p v 1) * (p j 0 - p i 0) = 0 := by
      by_contra h_contra;
      exact h_contra <| by nlinarith [ sq_nonneg ( p u 0 - p v 0 ), sq_nonneg ( p u 1 - p v 1 ), sq_nonneg ( p j 0 - p i 0 ), sq_nonneg ( p j 1 - p i 1 ) ] ;
    -- Since the determinant is non-zero, the only solution to the system is $p u 0 = p v 0$ and $p u 1 = p v 1$.
    have h_eq : p u 0 = p v 0 ∧ p u 1 = p v 1 := by
      have h_eq : (p j 0 - p i 0) ^ 2 + (p j 1 - p i 1) ^ 2 ≠ 0 := by
        exact fun h => by have := hinj ( show p j = p i from by ext x; fin_cases x <;> nlinarith! only [ h ] ) ; aesop;
      exact ⟨ mul_left_cancel₀ h_eq <| by linear_combination h_same_point * ( p j 0 - p i 0 ) + h_unique * ( p j 1 - p i 1 ), mul_left_cancel₀ h_eq <| by linear_combination h_same_point * ( p j 1 - p i 1 ) - h_unique * ( p j 0 - p i 0 ) ⟩;
    exact hinj ( by ext x; fin_cases x <;> tauto )

/-
The cardinality of the union of a chain of sets where only adjacent sets intersect is the sum of cardinalities minus the sum of adjacent intersection cardinalities.
-/
theorem chain_union_card_eq_sum_sub_adj_inter
  {α : Type*} [DecidableEq α]
  (n : ℕ)
  (hn : n ≥ 1)
  (S : Fin n → Finset α)
  (h_disj : ∀ i j : Fin n, i.val + 1 < j.val → Disjoint (S i) (S j)) :
  (Finset.biUnion Finset.univ S).card = (∑ i, (S i).card) - (∑ i : Fin (n - 1), (S (Fin.cast (Nat.sub_add_cancel hn) i.castSucc) ∩ S (Fin.cast (Nat.sub_add_cancel hn) i.succ)).card) := by
    induction' hn with n hn ih;
    · simp +decide [ Fin.eq_zero ];
    · rcases n <;> simp_all +decide [ Fin.sum_univ_castSucc ];
      rw [ show Finset.univ.biUnion S = Finset.biUnion Finset.univ ( fun i : Fin _ => S ( Fin.castSucc i ) ) ∪ S ( Fin.last _ ) from ?_, Finset.card_union ];
      · rw [ ih _ fun i j hij => h_disj _ _ <| by simpa using hij ];
        rw [ show ( Finset.univ.biUnion fun i : Fin _ => S i.castSucc ) ∩ S ( Fin.last _ ) = S ( Fin.last _ ).castSucc ∩ S ( Fin.last _ ) from ?_ ];
        · rw [ tsub_add_eq_add_tsub ];
          · exact?;
          · exact le_add_of_le_of_nonneg ( Finset.sum_le_sum fun _ _ => Finset.card_le_card fun x hx => by aesop ) ( Nat.zero_le _ );
        · ext x;
          simp_all +decide [ Finset.ext_iff, Finset.mem_biUnion ];
          refine' fun hx => ⟨ fun ⟨ i, hi ⟩ => _, fun hi => ⟨ Fin.last _, hi ⟩ ⟩;
          contrapose! h_disj;
          refine' ⟨ Fin.castSucc i, Fin.last _, _, _ ⟩ <;> simp_all +decide [ Fin.ext_iff, Finset.disjoint_left ];
          · exact lt_of_le_of_ne ( Nat.le_of_lt_succ i.2 ) ( by rintro h; exact h_disj <| by convert hi; aesop );
          · exact ⟨ x, hi, hx ⟩;
      · ext x;
        simp +decide [ Fin.exists_iff, Fin.last ];
        exact ⟨ fun ⟨ i, hi, hx ⟩ => if hi' : i = Nat.succ _ then Or.inr ( by simpa [ hi' ] using hx ) else Or.inl ⟨ i, lt_of_le_of_ne ( Nat.le_of_lt_succ hi ) hi', hx ⟩, fun hx => hx.elim ( fun ⟨ i, hi, hx ⟩ => ⟨ i, Nat.lt_succ_of_lt hi, hx ⟩ ) fun hx => ⟨ Nat.succ _, Nat.lt_succ_self _, hx ⟩ ⟩

/-
If y is antitone and S1 < S2, then the intersection of their images has size at most 1.
-/
theorem antitone_disjoint_intervals_inter_le_one
  {n : ℕ}
  {α : Type*} [LinearOrder α] [DecidableEq α]
  (y : Fin n → α)
  (hy : Antitone y)
  (S1 S2 : Finset (Fin n))
  (h_order : ∀ i ∈ S1, ∀ j ∈ S2, i < j) :
  (Finset.image y S1 ∩ Finset.image y S2).card ≤ 1 := by
    by_contra h_contra;
    -- Then there exist $v_1, v_2 \in y(S_1) \cap y(S_2)$ such that $v_1 < v_2$.
    obtain ⟨v1, hv1, v2, hv2, hv1v2⟩ : ∃ v1 v2, v1 ∈ Finset.image y S1 ∩ Finset.image y S2 ∧ v2 ∈ Finset.image y S1 ∩ Finset.image y S2 ∧ v1 < v2 := by
      obtain ⟨ v1, hv1, v2, hv2, hne ⟩ := Finset.one_lt_card.1 ( lt_of_not_ge h_contra ) ; exact hne.lt_or_gt.elim ( fun h => ⟨ v1, v2, hv1, hv2, h ⟩ ) fun h => ⟨ v2, v1, hv2, hv1, h ⟩ ;
    simp_all +decide [ Finset.mem_inter, Finset.mem_image ];
    obtain ⟨ ⟨ i, hi, rfl ⟩, j, hj, hj' ⟩ := v2; obtain ⟨ ⟨ k, hk, rfl ⟩, l, hl, hl' ⟩ := hv2; exact hv1v2.not_le ( by simpa [ hj', hl' ] using hy ( h_order _ hi _ hl |> le_of_lt ) ) ;

/-
If x is monotone and y is antitone and (x,y) is injective, then |Im(y)| >= n - (|Im(x)| - 1).
-/
theorem monotone_antitone_card_bound_aux
  {n : ℕ} (hn : n ≥ 1)
  {α : Type*} [LinearOrder α] [DecidableEq α]
  (x y : Fin n → α)
  (hx : Monotone x)
  (hy : Antitone y)
  (hinj : Function.Injective (fun i => (x i, y i))) :
  (Finset.image y Finset.univ).card ≥ n - ((Finset.image x Finset.univ).card - 1) := by
    have h_ind : ∀ k : ℕ, ∀ S : Finset (Fin n), (Finset.image x S).card = k → (Finset.image y S).card ≥ S.card - (k - 1) := by
      intro k S hk;
      induction' k using Nat.strong_induction_on with k ih generalizing S;
      rcases k with ( _ | _ | k ) <;> simp_all +decide;
      · rw [ Finset.card_image_of_injOn ];
        intro i hi j hj hij;
        have := Finset.card_eq_one.mp hk;
        obtain ⟨ a, ha ⟩ := this; simp_all +decide [ Finset.eq_singleton_iff_unique_mem ] ;
        have := @hinj i j; aesop;
      · -- Let $v_{min}$ be the minimum value of $x$ on $S$.
        obtain ⟨v_min, hv_min⟩ : ∃ v_min ∈ Finset.image x S, ∀ v ∈ Finset.image x S, v_min ≤ v := by
          exact ⟨ Finset.min' ( Finset.image x S ) ( Finset.card_pos.mp ( by linarith ) ), Finset.min'_mem _ _, fun v hv => Finset.min'_le _ _ hv ⟩;
        -- Let $S_1 = \{i \in S \mid x_i = v_{min}\}$ and $S_2 = \{i \in S \mid x_i > v_{min}\}$.
        set S1 := Finset.filter (fun i => x i = v_min) S
        set S2 := Finset.filter (fun i => x i > v_min) S;
        -- By the induction hypothesis, $|y(S_2)| \geq |S_2| - (k - 1)$.
        have h_ind_S2 : (Finset.image y S2).card ≥ S2.card - k := by
          have h_ind_S2 : (Finset.image x S2).card ≤ k + 1 := by
            have h_ind_S2 : Finset.image x S2 ⊆ Finset.image x S \ {v_min} := by
              simp +contextual [ Finset.subset_iff ];
              exact fun i hi => ⟨ ⟨ i, Finset.mem_filter.mp hi |>.1, rfl ⟩, ne_of_gt ( Finset.mem_filter.mp hi |>.2 ) ⟩;
            exact le_trans ( Finset.card_le_card h_ind_S2 ) ( by rw [ Finset.card_sdiff ] ; aesop );
          grind;
        -- Since $y$ is antitone, $|y(S_1) \cap y(S_2)| \leq 1$.
        have h_inter : (Finset.image y S1 ∩ Finset.image y S2).card ≤ 1 := by
          have h_inter : ∀ i ∈ S1, ∀ j ∈ S2, i < j := by
            norm_num +zetaDelta at *;
            intro i hi hi' j hj hj'; contrapose! hj'; aesop;
          exact?;
        -- Since $S = S_1 \cup S_2$, we have $|S| = |S_1| + |S_2|$.
        have h_card_S : S.card = S1.card + S2.card := by
          rw [ Finset.card_filter, Finset.card_filter ];
          rw [ ← Finset.sum_add_distrib, Finset.card_eq_sum_ones ];
          refine' Finset.sum_congr rfl fun i hi => _;
          split_ifs <;> simp_all +decide [ not_lt_of_ge ];
          exact ‹¬x i = v_min› ( le_antisymm ‹_› ( hv_min.2 i hi ) );
        -- Since $y$ is injective on $S_1$, we have $|y(S_1)| = |S_1|$.
        have h_card_S1 : (Finset.image y S1).card = S1.card := by
          rw [ Finset.card_image_of_injOn ];
          intro i hi j hj hij; have := @hinj i j; aesop;
        have h_card_union : (Finset.image y S).card ≥ (Finset.image y S1).card + (Finset.image y S2).card - (Finset.image y S1 ∩ Finset.image y S2).card := by
          rw [ ← Finset.card_union_add_card_inter ];
          simp +zetaDelta at *;
          exact Finset.card_le_card fun x hx => by aesop;
        omega;
    simpa using h_ind ( Finset.card ( Finset.image x Finset.univ ) ) Finset.univ rfl

/-
If x is monotone and y is antitone and (x,y) is injective, then |Im(x)| + |Im(y)| >= n + 1.
-/
theorem monotone_antitone_card_bound
  {n : ℕ} (hn : n ≥ 1)
  {α : Type*} [LinearOrder α] [DecidableEq α]
  (x y : Fin n → α)
  (hx : Monotone x)
  (hy : Antitone y)
  (hinj : Function.Injective (fun i => (x i, y i))) :
  (Finset.image x Finset.univ).card + (Finset.image y Finset.univ).card ≥ n + 1 := by
    -- Apply the lemma monotone_antitone_card_bound_aux to get the inequality involving |Im(y)|.
    have h_ineq : (Finset.image y Finset.univ).card ≥ n - ((Finset.image x Finset.univ).card - 1) := by
      exact?;
    contrapose! h_ineq;
    rcases n with ( _ | _ | n ) <;> simp_all +arith +decide;
    exact lt_tsub_iff_left.mpr ( by linarith [ Nat.sub_add_cancel ( show 1 ≤ Finset.card ( Finset.image x Finset.univ ) from Finset.card_pos.mpr ⟨ x 0, Finset.mem_image_of_mem _ ( Finset.mem_univ _ ) ⟩ ) ] )