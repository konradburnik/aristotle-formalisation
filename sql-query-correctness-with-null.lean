/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 4046f8af-e161-40f7-9ce4-aa427a19f118

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

/-
We define a 3-valued logic `Tristate` (true, false, unknown) to model SQL's behavior with NULLs.
We define `TableNull` to represent tables with nullable columns.
We implement the semantics of `NOT IN` using `tristate_eq` (equality returning unknown on NULL), `tristate_in` (fold of OR), and `sql_query_null` (filter where condition is true).

We prove the following theorems:
1. `sql_null_poison`: If the subquery `U` contains `NULL`, the result is always empty.
2. `sql_null_safe`: If `U` is non-empty and contains no `NULL`s, the result is `T` filtered for non-NULL values not in `U`.
3. `sql_null_empty`: If `U` is empty, the result is `T` (including NULLs).
4. `sql_correctness`: A comprehensive theorem characterizing the behavior in all cases.
-/

/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 32a5d4da-22c6-498d-a85a-1f3191dab855

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

/-
We define a simple model of database tables with a single column and formalize the SQL query `SELECT T.col FROM T WHERE T.col NOT IN (SELECT U.col FROM U)` as a list filter operation. We then prove that this query returns exactly the records in `T` that are not present in `U`.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
For any two non-empty tables $T$ and $U$ with column $col$, such that $U.col$ has common values with $T.col$, the query SELECT T.col FROM T WHERE T.col NOT IN (SELECT U.col FROM U) returns all records in $T$ for which $col$ is not found in $U$.
-/
structure Table (α : Type) where
  col : List α

variable {α : Type} [DecidableEq α]

def sql_query (T U : Table α) : List α :=
  T.col.filter (λ x => x ∉ U.col)

theorem claim_correct (T U : Table α)
  (hT : T.col ≠ []) (hU : U.col ≠ [])
  (h_common : ∃ x, x ∈ T.col ∧ x ∈ U.col) :
  sql_query T U = T.col.filter (λ x => x ∉ U.col) := by
  unfold sql_query; aesop;

/-
Proving the trivial claim about the naive query definition.
-/
theorem claim_correct_proof (T U : Table α)
  (hT : T.col ≠ []) (hU : U.col ≠ [])
  (h_common : ∃ x, x ∈ T.col ∧ x ∈ U.col) :
  sql_query T U = T.col.filter (λ x => x ∉ U.col) := by rfl

/-
Defining the 3-valued logic (True, False, Unknown) and its operations (AND, OR, NOT).
-/
inductive Tristate
| true
| false
| unknown
deriving DecidableEq, Repr

def Tristate.not : Tristate → Tristate
| Tristate.true => Tristate.false
| Tristate.false => Tristate.true
| Tristate.unknown => Tristate.unknown

def Tristate.and : Tristate → Tristate → Tristate
| Tristate.true, Tristate.true => Tristate.true
| Tristate.true, Tristate.unknown => Tristate.unknown
| Tristate.unknown, Tristate.true => Tristate.unknown
| Tristate.unknown, Tristate.unknown => Tristate.unknown
| _, _ => Tristate.false

def Tristate.or : Tristate → Tristate → Tristate
| Tristate.false, Tristate.false => Tristate.false
| Tristate.false, Tristate.unknown => Tristate.unknown
| Tristate.unknown, Tristate.false => Tristate.unknown
| Tristate.unknown, Tristate.unknown => Tristate.unknown
| _, _ => Tristate.true

def Tristate.toBool : Tristate → Bool
| Tristate.true => Bool.true
| _ => Bool.false

/-
Defining the table structure with nullable columns and the SQL query semantics using 3-valued logic.
-/
structure TableNull (α : Type) where
  col : List (Option α)

def tristate_eq {α : Type} [DecidableEq α] (x y : Option α) : Tristate :=
  match x, y with
  | none, _ => Tristate.unknown
  | _, none => Tristate.unknown
  | some a, some b => if a = b then Tristate.true else Tristate.false

def tristate_or_list (l : List Tristate) : Tristate :=
  l.foldl Tristate.or Tristate.false

def tristate_in {α : Type} [DecidableEq α] (x : Option α) (ys : List (Option α)) : Tristate :=
  tristate_or_list (ys.map (tristate_eq x))

def sql_query_null {α : Type} [DecidableEq α] (T U : TableNull α) : List (Option α) :=
  T.col.filter (λ x => (Tristate.not (tristate_in x U.col)).toBool)

/-
Proving the "poison" effect of NULLs in the subquery: if the subquery result contains a NULL, the NOT IN condition is never true, so the result is empty.
-/
theorem sql_null_poison (T U : TableNull α) (h : none ∈ U.col) :
  sql_query_null T U = [] := by
    unfold sql_query_null;
    unfold tristate_in;
    have h_tristate_or_list : ∀ {l : List Tristate}, Tristate.unknown ∈ l → tristate_or_list l = Tristate.true ∨ tristate_or_list l = Tristate.unknown := by
      intros l hl
      induction' l using List.reverseRecOn with l ih;
      · contradiction;
      · simp_all +decide [ tristate_or_list ];
        rcases hl with ( hl | rfl ) <;> rcases h : List.foldl Tristate.or Tristate.false l with ( _ | _ | _ ) <;> simp_all +decide;
        · cases ih <;> tauto;
        · cases ih <;> tauto;
    rw [ List.filter_eq_nil_iff ];
    intro a ha; specialize h_tristate_or_list ( show Tristate.unknown ∈ List.map ( tristate_eq a ) U.col from List.mem_map.mpr ⟨ none, h, by unfold tristate_eq; aesop ⟩ ) ; aesop;

/-
Proving the "safe" behavior of NULLs: if the subquery result does not contain NULLs, the query behaves as expected, filtering out NULLs from the main table and values present in the subquery.
-/
theorem sql_null_safe (T U : TableNull α) (hU : U.col ≠ []) (h : none ∉ U.col) :
  sql_query_null T U = T.col.filter (λ x => x ≠ none ∧ x ∉ U.col) := by
    -- Apply the safe behavior to each element in `T.col`.
    have : ∀ x ∈ T.col, (Tristate.not (tristate_in x U.col)).toBool ↔ x ≠ none ∧ x ∉ U.col := by
      unfold tristate_in;
      -- By definition of `tristate_eq`, if `x` is `none`, then `tristate_eq x y` is `unknown` for any `y`.
      intro x hx
      by_cases hx_none : x = none;
      · -- Since `U.col` does not contain `none`, the list of `tristate_eq none y` for `y` in `U.col` is a list of `unknown` values.
        have h_tristate_eq_none : ∀ y ∈ U.col, tristate_eq none y = Tristate.unknown := by
          exact fun y hy => by cases y <;> tauto;
        -- Since `U.col` does not contain `none`, the list of `tristate_eq none y` for `y` in `U.col` is a list of `unknown` values, and thus `tristate_or_list` of this list is `unknown`.
        have h_tristate_or_list_none : List.foldl Tristate.or Tristate.false (List.map (fun y => Tristate.unknown) U.col) = Tristate.unknown := by
          rcases U_col : U.col with ( _ | ⟨ y, _ | ⟨ z, l ⟩ ⟩ ) <;> simp_all +decide [ List.foldl ];
          induction l.length <;> simp_all +decide [ List.replicate ];
          exact?;
        simp_all +decide [ List.map_congr_left ];
        rw [ List.map_congr_left fun y hy => h_tristate_eq_none y hy ];
        rw [ List.map_const', tristate_or_list ] ; aesop;
      · -- By definition of `tristate_or_list`, if `x` is `some a`, then `tristate_eq x y` is `true` if `y = some a` and `false` otherwise.
        have h_tristate_eq : ∀ y ∈ U.col, tristate_eq x y = if x = y then Tristate.true else Tristate.false := by
          unfold tristate_eq; aesop;
        -- By definition of `tristate_or_list`, if `x` is `some a`, then `tristate_eq x y` is `true` if `y = some a` and `false` otherwise. Therefore, `tristate_or_list` will be `true` if and only if there exists some `y ∈ U.col` such that `x = y`.
        have h_tristate_or_list : tristate_or_list (List.map (tristate_eq x) U.col) = if ∃ y ∈ U.col, x = y then Tristate.true else Tristate.false := by
          have h_tristate_or_list : ∀ {l : List (Option α)}, (∀ y ∈ l, tristate_eq x y = if x = y then Tristate.true else Tristate.false) → tristate_or_list (List.map (tristate_eq x) l) = if ∃ y ∈ l, x = y then Tristate.true else Tristate.false := by
            intros l hl; induction' l using List.reverseRecOn with y l ih <;> simp_all +decide ;
            unfold tristate_or_list at *; aesop;
          exact h_tristate_or_list h_tristate_eq;
        split_ifs at h_tristate_or_list <;> simp_all +decide;
    refine' List.filter_congr fun x hx => _;
    grind

/-
Proving that if the subquery is empty, the result is the entire table T (including NULLs), as `NOT IN ()` is always true.
-/
theorem sql_null_empty (T U : TableNull α) (h : U.col = []) :
  sql_query_null T U = T.col := by
    unfold sql_query_null;
    unfold tristate_in; aesop;

/-
Proving the complete correctness theorem that characterizes the SQL query behavior in all cases: empty subquery, subquery with NULLs, and subquery without NULLs.
-/
theorem sql_correctness (T U : TableNull α) :
  sql_query_null T U =
    if U.col = [] then T.col
    else if none ∈ U.col then []
    else T.col.filter (λ x => x ≠ none ∧ x ∉ U.col) := by
      -- We proceed by cases on whether U.col is empty or not.
      by_cases hU_empty : U.col = [];
      · unfold sql_query_null; aesop;
      · split_ifs <;> simp_all +decide [ sql_null_poison, sql_null_safe ];
