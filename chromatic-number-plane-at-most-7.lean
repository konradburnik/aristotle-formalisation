/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 8ffa19dc-6503-47ab-b6bb-0c388fa56c90
-/

/-
We define the unit distance graph on the Euclidean plane and the complex plane. We prove that the chromatic number of the plane is at most 7 by constructing a valid 7-coloring based on the Eisenstein integers. The problem of whether the chromatic number is 5, 6, or 7 is a famous open problem (Hadwiger-Nelson problem). The upper bound of 7 is the best known upper bound.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
The unit distance graph on the Euclidean plane has vertices as points in the plane and edges between points at distance 1.
-/
noncomputable def unitDistanceGraph : SimpleGraph (EuclideanSpace ℝ (Fin 2)) where
  Adj x y := dist x y = 1
  symm x y h := by
    -- Since the distance function is symmetric, we have dist x y = dist y x.
    simp [dist_comm] at h ⊢; exact h
  loopless x h := by
    -- The distance from a point to itself is 0, not 1.
    simp [dist_self] at h

/-
The unit distance graph on the complex plane has vertices as complex numbers and edges between numbers at distance 1.
-/
noncomputable def unitDistanceGraphC : SimpleGraph ℂ where
  Adj x y := dist x y = 1
  symm x y h := by
    exact h ▸ dist_comm _ _
  loopless x h := by
    norm_num at h

/-
We define the Eisenstein integers as pairs of integers $(a, b)$ representing $a + b\omega$, where $\omega = e^{i\pi/3}$. We also state that $\omega^2 - \omega + 1 = 0$ and $|\omega| = 1$.
-/
@[ext]
structure EisensteinInteger where
  a : ℤ
  b : ℤ

noncomputable def omega : ℂ := Complex.exp (Complex.I * Real.pi / 3)

noncomputable def EisensteinInteger.toComplex (z : EisensteinInteger) : ℂ :=
  z.a + z.b * omega

instance : Coe EisensteinInteger ℂ := ⟨EisensteinInteger.toComplex⟩

lemma omega_sq_sub_omega_add_one : omega ^ 2 - omega + 1 = 0 := by
  unfold omega;
  norm_num [ Complex.ext_iff, Complex.exp_re, Complex.exp_im, pow_two ] ; ring ; norm_num;
lemma norm_omega : ‖omega‖ = 1 := by
  unfold omega;
  norm_num [ Complex.norm_exp ]

/-
We define `nearestEisenstein` as a function that maps a complex number `z` to an Eisenstein integer `w` such that the distance `|z - w|` is minimized.
-/
noncomputable def nearestEisenstein (z : ℂ) : EisensteinInteger :=
  Classical.choose (show ∃ w : EisensteinInteger, ∀ w' : EisensteinInteger, ‖z - w‖ ≤ ‖z - w'‖ by
                      -- The set of Eisenstein integers is discrete and closed, so the distance function is continuous.
                      have h_closed : IsClosed {w : ℂ | ∃ w' : EisensteinInteger, w = w'.toComplex} := by
                        have h_discrete : ∀ w : EisensteinInteger, ∀ w' : EisensteinInteger, w ≠ w' → 1 ≤ ‖w.toComplex - w'.toComplex‖ := by
                          intro w w' h_ne
                          have h_dist : ‖w.toComplex - w'.toComplex‖ ^ 2 = (w.a - w'.a) ^ 2 + (w.b - w'.b) ^ 2 + (w.a - w'.a) * (w.b - w'.b) := by
                            unfold EisensteinInteger.toComplex; norm_num [ Complex.normSq, Complex.sq_norm ] ; ring;
                            unfold omega; norm_num [ Complex.exp_re, Complex.exp_im, mul_div ] ; ring;
                            norm_num ; ring;
                          have h_dist_ge_one : (w.a - w'.a : ℝ) ^ 2 + (w.b - w'.b : ℝ) ^ 2 + (w.a - w'.a : ℝ) * (w.b - w'.b : ℝ) ≥ 1 := by
                            contrapose! h_ne;
                            norm_cast at h_ne;
                            exact congr_arg₂ EisensteinInteger.mk ( by nlinarith only [ sq_nonneg ( w.a - w'.a + ( w.b - w'.b ) ), h_ne ] ) ( by nlinarith only [ sq_nonneg ( w.a - w'.a + ( w.b - w'.b ) ), h_ne ] );
                          nlinarith [ norm_nonneg ( w.toComplex - w'.toComplex ) ];
                        refine' isClosed_of_closure_subset fun w hw => _;
                        rw [ mem_closure_iff_seq_limit ] at hw;
                        obtain ⟨ x, hx₁, hx₂ ⟩ := hw;
                        -- Since the sequence $x_n$ converges to $w$, there exists an $N$ such that for all $n \geq N$, $‖x_n - w‖ < 1/2$.
                        obtain ⟨N, hN⟩ : ∃ N, ∀ n ≥ N, ‖x n - w‖ < 1 / 2 := by
                          simpa using Metric.tendsto_atTop.mp hx₂ ( 1 / 2 ) ( by norm_num );
                        -- Since $x_n$ converges to $w$, for all $n \geq N$, $x_n$ must be equal to $w$.
                        have h_eq : ∀ n ≥ N, x n = x N := by
                          intros n hn
                          obtain ⟨w', hw'⟩ := hx₁ n
                          obtain ⟨w'', hw''⟩ := hx₁ N
                          have h_dist : ‖w'.toComplex - w''.toComplex‖ < 1 := by
                            have := hN n hn; have := hN N le_rfl; simp_all +decide [ dist_eq_norm ];
                            have := norm_sub_le ( w'.toComplex - w ) ( w''.toComplex - w ) ; norm_num at * ; linarith;
                          exact Classical.not_not.1 fun h => h_dist.not_le <| h_discrete _ _ <| by aesop;
                        exact ⟨ Classical.choose ( hx₁ N ), by simpa [ h_eq ] using tendsto_nhds_unique ( hx₂.congr' ( Filter.eventuallyEq_of_mem ( Filter.Ici_mem_atTop N ) fun n hn => by rw [ h_eq n hn ] ) ) ( tendsto_const_nhds ) ▸ Classical.choose_spec ( hx₁ N ) ⟩;
                      have h_compact : IsCompact {w : ℂ | ∃ w' : EisensteinInteger, w = w'.toComplex ∧ ‖z - w‖ ≤ ‖z‖ + 1} := by
                        have h_compact : IsCompact {w : ℂ | ‖z - w‖ ≤ ‖z‖ + 1} := by
                          convert ProperSpace.isCompact_closedBall z ( ‖z‖ + 1 ) using 1 ; ext ; simp +decide [ dist_eq_norm' ];
                        convert h_compact.inter_right h_closed using 1 ; aesop;
                      -- By the properties of the distance function and the compactness of the set, there exists an Eisenstein integer $w$ such that $‖z - w‖$ is minimized.
                      obtain ⟨w, hw⟩ : ∃ w ∈ {w : ℂ | ∃ w' : EisensteinInteger, w = w'.toComplex ∧ ‖z - w‖ ≤ ‖z‖ + 1}, ∀ w' ∈ {w : ℂ | ∃ w' : EisensteinInteger, w = w'.toComplex ∧ ‖z - w‖ ≤ ‖z‖ + 1}, ‖z - w‖ ≤ ‖z - w'‖ := by
                        have h_nonempty : {w : ℂ | ∃ w' : EisensteinInteger, w = w'.toComplex ∧ ‖z - w‖ ≤ ‖z‖ + 1}.Nonempty := by
                          refine' ⟨ _, ⟨ ⟨ 0, 0 ⟩, rfl, _ ⟩ ⟩;
                          all_goals first | infer_instance | norm_num [ EisensteinInteger.toComplex ];
                        have h_continuous : ContinuousOn (fun w : ℂ => ‖z - w‖) {w : ℂ | ∃ w' : EisensteinInteger, w = w'.toComplex ∧ ‖z - w‖ ≤ ‖z‖ + 1} := by
                          exact Continuous.continuousOn ( continuous_norm.comp ( continuous_const.sub continuous_id' ) );
                        exact h_compact.exists_isMinOn h_nonempty h_continuous;
                      obtain ⟨ ⟨ w', rfl, hw' ⟩, hw'' ⟩ := hw;
                      refine' ⟨ w', fun w'' => _ ⟩;
                      grind)

/-
We define a function `toFin7` that maps an Eisenstein integer $a + b\omega$ to $(|a + 5b| \pmod 7)$.
-/
def toFin7 (z : EisensteinInteger) : Fin 7 :=
  Fin.mk ((z.a + 5 * z.b).natAbs % 7) (Nat.mod_lt _ (by norm_num))

/-
We define the coloring of the plane by scaling the complex number by $1/0.8$, finding the nearest Eisenstein integer, and then mapping it to `Fin 7`.
-/
noncomputable def planeColoring (z : ℂ) : Fin 7 :=
  toFin7 (nearestEisenstein (z / 0.8))

/-
For any real numbers $x, y$, there exist integers $a, b$ such that $(x-a)^2 + (y-b)^2 + (x-a)(y-b) \le 1/3$.
-/
lemma min_dist_A2 (x y : ℝ) : ∃ a b : ℤ, (x - a)^2 + (y - b)^2 + (x - a) * (y - b) ≤ 1/3 := by
  -- By contradiction, assume there exist $x$ and $y$ such that for all integers $a$ and $b$, $(x - a)^2 + (y - b)^2 + (x - a)(y - b) > 1/3$.
  by_contra h_contra;
  -- Let $u = x - a$ and $v = y - b$, then we need to find $a, b \in \mathbb{Z}$ such that $u^2 + v^2 + uv \leq 1/3$.
  set u := x - ⌊x + 1 / 2⌋
  set v := y - ⌊y + 1 / 2⌋
  have h_uv : u^2 + v^2 + u * v ≤ 1 / 3 ∨ (u - 1)^2 + v^2 + (u - 1) * v ≤ 1 / 3 ∨ u^2 + (v - 1)^2 + u * (v - 1) ≤ 1 / 3 ∨ (u - 1)^2 + (v - 1)^2 + (u - 1) * (v - 1) ≤ 1 / 3 ∨ u^2 + (v + 1)^2 + u * (v + 1) ≤ 1 / 3 ∨ (u + 1)^2 + v^2 + (u + 1) * v ≤ 1 / 3 := by
    have h_uv_bounds : -1 / 2 ≤ u ∧ u < 1 / 2 ∧ -1 / 2 ≤ v ∧ v < 1 / 2 := by
      exact ⟨ by norm_num1; linarith [ Int.floor_le ( x + 1 / 2 ), Int.lt_floor_add_one ( x + 1 / 2 ) ], by norm_num1; linarith [ Int.floor_le ( x + 1 / 2 ), Int.lt_floor_add_one ( x + 1 / 2 ) ], by norm_num1; linarith [ Int.floor_le ( y + 1 / 2 ), Int.lt_floor_add_one ( y + 1 / 2 ) ], by norm_num1; linarith [ Int.floor_le ( y + 1 / 2 ), Int.lt_floor_add_one ( y + 1 / 2 ) ] ⟩;
    by_cases hu : u ≤ 0 <;> by_cases hv : v ≤ 0 <;> norm_num [ hu, hv ] at h_uv_bounds ⊢;
    · exact Classical.or_iff_not_imp_left.2 fun h => Classical.or_iff_not_imp_left.2 fun h' => Classical.or_iff_not_imp_left.2 fun h'' => Classical.or_iff_not_imp_left.2 fun h''' => Classical.or_iff_not_imp_left.2 fun h'''' => by nlinarith;
    · by_cases hu : u ≥ -1 / 2 ∧ u ≤ 0 ∧ v ≥ 0 ∧ v < 1 / 2 ∧ u^2 + v^2 + u * v > 1 / 3 ∧ (u - 1)^2 + v^2 + (u - 1) * v > 1 / 3 ∧ u^2 + (v - 1)^2 + u * (v - 1) > 1 / 3 ∧ (u - 1)^2 + (v - 1)^2 + (u - 1) * (v - 1) > 1 / 3 ∧ u^2 + (v + 1)^2 + u * (v + 1) > 1 / 3 ∧ (u + 1)^2 + v^2 + (u + 1) * v > 1 / 3;
      · nlinarith only [ hu, h_uv_bounds ];
      · grind;
    · exact Classical.or_iff_not_imp_left.2 fun h => Classical.or_iff_not_imp_left.2 fun h' => Classical.or_iff_not_imp_left.2 fun h'' => Classical.or_iff_not_imp_left.2 fun h''' => Classical.or_iff_not_imp_left.2 fun h'''' => by nlinarith [ sq_nonneg ( x - ⌊x + 2⁻¹⌋ - 1 / 3 ), sq_nonneg ( y - ⌊y + 2⁻¹⌋ + 1 / 3 ) ] ;
    · exact Classical.or_iff_not_imp_left.2 fun h => Classical.or_iff_not_imp_left.2 fun h' => Classical.or_iff_not_imp_left.2 fun h'' => Classical.or_iff_not_imp_left.2 fun h''' => by nlinarith [ sq_nonneg ( x - ⌊x + 2⁻¹⌋ - ( y - ⌊y + 2⁻¹⌋ ) ), sq_nonneg ( x - ⌊x + 2⁻¹⌋ + ( y - ⌊y + 2⁻¹⌋ ) ) ] ;
  norm_num +zetaDelta at *;
  rcases h_uv with h | h | h | h | h | h <;> have := h_contra ( ⌊x + 1 / 2⌋ ) ( ⌊y + 1 / 2⌋ ) <;> have := h_contra ( ⌊x + 1 / 2⌋ + 1 ) ( ⌊y + 1 / 2⌋ ) <;> have := h_contra ( ⌊x + 1 / 2⌋ ) ( ⌊y + 1 / 2⌋ + 1 ) <;> have := h_contra ( ⌊x + 1 / 2⌋ + 1 ) ( ⌊y + 1 / 2⌋ + 1 ) <;> have := h_contra ( ⌊x + 1 / 2⌋ ) ( ⌊y + 1 / 2⌋ - 1 ) <;> have := h_contra ( ⌊x + 1 / 2⌋ - 1 ) ( ⌊y + 1 / 2⌋ ) <;> norm_num at * <;> linarith

/-
The squared norm of $x + y\omega$ is $x^2 + y^2 + xy$.
-/
lemma norm_sq_eq_quad_form (x y : ℝ) : ‖(x : ℂ) + y * omega‖ ^ 2 = x^2 + y^2 + x * y := by
  norm_num [ Complex.normSq, Complex.sq_norm ];
  unfold omega; norm_num [ Complex.exp_re, Complex.exp_im ] ; ring;
  norm_num ; ring

/-
Any complex number $z$ can be written as $x + y\omega$ for some real numbers $x, y$.
-/
lemma exists_complex_basis (z : ℂ) : ∃ x y : ℝ, z = x + y * omega := by
  -- Let $z = a + bi$. We want to find $x$ and $y$ such that $z = x + y \omega$.
  -- Since $\omega = \frac{1}{2} + \frac{\sqrt{3}}{2}i$, we can write $z = x + y \left(\frac{1}{2} + \frac{\sqrt{3}}{2}i\right)$.
  -- Equating the real and imaginary parts, we get $a = x + \frac{y}{2}$ and $b = \frac{y\sqrt{3}}{2}$.
  -- Solving these equations for $x$ and $y$, we find $y = \frac{2b}{\sqrt{3}}$ and $x = a - \frac{b}{\sqrt{3}}$.
  use (z.re - z.im / Real.sqrt 3), (2 * z.im / Real.sqrt 3);
  norm_num [ Complex.ext_iff, omega ];
  norm_num [ Complex.exp_re, Complex.exp_im ] ; ring ; norm_num

/-
The distance from any complex number to the nearest Eisenstein integer is at most $1/\sqrt{3}$.
-/
lemma dist_nearest_eisenstein (z : ℂ) : ‖z - (nearestEisenstein z).toComplex‖ ≤ 1 / Real.sqrt 3 := by
  -- By definition of `nearestEisenstein`, we know that `nearestEisenstein z` is the Eisenstein integer closest to `z`.
  obtain ⟨a, b, h_nearest⟩ : ∃ a b : ℤ, ‖z - (a + b * omega)‖ ≤ 1 / Real.sqrt 3 := by
    -- By `exists_complex_basis`, we can write $z = x + y\omega$ for some real numbers $x, y$.
    obtain ⟨x, y, hx⟩ : ∃ x y : ℝ, z = x + y * omega := exists_complex_basis z;
    -- By `min_dist_A2`, there exist integers $a, b$ such that $(x-a)^2 + (y-b)^2 + (x-a)(y-b) \le 1/3$.
    obtain ⟨a, b, h_min⟩ : ∃ a b : ℤ, (x - a)^2 + (y - b)^2 + (x - a) * (y - b) ≤ 1 / 3 := min_dist_A2 x y;
    use a, b;
    norm_num [ Complex.normSq, Complex.norm_def, hx ];
    rw [ Real.sqrt_le_left ] <;> norm_num [ Complex.exp_re, Complex.exp_im, omega ] ; ring_nf at * ; norm_num at * ; nlinarith;
  have h_nearest_def : ∀ w : EisensteinInteger, ‖z - w.toComplex‖ ≥ ‖z - (nearestEisenstein z).toComplex‖ := by
    intros w
    apply Classical.byContradiction
    intro h_contra;
    exact h_contra <| Classical.choose_spec ( _ : ∃ w : EisensteinInteger, ∀ w' : EisensteinInteger, ‖z - w‖ ≤ ‖z - w'‖ ) w;
  refine le_trans ( h_nearest_def ⟨ a, b ⟩ ) ?_;
  convert h_nearest using 1

/-
If $u + 5v$ is divisible by 7, then $u^2 + v^2 + uv$ is divisible by 7.
-/
lemma mod_seven_condition (u v : ℤ) (h : (u + 5 * v) % 7 = 0) : (u^2 + v^2 + u * v) % 7 = 0 := by
  norm_num [ Int.add_emod, Int.mul_emod, sq ] at * ; have := Int.emod_nonneg u ( by decide : ( 7 : ℤ ) ≠ 0 ) ; have := Int.emod_nonneg v ( by decide : ( 7 : ℤ ) ≠ 0 ) ; have := Int.emod_lt_of_pos u ( by decide : ( 0 : ℤ ) < 7 ) ; have := Int.emod_lt_of_pos v ( by decide : ( 0 : ℤ ) < 7 ) ; interval_cases u % 7 <;> interval_cases v % 7 <;> trivial;

/-
We define a function `toFin7_linear` that maps an Eisenstein integer $a + b\omega$ to $(a + 5b) \pmod 7$.
-/
def toFin7_linear (z : EisensteinInteger) : Fin 7 :=
  Fin.mk ((z.a + 5 * z.b) % 7).natAbs (by
  exact Int.natAbs_lt_natAbs_of_nonneg_of_lt ( Int.emod_nonneg _ ( by decide ) ) ( Int.emod_lt_of_pos _ ( by decide ) )
  )

/-
We define `planeColoring_linear` using `toFin7_linear`. We state a lemma that if two Eisenstein integers have the same color, their difference satisfies the modular condition $u + 5v \equiv 0 \pmod 7$.
-/
noncomputable def planeColoring_linear (z : ℂ) : Fin 7 :=
  toFin7_linear (nearestEisenstein (z / 0.8))

lemma diff_mod_seven_linear (w1 w2 : EisensteinInteger) (h : toFin7_linear w1 = toFin7_linear w2) :
  ((w1.a - w2.a) + 5 * (w1.b - w2.b)) % 7 = 0 := by
    unfold toFin7_linear at h;
    grind

/-
If two Eisenstein integers have the same color, the squared norm of their difference is divisible by 7.
-/
lemma same_color_implies_norm_sq_div_seven_linear (w1 w2 : EisensteinInteger) (h : toFin7_linear w1 = toFin7_linear w2) :
  ∃ k : ℤ, (w1.a - w2.a)^2 + (w1.b - w2.b)^2 + (w1.a - w2.a) * (w1.b - w2.b) = 7 * k := by
    -- Let $u = w_1.a - w_2.a$ and $v = w_1.b - w_2.b$.
    set u : ℤ := w1.a - w2.a
    set v : ℤ := w1.b - w2.b;
    exact Int.dvd_of_emod_eq_zero ( by have := diff_mod_seven_linear w1 w2 h; exact mod_seven_condition u v this )

/-
The linear coloring is a valid 7-coloring of the unit distance graph.
-/
theorem plane_coloring_linear_is_valid : ∀ x y : ℂ, dist x y = 1 → planeColoring_linear x ≠ planeColoring_linear y := by
  intros x y hxy;
  intro h_eq
  have h_norm_sq : ‖(nearestEisenstein (x / 0.8)).toComplex - (nearestEisenstein (y / 0.8)).toComplex‖^2 ≤ (2 / Real.sqrt 3 + 1.25)^2 := by
    have h_norm_sq : ‖(nearestEisenstein (x / 0.8)).toComplex - (nearestEisenstein (y / 0.8)).toComplex‖ ≤ 1 / Real.sqrt 3 + 1.25 + 1 / Real.sqrt 3 := by
      have h_triangle : ‖(nearestEisenstein (x / 0.8)).toComplex - (nearestEisenstein (y / 0.8)).toComplex‖ ≤ ‖(nearestEisenstein (x / 0.8)).toComplex - (x / 0.8)‖ + ‖(x / 0.8) - (y / 0.8)‖ + ‖(y / 0.8) - (nearestEisenstein (y / 0.8)).toComplex‖ := by
        have := norm_add_le ( ( nearestEisenstein ( x / 0.8 ) |> EisensteinInteger.toComplex ) - x / 0.8 ) ( x / 0.8 - y / 0.8 ) ; have := norm_add_le ( ( nearestEisenstein ( x / 0.8 ) |> EisensteinInteger.toComplex ) - x / 0.8 + ( x / 0.8 - y / 0.8 ) ) ( y / 0.8 - ( nearestEisenstein ( y / 0.8 ) |> EisensteinInteger.toComplex ) ) ; norm_num at * ; linarith;
      have h_dist_nearest : ‖(nearestEisenstein (x / 0.8)).toComplex - x / 0.8‖ ≤ 1 / Real.sqrt 3 ∧ ‖(nearestEisenstein (y / 0.8)).toComplex - y / 0.8‖ ≤ 1 / Real.sqrt 3 := by
        exact ⟨ by simpa [ norm_sub_rev ] using dist_nearest_eisenstein ( x / 0.8 ), by simpa [ norm_sub_rev ] using dist_nearest_eisenstein ( y / 0.8 ) ⟩;
      have h_dist_xy : ‖x / 0.8 - y / 0.8‖ = 1 / 0.8 := by
        rw [ ← sub_div, norm_div ] ; norm_num [ hxy ];
        norm_num [ dist_eq_norm ] at * ; linarith;
      norm_num [ norm_sub_rev ] at * ; linarith;
    exact pow_le_pow_left₀ ( norm_nonneg _ ) ( h_norm_sq.trans_eq ( by ring ) ) _;
  -- By `same_color_implies_norm_sq_div_seven_linear`, $\|w_x - w_y\|^2$ is divisible by 7.
  have h_div : ∃ k : ℤ, ‖(nearestEisenstein (x / 0.8)).toComplex - (nearestEisenstein (y / 0.8)).toComplex‖^2 = 7 * k := by
    have h_div : ∃ k : ℤ, ((nearestEisenstein (x / 0.8)).a - (nearestEisenstein (y / 0.8)).a)^2 + ((nearestEisenstein (x / 0.8)).b - (nearestEisenstein (y / 0.8)).b)^2 + ((nearestEisenstein (x / 0.8)).a - (nearestEisenstein (y / 0.8)).a) * ((nearestEisenstein (x / 0.8)).b - (nearestEisenstein (y / 0.8)).b) = 7 * k := by
      exact?;
    convert h_div using 1;
    norm_num [ Complex.normSq, Complex.sq_norm ];
    norm_num [ ← @Int.cast_inj ℝ ] ; ring!;
    unfold EisensteinInteger.toComplex; norm_num [ Complex.exp_re, Complex.exp_im, omega ] ; ring;
    norm_num ; ring;
  -- Since $\|w_x - w_y\|^2$ is divisible by 7 and lies in the interval $[0.009, 5.78]$, it must be equal to 0.
  obtain ⟨k, hk⟩ := h_div
  have h_k_zero : k = 0 := by
    rcases k with ⟨ _ | _ | k ⟩ <;> norm_num at *;
    · ring_nf at *; norm_num at *; nlinarith [ Real.sqrt_nonneg 3, Real.sq_sqrt zero_le_three, mul_inv_cancel₀ ( ne_of_gt ( Real.sqrt_pos.mpr zero_lt_three ) ) ] ;
    · ring_nf at *; nlinarith [ Real.sqrt_nonneg 3, Real.sq_sqrt ( show 0 ≤ 3 by norm_num ), inv_mul_cancel₀ ( ne_of_gt ( Real.sqrt_pos.mpr ( show 0 < 3 by norm_num ) ) ) ] ;
    · nlinarith;
  -- If $w_x = w_y$, then $\|z_x - z_y\| \le \|z_x - w_x\| + \|w_x - z_y\| \le 2/\sqrt{3} \approx 1.1547$.
  have h_dist_le : ‖x / 0.8 - y / 0.8‖ ≤ 2 / Real.sqrt 3 := by
    have h_dist_le : ‖x / 0.8 - (nearestEisenstein (x / 0.8)).toComplex‖ ≤ 1 / Real.sqrt 3 ∧ ‖y / 0.8 - (nearestEisenstein (y / 0.8)).toComplex‖ ≤ 1 / Real.sqrt 3 := by
      exact ⟨ dist_nearest_eisenstein _, dist_nearest_eisenstein _ ⟩;
    have h_dist_le : ‖x / 0.8 - y / 0.8‖ ≤ ‖x / 0.8 - (nearestEisenstein (x / 0.8)).toComplex‖ + ‖(nearestEisenstein (x / 0.8)).toComplex - (nearestEisenstein (y / 0.8)).toComplex‖ + ‖(nearestEisenstein (y / 0.8)).toComplex - y / 0.8‖ := by
      convert norm_add_le _ _ |> le_trans <| add_le_add_right ( norm_add_le _ _ ) _ using 1 ; ring;
    simp_all +decide [ norm_sub_rev ];
    exact h_dist_le.trans ( by ring_nf at *; linarith );
  norm_num [ dist_eq_norm ] at *;
  rw [ show x / ( 4 / 5 ) - y / ( 4 / 5 ) = ( x - y ) / ( 4 / 5 ) by ring, norm_div ] at h_dist_le ; norm_num at * ; nlinarith [ Real.sqrt_nonneg 3, Real.sq_sqrt zero_le_three, mul_div_cancel₀ 2 ( ne_of_gt ( Real.sqrt_pos.mpr zero_lt_three ) ) ]

/-
We define a valid 7-coloring of the unit distance graph using `planeColoring_linear` and prove that the chromatic number is at most 7.
-/
def validColoring : unitDistanceGraphC.Coloring (Fin 7) :=
  SimpleGraph.Coloring.mk planeColoring_linear (fun {x y} h => plane_coloring_linear_is_valid x y h)

theorem chromatic_number_le_seven : unitDistanceGraphC.chromaticNumber ≤ 7 :=
  SimpleGraph.Colorable.chromaticNumber_le ⟨validColoring⟩