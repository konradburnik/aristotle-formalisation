/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 03e5d1dc-40d1-497c-aa90-dce7c7987aad
-/

/-
We define Hadamard matrices and Williamson sequences. We construct the Williamson block matrix and prove that it yields a Hadamard matrix of order 4n, provided that Williamson sequences of order n exist. We specifically prove that the existence of Williamson sequences of order 167 implies the existence of a Hadamard matrix of order 668. The existence of Williamson sequences of order 167 is a known result (Sawade 1977), but the sequences themselves are too large to be constructed here without external data.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
Definition of a Hadamard matrix of order n.
-/
def IsHadamardMatrix (n : ℕ) (H : Matrix (Fin n) (Fin n) ℤ) : Prop :=
  (∀ i j, H i j = 1 ∨ H i j = -1) ∧ H * H.transpose = n • (1 : Matrix (Fin n) (Fin n) ℤ)

/-
Check if Matrix.circulant is available.
-/
#check Matrix.circulant

/-
Check for block matrix operations.
-/
#check Matrix.fromBlocks
#check Matrix.blockDiagonal

/-
Definition of Williamson sequences of length n.
-/
def IsWilliamsonSequences (n : ℕ) [NeZero n] (a b c d : ZMod n → ℤ) : Prop :=
  (∀ i, a (-i) = a i) ∧ (∀ i, b (-i) = b i) ∧ (∀ i, c (-i) = c i) ∧ (∀ i, d (-i) = d i) ∧
  (∀ i, a i = 1 ∨ a i = -1) ∧ (∀ i, b i = 1 ∨ b i = -1) ∧ (∀ i, c i = 1 ∨ c i = -1) ∧ (∀ i, d i = 1 ∨ d i = -1) ∧
  (Matrix.circulant a) * (Matrix.circulant a) + (Matrix.circulant b) * (Matrix.circulant b) +
  (Matrix.circulant c) * (Matrix.circulant c) + (Matrix.circulant d) * (Matrix.circulant d) =
  ((4 * n : ℕ) : ℤ) • (1 : Matrix (ZMod n) (ZMod n) ℤ)

/-
Correct definition of Williamson matrix using reindexing.
-/
def Equiv.sumSumFin4 (n : ℕ) : ((ZMod n ⊕ ZMod n) ⊕ (ZMod n ⊕ ZMod n)) ≃ (Fin 4 × ZMod n) where
  toFun := fun x => match x with
    | Sum.inl (Sum.inl i) => (0, i)
    | Sum.inl (Sum.inr i) => (1, i)
    | Sum.inr (Sum.inl i) => (2, i)
    | Sum.inr (Sum.inr i) => (3, i)
  invFun := fun x => match x.1.val with
    | 0 => Sum.inl (Sum.inl x.2)
    | 1 => Sum.inl (Sum.inr x.2)
    | 2 => Sum.inr (Sum.inl x.2)
    | 3 => Sum.inr (Sum.inr x.2)
    | _ => Sum.inl (Sum.inl x.2) -- unreachable
  left_inv := by
    intro x
    rcases x with ((i|i)|(i|i)) <;> simp
  right_inv := by
    intro x
    rcases x with ⟨i, j⟩
    fin_cases i <;> simp

def WilliamsonMatrix (n : ℕ) (a b c d : ZMod n → ℤ) : Matrix (Fin 4 × ZMod n) (Fin 4 × ZMod n) ℤ :=
  let A := Matrix.circulant a
  let B := Matrix.circulant b
  let C := Matrix.circulant c
  let D := Matrix.circulant d
  let TL := Matrix.fromBlocks A B (-B) A
  let TR := Matrix.fromBlocks C D (-D) C
  let BL := Matrix.fromBlocks (-C) D (-D) (-C)
  let BR := Matrix.fromBlocks A (-B) B A
  Matrix.reindex (Equiv.sumSumFin4 n) (Equiv.sumSumFin4 n) (Matrix.fromBlocks TL TR BL BR)

/-
If a sequence is symmetric, its circulant matrix is symmetric.
-/
theorem circulant_transpose_eq_self_of_symmetric {n : ℕ} {α : Type*} (v : ZMod n → α) (h : ∀ i, v (-i) = v i) : (Matrix.circulant v).transpose = Matrix.circulant v := by
  rw [Matrix.transpose_circulant]
  congr
  ext i
  exact h i

/-
The block Williamson matrix satisfies the Hadamard equation.
-/
def WilliamsonBlockMatrix (n : ℕ) (a b c d : ZMod n → ℤ) : Matrix ((ZMod n ⊕ ZMod n) ⊕ (ZMod n ⊕ ZMod n)) ((ZMod n ⊕ ZMod n) ⊕ (ZMod n ⊕ ZMod n)) ℤ :=
  let A := Matrix.circulant a
  let B := Matrix.circulant b
  let C := Matrix.circulant c
  let D := Matrix.circulant d
  let TL := Matrix.fromBlocks A B (-B) A
  let TR := Matrix.fromBlocks C D (-D) C
  let BL := Matrix.fromBlocks (-C) D (-D) (-C)
  let BR := Matrix.fromBlocks A (-B) B A
  Matrix.fromBlocks TL TR BL BR

theorem williamson_block_is_hadamard_eq (n : ℕ) [NeZero n] (a b c d : ZMod n → ℤ) (h : IsWilliamsonSequences n a b c d) :
  (WilliamsonBlockMatrix n a b c d) * (WilliamsonBlockMatrix n a b c d).transpose = ((4 * n : ℕ) : ℤ) • (1 : Matrix ((ZMod n ⊕ ZMod n) ⊕ (ZMod n ⊕ ZMod n)) ((ZMod n ⊕ ZMod n) ⊕ (ZMod n ⊕ ZMod n)) ℤ) := by
    revert h;
    unfold WilliamsonBlockMatrix IsWilliamsonSequences;
    simp +decide [ Matrix.fromBlocks_transpose, Matrix.fromBlocks_multiply ];
    intro ha hb hc hd ha' hb' hc' hd' h; rw [ circulant_transpose_eq_self_of_symmetric _ ha, circulant_transpose_eq_self_of_symmetric _ hb, circulant_transpose_eq_self_of_symmetric _ hc, circulant_transpose_eq_self_of_symmetric _ hd ] ; simp +decide [ ← Matrix.ext_iff, Fin.forall_fin_succ ] at *;
    -- Since matrix multiplication is commutative for circulant matrices, the products of the circulant matrices are equal.
    have h_comm : ∀ (x y : ZMod n → ℤ), Matrix.circulant x * Matrix.circulant y = Matrix.circulant y * Matrix.circulant x := by
      intro x y; ext i j; simp +decide [ Matrix.mul_apply, Matrix.circulant ] ;
      rw [ ← Equiv.sum_comp ( Equiv.subLeft i ) ] ; simp +decide [ mul_comm ] ;
      rw [ ← Equiv.sum_comp ( Equiv.subRight j ) ] ; simp +decide [ mul_comm ] ;
      exact Finset.sum_congr rfl fun _ _ => by ring;
    simp_all +decide [ add_comm, add_left_comm, add_assoc ];
    simp +decide [ Matrix.mul_apply, Finset.mul_sum _ _ _ ];
    simp +decide [ show ( 4 : Matrix ( ZMod n ) ( ZMod n ) ℤ ) = 4 • 1 by norm_num, show ( 4 : Matrix ( ( ZMod n ⊕ ZMod n ) ⊕ ZMod n ⊕ ZMod n ) ( ( ZMod n ⊕ ZMod n ) ⊕ ZMod n ⊕ ZMod n ) ℤ ) = 4 • 1 by norm_num, Matrix.one_apply ];
    erw [ show ( n : Matrix ( ZMod n ) ( ZMod n ) ℤ ) = n • 1 by norm_num, show ( n : Matrix ( ( ZMod n ⊕ ZMod n ) ⊕ ZMod n ⊕ ZMod n ) ( ( ZMod n ⊕ ZMod n ) ⊕ ZMod n ⊕ ZMod n ) ℤ ) = n • 1 by norm_num ] ; simp +decide [ Matrix.one_apply ] ;

/-
The entries of the Williamson block matrix are 1 or -1.
-/
theorem williamson_block_entries_pm_one (n : ℕ) [NeZero n] (a b c d : ZMod n → ℤ) (h : IsWilliamsonSequences n a b c d) :
  ∀ i j, WilliamsonBlockMatrix n a b c d i j = 1 ∨ WilliamsonBlockMatrix n a b c d i j = -1 := by
    -- By definition of $WilliamsonBlockMatrix$, we know that each entry is either $1$ or $-1$ because $a$, $b$, $c$, and $d$ are Williamson sequences.
    intros i j
    have h_entry : ∀ i j, (Matrix.circulant a) i j = 1 ∨ (Matrix.circulant a) i j = -1 := by
      exact fun i j => h.2.2.2.2.1 _ |> fun x => by aesop;
    have h_entry_b : ∀ i j, (Matrix.circulant b) i j = 1 ∨ (Matrix.circulant b) i j = -1 := by
      simp_all +decide [ IsWilliamsonSequences, Matrix.circulant ]
    have h_entry_c : ∀ i j, (Matrix.circulant c) i j = 1 ∨ (Matrix.circulant c) i j = -1 := by
      unfold IsWilliamsonSequences at h; aesop;
    have h_entry_d : ∀ i j, (Matrix.circulant d) i j = 1 ∨ (Matrix.circulant d) i j = -1 := by
      unfold IsWilliamsonSequences at h; aesop;
    simp_all +decide [ WilliamsonBlockMatrix ];
    rcases i with ( ( i | i ) | ( i | i ) ) <;> rcases j with ( ( j | j ) | ( j | j ) ) <;> simp +decide [ *, Matrix.fromBlocks ];
    all_goals cases h_entry_b i j <;> cases h_entry_c i j <;> cases h_entry_d i j <;> simp +decide [ * ] ;

/-
The reindexed Williamson matrix is a Hadamard matrix.
-/
def equivBlockToFin (n : ℕ) [NeZero n] : ((ZMod n ⊕ ZMod n) ⊕ (ZMod n ⊕ ZMod n)) ≃ Fin (4 * n) :=
  let e1 : ZMod n ≃ Fin n := (ZMod.finEquiv n).symm.toEquiv
  let e2 : (ZMod n ⊕ ZMod n) ⊕ (ZMod n ⊕ ZMod n) ≃ (Fin n ⊕ Fin n) ⊕ (Fin n ⊕ Fin n) :=
    Equiv.sumCongr (Equiv.sumCongr e1 e1) (Equiv.sumCongr e1 e1)
  let e3 : (Fin n ⊕ Fin n) ⊕ (Fin n ⊕ Fin n) ≃ Fin (n + n) ⊕ Fin (n + n) :=
    Equiv.sumCongr finSumFinEquiv finSumFinEquiv
  let e4 : Fin (n + n) ⊕ Fin (n + n) ≃ Fin (n + n + (n + n)) := finSumFinEquiv
  let e5 : Fin (n + n + (n + n)) ≃ Fin (4 * n) :=
    finCongr (by ring)
  e2.trans (e3.trans (e4.trans e5))

theorem williamson_final_is_hadamard (n : ℕ) [NeZero n] (a b c d : ZMod n → ℤ) (h : IsWilliamsonSequences n a b c d) :
  IsHadamardMatrix (4 * n) (Matrix.reindex (equivBlockToFin n) (equivBlockToFin n) (WilliamsonBlockMatrix n a b c d)) := by
    constructor;
    · intro i j;
      convert williamson_block_entries_pm_one n a b c d h ( equivBlockToFin n |> Equiv.symm <| i ) ( equivBlockToFin n |> Equiv.symm <| j ) using 1;
    · refine' Matrix.ext fun i j => _;
      have := williamson_block_is_hadamard_eq n a b c d h;
      convert congr_arg ( fun m : Matrix _ _ ℤ => m ( ( equivBlockToFin n ).symm i ) ( ( equivBlockToFin n ).symm j ) ) this using 1;
      · simp +decide [ ← Matrix.ext_iff ];
      · by_cases hij : i = j <;> aesop

/-
If Williamson sequences of order 167 exist, then a Hadamard matrix of order 668 exists.
-/
theorem hadamard_668_of_williamson_167 : (∃ a b c d : ZMod 167 → ℤ, IsWilliamsonSequences 167 a b c d) → ∃ H, IsHadamardMatrix 668 H := by
  rintro ⟨ a, b, c, d, h ⟩;
  exact ⟨ _, williamson_final_is_hadamard 167 a b c d h ⟩

/-
Correct definition of checkWilliamson and its correctness proof.
-/
def checkWilliamson (n : ℕ) [NeZero n] (a b c d : ZMod n → ℤ) : Bool :=
  let A := Matrix.circulant a
  let B := Matrix.circulant b
  let C := Matrix.circulant c
  let D := Matrix.circulant d
  let M := A * A + B * B + C * C + D * D
  let target := ((4 * n : ℕ) : ℤ) • (1 : Matrix (ZMod n) (ZMod n) ℤ)
  (∀ i, a (-i) = a i) ∧ (∀ i, b (-i) = b i) ∧ (∀ i, c (-i) = c i) ∧ (∀ i, d (-i) = d i) ∧
  (∀ i, a i = 1 ∨ a i = -1) ∧ (∀ i, b i = 1 ∨ b i = -1) ∧ (∀ i, c i = 1 ∨ c i = -1) ∧ (∀ i, d i = 1 ∨ d i = -1) ∧
  (∀ i j, M i j = target i j)

theorem checkWilliamson_correct (n : ℕ) [NeZero n] (a b c d : ZMod n → ℤ) :
  checkWilliamson n a b c d = true → IsWilliamsonSequences n a b c d := by
  intro h
  simp [checkWilliamson] at h
  obtain ⟨h_symm_a, h_symm_b, h_symm_c, h_symm_d, h_val_a, h_val_b, h_val_c, h_val_d, h_eq⟩ := h
  refine ⟨h_symm_a, h_symm_b, h_symm_c, h_symm_d, h_val_a, h_val_b, h_val_c, h_val_d, ?_⟩
  ext i j
  exact h_eq i j

/-
Check if jacobiSym is available.
-/
#check jacobiSym