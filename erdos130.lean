/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 98adc6f6-d312-4be5-81f1-820d632730f6

Aristotle's budget for this request has been reached.
If there is partial progress, it will appear in this file.
If you would like to continue working off of this partial progress,
please submit the same prompt, and add this .lean file in "Optional: Attach a Lean file as context" field.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

open EuclideanGeometry
abbrev Point := EuclideanSpace ℝ (Fin 2)
#check Collinear
#check Concyclic

/-
Definition of the set A and the integer distance graph on A.
-/
open EuclideanGeometry Metric

def Erdos130Property (A : Set Point) : Prop :=
  A.Infinite ∧
  (∀ s ⊆ A, s.ncard = 3 → ¬ Collinear ℝ s) ∧
  (∀ s ⊆ A, s.ncard = 4 → ¬ Concyclic s)

def integerDistanceGraph (A : Set Point) : SimpleGraph A where
  Adj x y := ∃ (n : ℕ), n > 0 ∧ dist x.1 y.1 = n
  symm x y h := by
    -- Since distance is symmetric, we have dist x y = dist y x.
    have h_symm : dist x.val y.val = dist y.val x.val := by
      -- The distance function is symmetric by definition.
      apply dist_comm;
    -- Since distance is symmetric, we can use the same n from h to satisfy the condition for y and x.
    obtain ⟨n, hn_pos, hn_eq⟩ := h;
    use n;
    aesop
  loopless x h := by
    -- Since the distance from a point to itself is zero, we have `dist x x = 0`.
    have h_dist_zero : dist x x = 0 := by
      -- The distance from a point to itself is zero by definition.
      apply dist_self;
    -- Since the distance from a point to itself is zero, we have `dist x x = 0`, which contradicts the existence of a positive integer `n` such that `dist x x = n`.
    obtain ⟨n, hn_pos, hn_eq⟩ := h
    have h_contra : 0 = n := by
      exact_mod_cast h_dist_zero.symm.trans hn_eq
    exact absurd h_contra (by linarith [hn_pos])

/-
Definitions of the maximum chromatic number and clique number for the integer distance graph on a set A satisfying the Erdos 130 property.
-/
open EuclideanGeometry Metric

noncomputable def maxChromaticNumber : ℕ∞ := ⨆ (A : Set Point) (_ : Erdos130Property A), (integerDistanceGraph A).chromaticNumber

noncomputable def maxCliqueNumber : ℕ∞ := ⨆ (A : Set Point) (_ : Erdos130Property A), (integerDistanceGraph A).cliqueNum

/-
There exists a set of 3 points in general position with integer distances.
-/
open EuclideanGeometry Metric

def GeneralPosition (s : Set Point) : Prop :=
  (∀ t ⊆ s, t.ncard = 3 → ¬ Collinear ℝ t) ∧
  (∀ t ⊆ s, t.ncard = 4 → ¬ Concyclic t)

def IntegerDistanceSet (s : Set Point) : Prop :=
  ∀ x ∈ s, ∀ y ∈ s, ∃ n : ℕ, dist x y = n

theorem exists_clique_size_three : ∃ s : Set Point, s.ncard = 3 ∧ IntegerDistanceSet s ∧ GeneralPosition s := by
  unfold GeneralPosition IntegerDistanceSet; norm_num [ Set.ncard_eq_three ] ;
  refine' ⟨ _, ⟨ 0, EuclideanSpace.single 0 3, _, EuclideanSpace.single 1 4, _, _, rfl ⟩, _, _, _ ⟩ <;> norm_num [ collinear_pair ];
  any_goals intro h; have := congr_fun h 0; have := congr_fun h 1; norm_num at *;
  · norm_num [ EuclideanSpace.dist_eq ] ; norm_cast ; aesop;
  · rintro t ht x y hxy z hxz hyz rfl; simp_all +decide [ collinear_iff_exists_forall_eq_smul_vadd ] ;
    simp_all +decide [ Set.subset_def ];
    rcases ht with ⟨ rfl | rfl | rfl, rfl | rfl | rfl, rfl | rfl | rfl ⟩ <;> norm_num at *;
    all_goals intro x y a ha b hb c hc; rw [ ← List.ofFn_inj ] at *; norm_num at * ; nlinarith;
  · intro t ht hcard; have := Set.ncard_le_ncard ht; simp_all +decide ;
    exact absurd this ( by exact not_le_of_gt ( lt_of_le_of_lt ( Set.ncard_insert_le _ _ ) ( by exact lt_of_le_of_lt ( add_le_add_right ( Set.ncard_insert_le _ _ ) _ ) ( by norm_num ) ) ) )

/-
There exists a set of 4 points in general position with integer distances.
-/
open EuclideanGeometry Metric

theorem exists_clique_size_four : ∃ s : Set Point, s.ncard = 4 ∧ IntegerDistanceSet s ∧ GeneralPosition s := by
  refine' ⟨ { ![3, 0], ![-3, 0], ![0, 4], ![0, -4] }, _, _, _ ⟩ <;> norm_num [ Set.ncard_eq_toFinset_card' ];
  · rw [ Finset.card_insert_of_notMem, Finset.card_insert_of_notMem, Finset.card_insert_of_notMem, Finset.card_singleton ] <;> norm_num [ ← List.ofFn_inj ];
    · exact ne_of_apply_ne ( fun x => x 1 ) ( by norm_num );
    · exact ⟨ ne_of_apply_ne ( fun x => x 0 ) ( by norm_num ), ne_of_apply_ne ( fun x => x 0 ) ( by norm_num ) ⟩;
    · exact ⟨ ne_of_apply_ne ( fun x => x 0 ) ( by norm_num ), ne_of_apply_ne ( fun x => x 0 ) ( by norm_num ), ne_of_apply_ne ( fun x => x 0 ) ( by norm_num ) ⟩;
  · intro x hx y hy;
    rcases hx with ( rfl | rfl | rfl | rfl ) <;> rcases hy with ( rfl | rfl | rfl | rfl ) <;> norm_num [ dist_eq_norm, EuclideanSpace.norm_eq ];
    all_goals norm_cast; aesop;
  · constructor <;> intro t ht ht' <;> simp_all +decide [ Set.ncard_eq_toFinset_card' ];
    · rw [ Set.ncard_eq_three ] at ht';
      rcases ht' with ⟨ x, y, z, hxy, hxz, hyz, rfl ⟩ ; simp_all +decide [ Set.subset_def, collinear_iff_exists_forall_eq_smul_vadd ] ;
      rintro x y a ha b hb c hc; rcases ht with ⟨ rfl | rfl | rfl | rfl, rfl | rfl | rfl | rfl, rfl | rfl | rfl | rfl ⟩ <;> norm_num [ ← List.ofFn_inj ] at *;
      all_goals rw [ ← @List.ofFn_inj ] at *; norm_num at * ;
      all_goals nlinarith!;
    · rw [ Set.eq_of_subset_of_ncard_le ht ];
      · rintro ⟨ c, hc ⟩;
        obtain ⟨ x, hx ⟩ := c;
        norm_num [ dist_eq_norm, EuclideanSpace.norm_eq ] at hx;
        rw [ Real.sqrt_inj ( by positivity ) ( by positivity ), Real.sqrt_inj ( by positivity ) ( by positivity ), Real.sqrt_inj ( by positivity ) ( by positivity ) ] at hx ; nlinarith;
      · rw [ ht' ];
        exact le_trans ( Set.ncard_insert_le _ _ ) ( add_le_add_right ( le_trans ( Set.ncard_insert_le _ _ ) ( add_le_add_right ( le_trans ( Set.ncard_insert_le _ _ ) ( by norm_num ) ) _ ) ) _ )

/-
Search for valid integer distances for the 5th point.
-/
def findValidDistances : List (ℕ × ℕ × ℕ × ℕ) := Id.run do
  let mut results := []
  for d1 in [1:20] do
    for d2 in [1:20] do
      for d3 in [1:20] do
        for d4 in [1:20] do
          let x_num : ℤ := (d2 : ℤ)^2 - (d1 : ℤ)^2
          let y_num : ℤ := (d4 : ℤ)^2 - (d3 : ℤ)^2
          -- Check if x and y are valid coordinates (we need the equation to hold)
          -- 2 * (x_num/12)^2 + 2 * (y_num/16)^2 = d1^2 + d2^2 - 18
          -- Multiply by 144 * 256 to clear denominators?
          -- LCM(144, 256) = 2304.
          -- 12^2 = 144. 16^2 = 256.
          -- 2 * x_num^2 / 144 + 2 * y_num^2 / 256 = d1^2 + d2^2 - 18
          -- x_num^2 / 72 + y_num^2 / 128 = d1^2 + d2^2 - 18
          -- Multiply by 1152 (LCM of 72 and 128):
          -- 16 * x_num^2 + 9 * y_num^2 = 1152 * (d1^2 + d2^2 - 18)
          if 16 * x_num^2 + 9 * y_num^2 == 1152 * ((d1 : ℤ)^2 + (d2 : ℤ)^2 - 18) then
             -- Check non-collinear and non-concyclic conditions roughly
             if x_num != 0 && y_num != 0 then
               results := results.concat (d1, d2, d3, d4)
  return results

#eval findValidDistances

/-
Search for an integer point with integer distances to the rhombus vertices.
-/
def findIntegerPoint : List (ℤ × ℤ) := Id.run do
  let mut results : List (ℤ × ℤ) := []
  for x in List.range 41 do
    let x_int : ℤ := x - 20
    for y in List.range 41 do
      let y_int : ℤ := y - 20
      let d1_sq := (x_int - 3)^2 + y_int^2
      let d2_sq := (x_int + 3)^2 + y_int^2
      let d3_sq := x_int^2 + (y_int - 4)^2
      let d4_sq := x_int^2 + (y_int + 4)^2
      let d1 := Int.sqrt d1_sq
      let d2 := Int.sqrt d2_sq
      let d3 := Int.sqrt d3_sq
      let d4 := Int.sqrt d4_sq
      if d1 * d1 == d1_sq && d2 * d2 == d2_sq && d3 * d3 == d3_sq && d4 * d4 == d4_sq then
        -- Check general position (not collinear with any pair, not concyclic with any triple)
        -- The vertices are p1(3,0), p2(-3,0), p3(0,4), p4(0,-4).
        -- Check p not equal to any pi.
        if !((x_int == 3 && y_int == 0) || (x_int == -3 && y_int == 0) || (x_int == 0 && y_int == 4) || (x_int == 0 && y_int == -4)) then
           results := results.concat (x_int, y_int)
  return results

#eval! findIntegerPoint

/-
Search for a 5th point in general position with integer distances to the rhombus vertices.
-/
def findIntegerPointGeneralPosition : List (ℤ × ℤ) := Id.run do
  let mut results : List (ℤ × ℤ) := []
  for x in List.range 41 do
    let x_int : ℤ := x - 20
    for y in List.range 41 do
      let y_int : ℤ := y - 20
      let d1_sq := (x_int - 3)^2 + y_int^2
      let d2_sq := (x_int + 3)^2 + y_int^2
      let d3_sq := x_int^2 + (y_int - 4)^2
      let d4_sq := x_int^2 + (y_int + 4)^2
      let d1 := Int.sqrt d1_sq
      let d2 := Int.sqrt d2_sq
      let d3 := Int.sqrt d3_sq
      let d4 := Int.sqrt d4_sq
      if d1 * d1 == d1_sq && d2 * d2 == d2_sq && d3 * d3 == d3_sq && d4 * d4 == d4_sq then
        -- Check not equal to vertices
        if !((x_int == 3 && y_int == 0) || (x_int == -3 && y_int == 0) || (x_int == 0 && y_int == 4) || (x_int == 0 && y_int == -4)) then
          -- Check not collinear with any pair
          -- AB: y=0
          let not_AB := y_int != 0
          -- CD: x=0
          let not_CD := x_int != 0
          -- AC: 4x + 3y = 12
          let not_AC := 4 * x_int + 3 * y_int != 12
          -- AD: 4x - 3y = 12
          let not_AD := 4 * x_int - 3 * y_int != 12
          -- BC: -4x + 3y = 12
          let not_BC := -4 * x_int + 3 * y_int != 12
          -- BD: -4x - 3y = 12
          let not_BD := -4 * x_int - 3 * y_int != 12

          -- Check not concyclic with any triple
          -- ABC: 4x^2 + 4y^2 - 7y - 36 = 0
          let not_ABC := 4 * x_int^2 + 4 * y_int^2 - 7 * y_int - 36 != 0
          -- ABD: 4x^2 + 4y^2 + 7y - 36 = 0
          let not_ABD := 4 * x_int^2 + 4 * y_int^2 + 7 * y_int - 36 != 0
          -- ACD: 3x^2 + 3y^2 + 7x - 48 = 0
          let not_ACD := 3 * x_int^2 + 3 * y_int^2 + 7 * x_int - 48 != 0
          -- BCD: 3x^2 + 3y^2 - 7x - 48 = 0
          let not_BCD := 3 * x_int^2 + 3 * y_int^2 - 7 * x_int - 48 != 0

          if not_AB && not_CD && not_AC && not_AD && not_BC && not_BD && not_ABC && not_ABD && not_ACD && not_BCD then
             results := results.concat (x_int, y_int)
  return results

#eval! findIntegerPointGeneralPosition

/-
Search for valid integer distances for a 5th point in general position.
-/
def findValidDistancesStrict : List (ℕ × ℕ × ℕ × ℕ) := Id.run do
  let mut results := []
  for d1 in [1:50] do
    for d2 in [1:50] do
      for d3 in [1:50] do
        for d4 in [1:50] do
          let x_num : ℤ := (d2 : ℤ)^2 - (d1 : ℤ)^2
          let y_num : ℤ := (d4 : ℤ)^2 - (d3 : ℤ)^2
          -- x = x_num / 12, y = y_num / 16
          -- Check (x-3)^2 + y^2 = d1^2
          -- (x_num/12 - 3)^2 + (y_num/16)^2 = d1^2
          -- (x_num - 36)^2 / 144 + y_num^2 / 256 = d1^2
          -- Multiply by 2304 (16*144 = 9*256 = 2304)
          -- 16 * (x_num - 36)^2 + 9 * y_num^2 = 2304 * d1^2
          if 16 * (x_num - 36)^2 + 9 * y_num^2 == 2304 * (d1 : ℤ)^2 then
             -- Check general position
             -- x = x_num/12, y = y_num/16
             -- P != A, B, C, D
             let not_vertex := !((x_num == 36 && y_num == 0) || (x_num == -36 && y_num == 0) || (x_num == 0 && y_num == 64) || (x_num == 0 && y_num == -64))
             if not_vertex then
               -- Collinearity
               -- AB: y=0 => y_num=0
               let not_AB := y_num != 0
               -- CD: x=0 => x_num=0
               let not_CD := x_num != 0
               -- AC: 4x + 3y = 12 => 4(x_num/12) + 3(y_num/16) = 12 => x_num/3 + 3*y_num/16 = 12 => 16*x_num + 9*y_num = 576
               let not_AC := 16 * x_num + 9 * y_num != 576
               -- AD: 4x - 3y = 12 => 16*x_num - 9*y_num = 576
               let not_AD := 16 * x_num - 9 * y_num != 576
               -- BC: -4x + 3y = 12 => -16*x_num + 9*y_num = 576
               let not_BC := -16 * x_num + 9 * y_num != 576
               -- BD: -4x - 3y = 12 => -16*x_num - 9*y_num = 576
               let not_BD := -16 * x_num - 9 * y_num != 576

               -- Concyclic
               -- ABC: 4x^2 + 4y^2 - 7y - 36 = 0
               -- 4(x_num/12)^2 + 4(y_num/16)^2 - 7(y_num/16) - 36 = 0
               -- x_num^2/36 + y_num^2/64 - 7*y_num/16 - 36 = 0
               -- Multiply by 576:
               -- 16*x_num^2 + 9*y_num^2 - 252*y_num - 20736 = 0
               let not_ABC := 16 * x_num^2 + 9 * y_num^2 - 252 * y_num - 20736 != 0

               -- ABD: 4x^2 + 4y^2 + 7y - 36 = 0
               -- 16*x_num^2 + 9*y_num^2 + 252*y_num - 20736 = 0
               let not_ABD := 16 * x_num^2 + 9 * y_num^2 + 252 * y_num - 20736 != 0

               -- ACD: 3x^2 + 3y^2 + 7x - 48 = 0
               -- 3(x_num/12)^2 + 3(y_num/16)^2 + 7(x_num/12) - 48 = 0
               -- x_num^2/48 + 3*y_num^2/256 + 7*x_num/12 - 48 = 0
               -- Multiply by 768:
               -- 16*x_num^2 + 9*y_num^2 + 448*x_num - 36864 = 0
               let not_ACD := 16 * x_num^2 + 9 * y_num^2 + 448 * x_num - 36864 != 0

               -- BCD: 3x^2 + 3y^2 - 7x - 48 = 0
               -- 16*x_num^2 + 9*y_num^2 - 448*x_num - 36864 = 0
               let not_BCD := 16 * x_num^2 + 9 * y_num^2 - 448 * x_num - 36864 != 0

               if not_AB && not_CD && not_AC && not_AD && not_BC && not_BD && not_ABC && not_ABD && not_ACD && not_BCD then
                 results := results.concat (d1, d2, d3, d4)
  return results

#eval findValidDistancesStrict

/-
Search for a set of 5 points with integer distances, no 3 collinear, no 4 concyclic.
-/
def findFivePoints : List (List (ℤ × ℤ)) := Id.run do
  let range := 15
  let mut points := []
  for x in [0:2*range+1] do
    for y in [0:2*range+1] do
      points := points.concat ((x - range : ℤ), (y - range : ℤ))
  
  let p1 := (0, 0)
  let candidates := points.filter (fun p => p != p1)

  let distSq (p1 p2 : ℤ × ℤ) : ℤ := (p1.1 - p2.1)^2 + (p1.2 - p2.2)^2
  let isIntDist (p1 p2 : ℤ × ℤ) : Bool :=
    let d2 := distSq p1 p2
    let d := Int.sqrt d2
    d * d == d2

  let isCollinear (p1 p2 p3 : ℤ × ℤ) : Bool :=
    (p2.1 - p1.1) * (p3.2 - p1.2) == (p2.2 - p1.2) * (p3.1 - p1.1)

  let isConcyclic (p1 p2 p3 p4 : ℤ × ℤ) : Bool :=
    let m (p : ℤ × ℤ) : ℤ × ℤ × ℤ × ℤ := (p.1^2 + p.2^2, p.1, p.2, 1)
    let (a1, a2, a3, a4) := m p1
    let (b1, b2, b3, b4) := m p2
    let (c1, c2, c3, c4) := m p3
    let (d1, d2, d3, d4) := m p4
    let det :=
      a1 * (b2 * (c3 * d4 - c4 * d3) - b3 * (c2 * d4 - c4 * d2) + b4 * (c2 * d3 - c3 * d2)) -
      a2 * (b1 * (c3 * d4 - c4 * d3) - b3 * (c1 * d4 - c4 * d1) + b4 * (c1 * d3 - c3 * d1)) +
      a3 * (b1 * (c2 * d4 - c4 * d2) - b2 * (c1 * d4 - c4 * d1) + b4 * (c1 * d2 - c2 * d1)) -
      a4 * (b1 * (c2 * d3 - c3 * d2) - b2 * (c1 * d3 - c3 * d1) + b3 * (c1 * d2 - c2 * d1))
    det == 0

  for i2 in [0:candidates.length] do
    let p2 := candidates[i2]!
    if isIntDist p1 p2 then
      for i3 in [i2+1:candidates.length] do
        let p3 := candidates[i3]!
        if isIntDist p1 p3 && isIntDist p2 p3 && !isCollinear p1 p2 p3 then
          for i4 in [i3+1:candidates.length] do
            let p4 := candidates[i4]!
            if isIntDist p1 p4 && isIntDist p2 p4 && isIntDist p3 p4 &&
               !isCollinear p1 p2 p4 && !isCollinear p1 p3 p4 && !isCollinear p2 p3 p4 &&
               !isConcyclic p1 p2 p3 p4 then
               for i5 in [i4+1:candidates.length] do
                 let p5 := candidates[i5]!
                 if isIntDist p1 p5 && isIntDist p2 p5 && isIntDist p3 p5 && isIntDist p4 p5 &&
                    !isCollinear p1 p2 p5 && !isCollinear p1 p3 p5 && !isCollinear p1 p4 p5 &&
                    !isCollinear p2 p3 p5 && !isCollinear p2 p4 p5 && !isCollinear p3 p4 p5 &&
                    !isConcyclic p1 p2 p3 p5 && !isConcyclic p1 p2 p4 p5 && !isConcyclic p1 p3 p4 p5 && !isConcyclic p2 p3 p4 p5 then
                    return [[p1, p2, p3, p4, p5]]
  return []

#eval! findFivePoints

/-
Search for a set of 5 points with integer distances, no 3 collinear, no 4 concyclic.
-/
def det3 (a1 a2 a3 b1 b2 b3 c1 c2 c3 : ℤ) : ℤ :=
  a1 * (b2 * c3 - b3 * c2) - a2 * (b1 * c3 - b3 * c1) + a3 * (b1 * c2 - b2 * c1)

def det4 (a1 a2 a3 a4 b1 b2 b3 b4 c1 c2 c3 c4 d1 d2 d3 d4 : ℤ) : ℤ :=
  a1 * det3 b2 b3 b4 c2 c3 c4 d2 d3 d4 -
  a2 * det3 b1 b3 b4 c1 c3 c4 d1 d3 d4 +
  a3 * det3 b1 b2 b4 c1 c2 c4 d1 d2 d4 -
  a4 * det3 b1 b2 b3 c1 c2 c3 d1 d2 d3

def findFivePointsV2 : List (List (ℤ × ℤ)) := Id.run do
  let range := 15
  let mut points := []
  for x in List.range (2 * range + 1) do
    for y in List.range (2 * range + 1) do
      points := points.concat ((x : ℤ) - range, (y : ℤ) - range)
  
  let p1 := (0, 0)
  let candidates := points.filter (fun p => p != p1)

  let distSq (p1 p2 : ℤ × ℤ) : ℤ := (p1.1 - p2.1)^2 + (p1.2 - p2.2)^2
  let isIntDist (p1 p2 : ℤ × ℤ) : Bool :=
    let d2 := distSq p1 p2
    let d := Int.sqrt d2
    d * d == d2

  let isCollinear (p1 p2 p3 : ℤ × ℤ) : Bool :=
    (p2.1 - p1.1) * (p3.2 - p1.2) == (p2.2 - p1.2) * (p3.1 - p1.1)

  let isConcyclic (p1 p2 p3 p4 : ℤ × ℤ) : Bool :=
    let a1 := p1.1^2 + p1.2^2; let a2 := p1.1; let a3 := p1.2; let a4 := 1
    let b1 := p2.1^2 + p2.2^2; let b2 := p2.1; let b3 := p2.2; let b4 := 1
    let c1 := p3.1^2 + p3.2^2; let c2 := p3.1; let c3 := p3.2; let c4 := 1
    let d1 := p4.1^2 + p4.2^2; let d2 := p4.1; let d3 := p4.2; let d4 := 1
    det4 a1 a2 a3 a4 b1 b2 b3 b4 c1 c2 c3 c4 d1 d2 d3 d4 == 0

  for i2 in List.range candidates.length do
    let p2 := candidates.get! i2
    if isIntDist p1 p2 then
      for i3 in List.range (candidates.length - (i2 + 1)) do
        let p3 := candidates.get! (i2 + 1 + i3)
        if isIntDist p1 p3 && isIntDist p2 p3 && !isCollinear p1 p2 p3 then
          for i4 in List.range (candidates.length - (i2 + 1 + i3 + 1)) do
            let p4 := candidates.get! (i2 + 1 + i3 + 1 + i4)
            if isIntDist p1 p4 && isIntDist p2 p4 && isIntDist p3 p4 &&
               !isCollinear p1 p2 p4 && !isCollinear p1 p3 p4 && !isCollinear p2 p3 p4 &&
               !isConcyclic p1 p2 p3 p4 then
               for i5 in List.range (candidates.length - (i2 + 1 + i3 + 1 + i4 + 1)) do
                 let p5 := candidates.get! (i2 + 1 + i3 + 1 + i4 + 1 + i5)
                 if isIntDist p1 p5 && isIntDist p2 p5 && isIntDist p3 p5 && isIntDist p4 p5 &&
                    !isCollinear p1 p2 p5 && !isCollinear p1 p3 p5 && !isCollinear p1 p4 p5 &&
                    !isCollinear p2 p3 p5 && !isCollinear p2 p4 p5 && !isCollinear p3 p4 p5 &&
                    !isConcyclic p1 p2 p3 p5 && !isConcyclic p1 p2 p4 p5 && !isConcyclic p1 p3 p4 p5 && !isConcyclic p2 p3 p4 p5 then
                    return [[p1, p2, p3, p4, p5]]
  return []

#eval! findFivePointsV2

/-
Search for valid integer distances for a 5th point in general position.
-/
def findFifthPointDistances : List (ℕ × ℕ × ℕ × ℕ) := Id.run do
  let mut results := []
  for d1 in [1:50] do
    for d2 in [1:50] do
      for d3 in [1:50] do
        for d4 in [1:50] do
          let x_num : ℤ := (d2 : ℤ)^2 - (d1 : ℤ)^2
          let y_num : ℤ := (d4 : ℤ)^2 - (d3 : ℤ)^2
          -- x = x_num / 12, y = y_num / 16
          -- Check (x-3)^2 + y^2 = d1^2
          -- (x_num/12 - 3)^2 + (y_num/16)^2 = d1^2
          -- (x_num - 36)^2 / 144 + y_num^2 / 256 = d1^2
          -- Multiply by 2304:
          -- 16 * (x_num - 36)^2 + 9 * y_num^2 = 2304 * d1^2
          if 16 * (x_num - 36)^2 + 9 * y_num^2 == 2304 * (d1 : ℤ)^2 then
             -- Check general position
             -- P != A, B, C, D
             -- A(3,0) => x=3, y=0 => x_num=36, y_num=0
             -- B(-3,0) => x=-3, y=0 => x_num=-36, y_num=0
             -- C(0,4) => x=0, y=4 => x_num=0, y_num=64
             -- D(0,-4) => x=0, y=-4 => x_num=0, y_num=-64
             let not_vertex := !((x_num == 36 && y_num == 0) || (x_num == -36 && y_num == 0) || (x_num == 0 && y_num == 64) || (x_num == 0 && y_num == -64))
             if not_vertex then
               -- Collinearity
               -- AB: y=0 => y_num=0
               let not_AB := y_num != 0
               -- CD: x=0 => x_num=0
               let not_CD := x_num != 0
               -- AC: 4x + 3y = 12 => 16*x_num + 9*y_num = 576
               let not_AC := 16 * x_num + 9 * y_num != 576
               -- AD: 4x - 3y = 12 => 16*x_num - 9*y_num = 576
               let not_AD := 16 * x_num - 9 * y_num != 576
               -- BC: -4x + 3y = 12 => -16*x_num + 9*y_num = 576
               let not_BC := -16 * x_num + 9 * y_num != 576
               -- BD: -4x - 3y = 12 => -16*x_num - 9*y_num = 576
               let not_BD := -16 * x_num - 9 * y_num != 576

               -- Concyclic
               -- ABC: 16*x_num^2 + 9*y_num^2 - 252*y_num - 20736 = 0
               let not_ABC := 16 * x_num^2 + 9 * y_num^2 - 252 * y_num - 20736 != 0
               -- ABD: 16*x_num^2 + 9*y_num^2 + 252*y_num - 20736 = 0
               let not_ABD := 16 * x_num^2 + 9 * y_num^2 + 252 * y_num - 20736 != 0
               -- ACD: 16*x_num^2 + 9*y_num^2 + 448*x_num - 36864 = 0
               let not_ACD := 16 * x_num^2 + 9 * y_num^2 + 448 * x_num - 36864 != 0
               -- BCD: 16*x_num^2 + 9*y_num^2 - 448*x_num - 36864 = 0
               let not_BCD := 16 * x_num^2 + 9 * y_num^2 - 448 * x_num - 36864 != 0

               if not_AB && not_CD && not_AC && not_AD && not_BC && not_BD && not_ABC && not_ABD && not_ACD && not_BCD then
                 results := results.concat (d1, d2, d3, d4)
  return results

#eval findFifthPointDistances

/-
Search for valid integer distances for a 5th point in general position.
-/
def findCorrectDistances : List (ℕ × ℕ × ℕ × ℕ) := Id.run do
  let mut results := []
  for d1 in [1:50] do
    for d2 in [1:50] do
      for d3 in [1:50] do
        for d4 in [1:50] do
          let d1_sq := (d1 : ℤ)^2
          let d2_sq := (d2 : ℤ)^2
          let d3_sq := (d3 : ℤ)^2
          let d4_sq := (d4 : ℤ)^2
          if d1_sq + d2_sq + 14 == d3_sq + d4_sq then
             let x_num := d2_sq - d1_sq
             let y_num := d4_sq - d3_sq
             -- 16 * x_num^2 + 9 * y_num^2 = 1152 * (d1^2 + d2^2 - 18)
             if 16 * x_num^2 + 9 * y_num^2 == 1152 * (d1_sq + d2_sq - 18) then
               -- Check general position
               -- x = x_num/12, y = y_num/16
               -- P != A, B, C, D
               let not_vertex := !((x_num == 36 && y_num == 0) || (x_num == -36 && y_num == 0) || (x_num == 0 && y_num == 64) || (x_num == 0 && y_num == -64))
               if not_vertex then
                 -- Collinearity
                 let not_AB := y_num != 0
                 let not_CD := x_num != 0
                 let not_AC := 16 * x_num + 9 * y_num != 576
                 let not_AD := 16 * x_num - 9 * y_num != 576
                 let not_BC := -16 * x_num + 9 * y_num != 576
                 let not_BD := -16 * x_num - 9 * y_num != 576

                 -- Concyclic
                 let not_ABC := 16 * x_num^2 + 9 * y_num^2 - 252 * y_num - 20736 != 0
                 let not_ABD := 16 * x_num^2 + 9 * y_num^2 + 252 * y_num - 20736 != 0
                 let not_ACD := 16 * x_num^2 + 9 * y_num^2 + 448 * x_num - 36864 != 0
                 let not_BCD := 16 * x_num^2 + 9 * y_num^2 - 448 * x_num - 36864 != 0

                 if not_AB && not_CD && not_AC && not_AD && not_BC && not_BD && not_ABC && not_ABD && not_ACD && not_BCD then
                   results := results.concat (d1, d2, d3, d4)
  return results

#eval findCorrectDistances

/-
Definition of a hyperbola as the set of points with a constant difference of distances to two foci.
-/
open EuclideanGeometry Metric

def Hyperbola (p1 p2 : Point) (r : ℝ) : Set Point :=
  {p | |dist p p1 - dist p p2| = r}

/-
The set of integer values that the difference of distances to two points can take is finite.
-/
open EuclideanGeometry Metric

lemma range_of_dist_diff_is_finite (p1 p2 : Point) : {k : ℤ | ∃ x, |dist x p1 - dist x p2| = k}.Finite := by
  -- The set of integer values that the difference of distances can take is finite because the difference of distances is bounded.
  have h_bounded : ∃ M : ℝ, ∀ x : Point, |dist x p1 - dist x p2| ≤ M := by
    use dist p1 p2;
    intro x;
    convert dist_dist_dist_le _ _ _ _ using 1;
    norm_num;
  cases' h_bounded with M hM; exact Set.Finite.subset ( Set.finite_Icc ( 0 : ℤ ) ⌈M⌉₊ ) ( by rintro k ⟨ x, hx ⟩ ; exact ⟨ by exact_mod_cast hx ▸ abs_nonneg _, by exact_mod_cast hx ▸ le_trans ( hM x ) ( Nat.le_ceil _ ) ⟩ ) ;

/-
The points on a hyperbola satisfy a quadratic equation.
-/
open EuclideanGeometry Metric Real
open scoped RealInnerProductSpace

def dist_sq_diff (p1 p2 : Point) (x : Point) : ℝ := dist x p1 ^ 2 - dist x p2 ^ 2

lemma dist_sq_diff_eq_linear (p1 p2 : Point) (x : Point) :
  dist_sq_diff p1 p2 x = -2 * ⟪p1 - p2, x⟫ + ‖p1‖^2 - ‖p2‖^2 := by
    unfold dist_sq_diff; simp +decide [ dist_eq_norm, EuclideanSpace.norm_eq ];
    norm_num [ Real.sq_sqrt ( add_nonneg ( sq_nonneg _ ) ( sq_nonneg _ ) ), inner ] ; ring

def hyperbola_equation (p1 p2 : Point) (k : ℝ) (x : Point) : ℝ :=
  4 * (dist_sq_diff p1 p2 x)^2 - 4 * k^2 * (2 * (dist x p1)^2 + 2 * (dist x p2)^2 - k^2)

lemma hyperbola_subset_quadric (p1 p2 : Point) (k : ℝ) (x : Point) :
  |dist x p1 - dist x p2| = k → hyperbola_equation p1 p2 k x = 0 := by
    unfold hyperbola_equation;
    intro hk;
    rw [ ← hk, sq_abs ];
    unfold dist_sq_diff; ring;