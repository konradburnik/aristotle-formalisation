/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: ae1d1cac-b22d-4e29-a375-72f49be29401

Aristotle's budget for this request has been reached.
If there is partial progress, it will appear in this file.
If you would like to continue working off of this partial progress,
please submit the same prompt, and add this .lean file in "Optional: Attach a Lean file as context" field.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

#check Fin.rev

/-
Definition of a centrosymmetric matrix.
-/
def IsCentrosymmetric {n : ℕ} {α : Type*} (A : Matrix (Fin n) (Fin n) α) : Prop :=
  ∀ i j, A i j = A (Fin.rev i) (Fin.rev j)

/-
Definition of a Hadamard matrix.
-/
def IsHadamard {n : ℕ} (A : Matrix (Fin n) (Fin n) ℤ) : Prop :=
  (∀ i j, A i j = 1 ∨ A i j = -1) ∧ A * A.transpose = (n : ℤ) • (1 : Matrix (Fin n) (Fin n) ℤ)

/-
Definition of a number being a sum of two squares.
-/
def IsSumOfTwoSquares (n : ℕ) : Prop :=
  ∃ x y : ℕ, n = x^2 + y^2

/-
Definition of a weighing matrix W(n, k).
-/
def IsWeighing {n : ℕ} (k : ℕ) (A : Matrix (Fin n) (Fin n) ℤ) : Prop :=
  (∀ i j, A i j = 0 ∨ A i j = 1 ∨ A i j = -1) ∧ A * A.transpose = (k : ℤ) • (1 : Matrix (Fin n) (Fin n) ℤ)

#check IsWeighing

#check Matrix.fromBlocks

/-
Definition of a pair of disjoint weighing matrices.
-/
def IsDisjointWeighingPair {n : ℕ} (k : ℕ) (U V : Matrix (Fin n) (Fin n) ℤ) : Prop :=
  IsWeighing k U ∧ IsWeighing k V ∧
  (∀ i j, U i j * V i j = 0) ∧
  (∀ i j, U i j + V i j = 1 ∨ U i j + V i j = -1)

/-
Definition of the exchange matrix J (anti-diagonal identity).
-/
def matrix_J (n : ℕ) : Matrix (Fin n) (Fin n) ℤ :=
  Matrix.of (fun i j => if j = Fin.rev i then 1 else 0)

/-
J^2 = I.
-/
theorem matrix_J_sq (n : ℕ) : matrix_J n * matrix_J n = 1 := by
  -- By definition of matrix multiplication, we can expand the product of the exchange matrix with itself.
  ext i j; simp [matrix_J];
  rw [ Matrix.mul_apply ];
  simp +decide [ Matrix.one_apply, Finset.sum_ite ];
  grind

/-
J is symmetric.
-/
theorem matrix_J_transpose (n : ℕ) : (matrix_J n).transpose = matrix_J n := by
  ext i j; unfold matrix_J; aesop;

/-
J A J reverses the rows and columns of A.
-/
theorem matrix_J_mul_J (n : ℕ) (A : Matrix (Fin n) (Fin n) ℤ) :
  matrix_J n * A * matrix_J n = Matrix.of (fun i j => A (Fin.rev i) (Fin.rev j)) := by
    ext i j; simp +decide [ Matrix.mul_apply, matrix_J ] ;
    rw [ Finset.sum_eq_single ( Fin.rev j ) ] <;> aesop

/-
Construction of a centrosymmetric matrix from blocks B and C.
The matrix is [[B, C], [J C J, J B J]].
-/
def centrosymmetric_blocks {n : ℕ} (B C : Matrix (Fin n) (Fin n) ℤ) : Matrix (Fin (n + n)) (Fin (n + n)) ℤ :=
  Matrix.reindex finSumFinEquiv finSumFinEquiv (Matrix.fromBlocks B C (matrix_J n * C * matrix_J n) (matrix_J n * B * matrix_J n))

/-
Helper lemma: rev (inl i) = inr (rev i) under the equivalence.
-/
theorem fin_rev_sum_inl {n : ℕ} (i : Fin n) :
  Fin.rev (finSumFinEquiv (Sum.inl i)) = finSumFinEquiv (Sum.inr (Fin.rev i)) := by
    simp +decide [ Fin.ext_iff, Fin.rev ];
    rw [ tsub_add_eq_add_tsub ( by linarith [ Fin.is_lt i ] ) ]

/-
Helper lemma: rev (inr i) = inl (rev i) under the equivalence.
-/
theorem fin_rev_sum_inr {n : ℕ} (i : Fin n) :
  Fin.rev (finSumFinEquiv (Sum.inr i)) = finSumFinEquiv (Sum.inl (Fin.rev i)) := by
    simp +decide [ Fin.ext_iff, Fin.rev ];
    omega

/-
Proof that the constructed block matrix is centrosymmetric.
-/
theorem centrosymmetric_blocks_is_centrosymmetric {n : ℕ} (B C : Matrix (Fin n) (Fin n) ℤ) :
  IsCentrosymmetric (centrosymmetric_blocks B C) := by
    unfold centrosymmetric_blocks;
    intro i j;
    cases i using Fin.addCases <;> cases j using Fin.addCases <;> simp +decide [ *, matrix_J_mul_J ];
    · simp +decide [ Fin.rev, finSumFinEquiv ];
      simp +decide [ Fin.addCases, Matrix.fromBlocks ];
      split_ifs <;> simp_all +decide [ Nat.sub_sub ];
      · omega;
      · omega;
      · omega;
      · congr <;> norm_num [ Nat.sub_sub ] at *;
        · exact Fin.ext ( by norm_num; omega );
        · exact Fin.ext ( by norm_num; omega );
    · simp +decide [ Fin.rev, finSumFinEquiv ];
      simp +decide [ Fin.addCases, Nat.add_sub_add_right ];
      split_ifs <;> simp_all +decide [ Nat.sub_sub, add_comm ];
      · omega;
      · omega;
      · congr;
        · exact Eq.symm ( Fin.ext <| by norm_num; omega );
        · exact Fin.ext ( by norm_num; omega );
      · omega;
    · simp +decide [ finSumFinEquiv, Fin.rev ];
      simp +decide [ Fin.addCases, add_comm, add_left_comm, add_assoc ];
      split_ifs <;> simp_all +decide [ Nat.sub_sub ];
      · omega;
      · grind;
      · omega;
      · omega;
    · unfold finSumFinEquiv;
      simp +decide [ Fin.addNat, Fin.rev ];
      simp +decide [ add_comm, add_left_comm, add_assoc, Nat.add_sub_add_left ];
      simp +decide [ Fin.addCases ];
      split_ifs <;> simp_all +decide;
      grind

/-
Extraction of blocks B and C from a matrix A, and proof that a centrosymmetric matrix is reconstructed by these blocks.
-/
def extract_blocks {n : ℕ} (A : Matrix (Fin (n + n)) (Fin (n + n)) ℤ) :
  Matrix (Fin n) (Fin n) ℤ × Matrix (Fin n) (Fin n) ℤ :=
  let A' := Matrix.reindex finSumFinEquiv.symm finSumFinEquiv.symm A
  (A'.toBlocks₁₁, A'.toBlocks₁₂)

theorem extract_blocks_spec {n : ℕ} (A : Matrix (Fin (n + n)) (Fin (n + n)) ℤ) :
  let (B, C) := extract_blocks A
  IsCentrosymmetric A →
  A = centrosymmetric_blocks B C := by
    unfold IsCentrosymmetric centrosymmetric_blocks;
    intro hA
    ext i j;
    simp +decide [ Matrix.mul_apply, matrix_J ];
    rcases i with ( i | i ) <;> rcases j with ( j | j ) <;> simp +decide [ Matrix.toBlocks₁₁, Matrix.toBlocks₁₂, Matrix.toBlocks₂₁, Matrix.toBlocks₂₂ ];
    · rcases n with ( _ | _ | n ) <;> tauto;
    · convert hA _ _ using 1;
      unfold finSumFinEquiv; simp +decide [ Matrix.mul_apply ] ;
      simp +decide [ Matrix.mul_apply, Fin.addCases ];
      split_ifs <;> norm_num [ Matrix.mul_apply ];
      · exact hA _ _;
      · grind;
      · linarith;
      · linarith;
    · rcases i with ( _ | i ) <;> norm_num [ finSumFinEquiv ] at *;
      · rcases n with ( _ | _ | n ) <;> norm_num [ Fin.addCases ] at *;
        · contradiction;
        · simp +decide [ Matrix.mul_apply ];
          exact hA 1 0;
      · simp +decide [ Fin.addCases, Matrix.mul_apply ];
        split_ifs <;> norm_num [ Matrix.mul_apply ];
        · linarith;
        · rw [ Finset.sum_eq_single ⟨ n - 1, Nat.sub_lt ( by linarith ) ( by linarith ) ⟩ ] <;> simp +decide [ Fin.ext_iff, Fin.rev ];
          · rw [ if_pos ];
            · convert hA _ _ using 2;
              · norm_num [ Fin.ext_iff, Fin.rev ];
                omega;
              · norm_num [ Fin.ext_iff, Fin.rev ];
                omega;
            · omega;
          · intros; omega;
        · linarith;
    · unfold finSumFinEquiv;
      simp +decide [ Matrix.mul_apply, Fin.addCases ];
      split_ifs;
      · simp +decide [ Matrix.mul_apply, Finset.sum_ite ];
      · simp +decide [ Matrix.mul_apply, Matrix.fromBlocks ];
        grind;
      · simp +decide [ Matrix.mul_apply, Matrix.fromBlocks ];
        rw [ Finset.sum_eq_single ( Fin.rev ⟨ j + 1, by linarith ⟩ ) ] <;> simp +decide [ Fin.ext_iff ];
        · convert hA _ _ using 2;
          · norm_num [ Fin.ext_iff, Fin.rev ];
            omega;
          · norm_num [ Fin.addNat, Fin.rev ];
            omega;
        · intros; omega;
      · simp +decide [ Matrix.mul_apply, Finset.sum_ite ];
        rw [ Finset.sum_eq_single ⟨ n - ( j + 1 - n ) - 1, by omega ⟩ ] <;> simp +decide [ Fin.ext_iff, Fin.rev ];
        · convert hA _ _ using 2;
          · norm_num [ Fin.ext_iff, Fin.rev ];
            omega;
          · norm_num [ Fin.ext_iff, Fin.rev ];
            omega;
        · intros; omega;
        · omega

/-
Definitions of auxiliary matrices X and Y.
-/
def matrix_X {n : ℕ} (B C : Matrix (Fin n) (Fin n) ℤ) : Matrix (Fin n) (Fin n) ℤ :=
  B + C * matrix_J n

def matrix_Y {n : ℕ} (B C : Matrix (Fin n) (Fin n) ℤ) : Matrix (Fin n) (Fin n) ℤ :=
  B - C * matrix_J n

/-
Formula for X X^T in terms of B and C.
-/
theorem matrix_X_mul_transpose {n : ℕ} (B C : Matrix (Fin n) (Fin n) ℤ) :
  matrix_X B C * (matrix_X B C).transpose =
  (B * B.transpose + C * C.transpose) + (B * matrix_J n * C.transpose + C * matrix_J n * B.transpose) := by
    unfold matrix_X;
    norm_num [ add_mul, mul_add, Matrix.mul_assoc, Matrix.transpose_mul ] ; abel_nf;
    rw [ show ( matrix_J n ).transpose = matrix_J n from matrix_J_transpose n ] ; norm_num [ ← Matrix.mul_assoc, matrix_J_sq ] ;
    abel1

/-
Formula for Y Y^T in terms of B and C.
-/
theorem matrix_Y_mul_transpose {n : ℕ} (B C : Matrix (Fin n) (Fin n) ℤ) :
  matrix_Y B C * (matrix_Y B C).transpose =
  (B * B.transpose + C * C.transpose) - (B * matrix_J n * C.transpose + C * matrix_J n * B.transpose) := by
  unfold matrix_Y
  norm_num [ add_mul, mul_add, Matrix.mul_assoc, Matrix.transpose_mul, Matrix.transpose_sub, Matrix.mul_sub, Matrix.sub_mul ]
  rw [ show ( matrix_J n ).transpose = matrix_J n from matrix_J_transpose n ]
  norm_num [ ← Matrix.mul_assoc, matrix_J_sq ]
  abel1

/-
Definitions of U and V matrices.
-/
def matrix_U {n : ℕ} (B C : Matrix (Fin n) (Fin n) ℤ) : Matrix (Fin n) (Fin n) ℤ :=
  (B + C * matrix_J n).map (fun x => x / 2)

def matrix_V {n : ℕ} (B C : Matrix (Fin n) (Fin n) ℤ) : Matrix (Fin n) (Fin n) ℤ :=
  (B - C * matrix_J n).map (fun x => x / 2)

/-
If the centrosymmetric block matrix is Hadamard, then the blocks satisfy certain equations.
Specifically, BB^T + CC^T = 2nI and BJC^T + CJB^T = 0.
Note: The order of the large matrix is 2n, so the scalar is 2n.
-/
theorem hadamard_blocks_equations {n : ℕ} (B C : Matrix (Fin n) (Fin n) ℤ) :
  IsHadamard (centrosymmetric_blocks B C) →
  B * B.transpose + C * C.transpose = (2 * n : ℤ) • 1 ∧
  B * matrix_J n * C.transpose + C * matrix_J n * B.transpose = 0 := by
    rintro ⟨ h₁, h₂ ⟩;
    -- Let's expand the product of the block matrix with its transpose and compare the blocks.
    have h_expand : (Matrix.fromBlocks B C (matrix_J n * C * matrix_J n) (matrix_J n * B * matrix_J n)) * (Matrix.fromBlocks B C (matrix_J n * C * matrix_J n) (matrix_J n * B * matrix_J n)).transpose = (2 * n : ℤ) • 1 := by
      unfold centrosymmetric_blocks at h₂;
      convert congr_arg ( fun m => Matrix.reindex ( Equiv.symm finSumFinEquiv ) ( Equiv.symm finSumFinEquiv ) m ) h₂ using 1;
      · ext i j ; simp +decide [ Matrix.mul_apply, Matrix.transpose_apply ];
      · norm_num [ two_mul, Matrix.smul_eq_diagonal_mul ];
    simp_all +decide [ Matrix.fromBlocks_multiply, Matrix.fromBlocks_transpose ];
    -- By comparing the blocks, we can see that the equations hold.
    have h_block_eq : B * B.transpose + C * C.transpose = (2 * n : ℤ) • 1 ∧ B * (matrix_J n).transpose * C.transpose * (matrix_J n).transpose + C * (matrix_J n).transpose * B.transpose * (matrix_J n).transpose = 0 := by
      simp_all +decide [ ← Matrix.ext_iff, Fin.forall_fin_succ ];
      simp_all +decide [ two_mul, Matrix.add_mul, Matrix.mul_add ];
      constructor <;> intros <;> simp_all +decide [ Matrix.mul_assoc ];
      · congr;
        · exact if_congr ( by aesop ) rfl rfl;
        · exact if_congr ( by aesop ) rfl rfl;
      · exact?;
    simp_all +decide [ Matrix.mul_assoc, matrix_J_transpose ];
    convert congr_arg ( fun x => x * matrix_J n ) h_block_eq.2 using 1 <;> norm_num [ Matrix.mul_assoc ];
    simp +decide [ add_mul, mul_assoc, matrix_J_sq ]

/-
Entries of X and Y are in {-2, 0, 2}.
-/
theorem matrix_X_Y_entries {n : ℕ} (B C : Matrix (Fin n) (Fin n) ℤ)
  (hB : ∀ i j, B i j = 1 ∨ B i j = -1)
  (hC : ∀ i j, C i j = 1 ∨ C i j = -1) :
  (∀ i j, matrix_X B C i j ∈ ({-2, 0, 2} : Set ℤ)) ∧
  (∀ i j, matrix_Y B C i j ∈ ({-2, 0, 2} : Set ℤ)) := by
    simp +zetaDelta at *;
    -- By definition of matrix_X and matrix_Y, we know that their entries are sums and differences of entries from B and C, which are either 1 or -1.
    have h_entries : ∀ i j, matrix_X B C i j = B i j + C i (Fin.rev j) ∧ matrix_Y B C i j = B i j - C i (Fin.rev j) := by
      unfold matrix_X matrix_Y;
      simp +decide [ Matrix.mul_apply, matrix_J ];
      intro i j; rw [ Finset.sum_eq_single ( Fin.rev j ) ] <;> aesop;
    grind

/-
X + Y = 2B.
-/
theorem matrix_X_Y_sum {n : ℕ} (B C : Matrix (Fin n) (Fin n) ℤ) :
  matrix_X B C + matrix_Y B C = 2 • B := by
    unfold matrix_X matrix_Y;
    ext i j ; norm_num ; ring

/-
Helper lemma: (A * J) i j = A i (rev j).
-/
theorem matrix_mul_J_apply {n : ℕ} (A : Matrix (Fin n) (Fin n) ℤ) (i j : Fin n) :
  (A * matrix_J n) i j = A i (Fin.rev j) := by
    simp +decide [ Matrix.mul_apply, matrix_J ];
    rw [ Finset.sum_eq_single ( Fin.rev j ) ] <;> aesop

/-
X and Y are disjoint (their pointwise product is 0).
Proof uses the fact that entries of B and C are ±1, so their squares are 1.
Also uses `matrix_mul_J_apply`.
-/
theorem matrix_X_Y_disjoint {n : ℕ} (B C : Matrix (Fin n) (Fin n) ℤ)
  (hB : ∀ i j, B i j = 1 ∨ B i j = -1)
  (hC : ∀ i j, C i j = 1 ∨ C i j = -1) :
  ∀ i j, matrix_X B C i j * matrix_Y B C i j = 0 := by
    -- Let's choose any $i, j$ and derive a contradiction unless $X * Y = 0$.
    intros i j; unfold matrix_X matrix_Y; simp [mul_assoc, mul_comm, mul_left_comm];
    simp_all +decide [ Matrix.mul_apply, Finset.sum_add_distrib ];
    rw [ show matrix_J n = Matrix.of ( fun i j => if j = Fin.rev i then 1 else 0 ) by rfl ] ; simp +decide [ Finset.sum_ite, Finset.filter_eq', Finset.filter_ne' ] ; cases hB i j <;> cases hC i ( Fin.rev j ) <;> simp +decide [ * ] ;
    · rw [ Finset.sum_eq_single ( Fin.rev j ) ] <;> aesop;
    · rw [ Finset.sum_eq_single ( Fin.rev j ) ] <;> aesop;
    · rw [ Finset.sum_eq_single ( Fin.rev j ) ] <;> aesop;
    · rw [ Finset.sum_eq_single ( Fin.rev j ) ] <;> aesop

/-
Entries of U and V are in {-1, 0, 1}.
-/
theorem matrix_U_V_entries {n : ℕ} (B C : Matrix (Fin n) (Fin n) ℤ)
  (hB : ∀ i j, B i j = 1 ∨ B i j = -1)
  (hC : ∀ i j, C i j = 1 ∨ C i j = -1) :
  (∀ i j, matrix_U B C i j = 0 ∨ matrix_U B C i j = 1 ∨ matrix_U B C i j = -1) ∧
  (∀ i j, matrix_V B C i j = 0 ∨ matrix_V B C i j = 1 ∨ matrix_V B C i j = -1) := by
    -- By definition of $U$ and $V$, their entries are half of the entries of $X$ and $Y$, respectively.
    have h_U_V_entries : ∀ i j, matrix_U B C i j = (matrix_X B C i j) / 2 ∧ matrix_V B C i j = (matrix_Y B C i j) / 2 := by
      exact fun i j => ⟨ rfl, rfl ⟩;
    have h_X_Y_entries : ∀ i j, matrix_X B C i j ∈ ({-2, 0, 2} : Set ℤ) ∧ matrix_Y B C i j ∈ ({-2, 0, 2} : Set ℤ) := by
      have := matrix_X_Y_entries B C hB hC; aesop;
    grind

/-
Helper lemma: Pointwise product of X and Y entries.
-/
theorem matrix_X_Y_pointwise {n : ℕ} (B C : Matrix (Fin n) (Fin n) ℤ) (i j : Fin n) :
  matrix_X B C i j * matrix_Y B C i j = (B i j)^2 - (C i (Fin.rev j))^2 := by
    unfold matrix_X matrix_Y;
    unfold matrix_J; simp +decide [ Matrix.mul_apply, Finset.sum_ite ] ; ring;
    rw [ Finset.sum_eq_single ( Fin.rev j ) ] <;> aesop

/-
X and Y are disjoint (renamed to avoid conflict).
-/
theorem matrix_X_Y_disjoint' {n : ℕ} (B C : Matrix (Fin n) (Fin n) ℤ)
  (hB : ∀ i j, B i j = 1 ∨ B i j = -1)
  (hC : ∀ i j, C i j = 1 ∨ C i j = -1) :
  ∀ i j, matrix_X B C i j * matrix_Y B C i j = 0 := by
  intro i j
  rw [matrix_X_Y_pointwise]
  have hB_sq : (B i j)^2 = 1 := by
    cases hB i j <;> simp_all
  have hC_sq : (C i (Fin.rev j))^2 = 1 := by
    cases hC i (Fin.rev j) <;> simp_all
  rw [hB_sq, hC_sq]
  norm_num

/-
Lemma: Centrosymmetric Hadamard implies disjoint weighing pair.
-/
theorem disjoint_weighing_of_centrosymmetric_hadamard {m : ℕ} (hm : m % 2 = 0)
  (A : Matrix (Fin (m + m)) (Fin (m + m)) ℤ)
  (hA_centro : IsCentrosymmetric A) (hA_had : IsHadamard A) :
  let (B, C) := extract_blocks A
  let U := matrix_U B C
  let V := matrix_V B C
  IsDisjointWeighingPair (m/2) U V := by
  let B := (extract_blocks A).1
  let C := (extract_blocks A).2
  have hA_eq : A = centrosymmetric_blocks B C := extract_blocks_spec A hA_centro
  rw [hA_eq] at hA_had
  have h_eqs := hadamard_blocks_equations B C hA_had
  let U := matrix_U B C
  let V := matrix_V B C
  have h_XXT : matrix_X B C * (matrix_X B C).transpose = (2 * m : ℤ) • 1 := by
    rw [matrix_X_mul_transpose]
    rw [h_eqs.1, h_eqs.2]
    simp
  have h_YYT : matrix_Y B C * (matrix_Y B C).transpose = (2 * m : ℤ) • 1 := by
    rw [matrix_Y_mul_transpose]
    rw [h_eqs.1, h_eqs.2]
    simp
  have h_U_weight : U * U.transpose = (m/2 : ℤ) • 1 := by
    -- Since $X = 2U$, we have $X X^T = 4U U^T$.
    have h_XU : matrix_X B C = 2 • U := by
      ext i j; simp [matrix_X, matrix_U];
      -- Since $B$ and $C$ are matrices with entries in $\{-1, 1\}$, their sum $B i j + (C * matrix_J m) i j$ is even.
      have h_even : Even (B i j + (C * matrix_J m) i j) := by
        have h_even : ∀ i j, B i j = 1 ∨ B i j = -1 := by
          intro i j; have := hA_had.1; simp +decide [ ← hA_eq ] at this;
          convert this ( finSumFinEquiv ( Sum.inl i ) ) ( finSumFinEquiv ( Sum.inl j ) ) using 1
        have h_even_C : ∀ i j, C i j = 1 ∨ C i j = -1 := by
          intro i j; specialize hA_had; have := hA_had.1; simp_all +decide [ Matrix.mul_apply ] ;
          convert this ( finSumFinEquiv ( Sum.inl i ) ) ( finSumFinEquiv ( Sum.inr j ) ) using 1;
          · exact?;
          · unfold centrosymmetric_blocks; simp +decide [ Matrix.reindex_apply ] ;
            simp +decide [ Fin.addNat, finSumFinEquiv ];
            simp +decide [ Fin.addCases, Matrix.fromBlocks ];
        cases h_even i j <;> cases h_even_C i ( Fin.rev j ) <;> simp +decide [ *, Matrix.mul_apply ];
        · rw [ Finset.sum_eq_single ( Fin.rev j ) ] <;> simp +decide [ *, matrix_J ];
          exact fun k hk₁ hk₂ => False.elim <| hk₁ <| by simpa [ Fin.ext_iff ] using congr_arg Fin.rev hk₂.symm;
        · rw [ Finset.sum_eq_single ( Fin.rev j ) ] <;> simp +decide [ *, matrix_J ];
          exact fun k hk₁ hk₂ => False.elim <| hk₁ <| by simpa [ Fin.ext_iff ] using congr_arg Fin.rev hk₂.symm;
        · unfold matrix_J; simp +decide [ *, Finset.sum_ite ] ;
          rw [ Finset.sum_eq_single ( Fin.rev j ) ] <;> simp +decide [ *, Finset.sum_ite, Finset.filter_eq', Finset.filter_ne' ];
          exact fun k hk₁ hk₂ => False.elim <| hk₂ <| by simpa [ Fin.ext_iff ] using congr_arg Fin.rev hk₁.symm;
        · unfold matrix_J; simp +decide [ *, Finset.sum_ite ] ;
          rw [ Finset.sum_eq_single ( Fin.rev j ) ] <;> simp +decide [ *, Finset.sum_ite ];
          exact fun k hk₁ hk₂ => False.elim <| hk₂ <| by simpa [ Fin.ext_iff ] using congr_arg Fin.rev hk₁.symm;
      exact Eq.symm ( Int.mul_ediv_cancel' <| even_iff_two_dvd.mp h_even );
    -- Substitute h_XU into h_XXT and simplify.
    have h_UU : 4 • (U * U.transpose) = (2 * m : ℤ) • 1 := by
      convert h_XXT using 1 ; norm_num [ h_XU, two_mul ];
      grind;
    ext i j;
    replace h_UU := congr_fun ( congr_fun h_UU i ) j; norm_num at *;
    rcases Nat.even_or_odd' m with ⟨ k, rfl | rfl ⟩ <;> norm_num at *;
    linarith
  have h_V_weight : V * V.transpose = (m/2 : ℤ) • 1 := by
    -- Since $Y = 2V$, we have $Y Y^T = (2V)(2V)^T = 4V V^T$.
    have h_YV : (matrix_Y B C) * (matrix_Y B C).transpose = 4 * (V * V.transpose) := by
      have h_YV : matrix_Y B C = 2 • V := by
        ext i j; simp [V, matrix_V];
        unfold matrix_Y; norm_num [ two_mul ] ;
        -- Since $B$ and $C$ are matrices with entries in $\{-1, 1\}$, their product with $J$ will also have entries in $\{-1, 1\}$.
        have h_entries : ∀ i j, B i j = 1 ∨ B i j = -1 := by
          intro i j; have := hA_had.1; simp +decide [ centrosymmetric_blocks ] at this;
          specialize this ( Fin.castAdd m i ) ( Fin.castAdd m j ) ; simp +decide [ finSumFinEquiv ] at this ; tauto;
        have h_entries_C : ∀ i j, C i j = 1 ∨ C i j = -1 := by
          intro i j; have := hA_had.1; simp +decide [ hA_eq ] at this;
          convert this ( Fin.castAdd m i ) ( Fin.natAdd m j ) using 1;
          · unfold centrosymmetric_blocks; simp +decide [ Fin.castAdd, Fin.natAdd ] ;
            simp +decide [ Fin.castLE, finSumFinEquiv ];
            simp +decide [ Fin.addCases ];
          · exact?;
        rcases h_entries i j with ha | ha <;> rcases h_entries_C i ( Fin.rev j ) with hb | hb <;> norm_num [ ha, hb, Matrix.mul_apply, matrix_J ];
        · rw [ Finset.sum_eq_single ( Fin.rev j ) ] <;> simp +decide [ ha, hb ];
          exact fun k hk₁ hk₂ => False.elim <| hk₁ <| by simpa [ Fin.ext_iff ] using congr_arg Fin.rev hk₂.symm;
        · rw [ Finset.sum_eq_single ( Fin.rev j ) ] <;> simp +decide [ hb ];
          exact fun k hk₁ hk₂ => False.elim <| hk₁ <| by simpa [ Fin.ext_iff ] using congr_arg Fin.rev hk₂.symm;
        · rw [ Finset.sum_eq_single ( Fin.rev j ) ] <;> norm_num [ ha, hb ];
          exact fun k hk₁ hk₂ => False.elim <| hk₁ <| by simpa [ Fin.ext_iff ] using congr_arg Fin.rev hk₂.symm;
        · rw [ Finset.sum_eq_single ( Fin.rev j ) ] <;> norm_num [ ha, hb ];
          exact fun k hk₁ hk₂ => False.elim <| hk₁ <| by simpa [ Fin.ext_iff ] using congr_arg Fin.rev hk₂.symm;
      norm_num [ h_YV, two_mul, add_mul, mul_add, Matrix.mul_assoc ];
      abel_nf;
      norm_num [ Algebra.smul_def ];
    rw [ h_YV ] at h_YYT;
    ext i j ; replace h_YYT := congr_fun ( congr_fun h_YYT i ) j ; norm_num at *;
    norm_num [ Matrix.mul_apply ] at *;
    erw [ Finset.sum_eq_single i ] at h_YYT <;> norm_num at *;
    · erw [ show ( 4 : Matrix ( Fin m ) ( Fin m ) ℤ ) = 4 • 1 by norm_num, Matrix.smul_apply ] at h_YYT ; norm_num at h_YYT;
      norm_num [ Matrix.one_apply ] at *;
      split_ifs at * <;> omega;
    · exact fun k hk => Or.inl <| if_neg <| Ne.symm hk
  have h_disj : ∀ i j, U i j * V i j = 0 := by
    intro i j
    have h_prod := matrix_X_Y_disjoint' B C (by
    -- Since $A$ is Hadamard, each entry of $A$ is either $1$ or $-1$. Therefore, the entries of $B$ and $C$ must also be $1$ or $-1$.
    have hB_entries : ∀ i j, B i j = 1 ∨ B i j = -1 := by
      intro i j
      have hA_entry : A (finSumFinEquiv (Sum.inl i)) (finSumFinEquiv (Sum.inl j)) = 1 ∨ A (finSumFinEquiv (Sum.inl i)) (finSumFinEquiv (Sum.inl j)) = -1 := by
        exact hA_had.1 _ _ |> Or.imp ( fun h => by simpa [ hA_eq ] using h ) fun h => by simpa [ hA_eq ] using h;
      convert hA_entry using 1;
    exact hB_entries) (by
    -- Since $A$ is a Hadamard matrix, all its entries are $\pm 1$. Therefore, any submatrix, including $C$, must also have entries $\pm 1$.
    have hC_entries : ∀ i j, A i j = 1 ∨ A i j = -1 := by
      exact hA_eq ▸ hA_had.1;
    intro i j;
    convert hC_entries ( Fin.castAdd m i ) ( Fin.natAdd m j ) using 1) i j
    dsimp [U, V, matrix_U, matrix_V]
    unfold matrix_X matrix_Y at h_prod; norm_num at h_prod;
    grind
  have h_sum : ∀ i j, U i j + V i j = 1 ∨ U i j + V i j = -1 := by
    have h_entries : ∀ i j, B i j = 1 ∨ B i j = -1 := by
      have := hA_had.1;
      intro i j; specialize this ( finSumFinEquiv ( Sum.inl i ) ) ( finSumFinEquiv ( Sum.inl j ) ) ; simp +decide [ centrosymmetric_blocks ] at this ⊢; tauto;
    have h_entries_C : ∀ i j, C i j = 1 ∨ C i j = -1 := by
      have := hA_had.1; simp_all +decide [ Matrix.mul_apply ] ;
      intro i j; specialize this ( finSumFinEquiv ( Sum.inl i ) ) ( finSumFinEquiv ( Sum.inr j ) ) ; simp_all +decide [ centrosymmetric_blocks ] ;
      simp_all +decide [ finSumFinEquiv, Matrix.fromBlocks ];
      simp_all +decide [ Fin.addCases, Fin.addNat ];
    intro i j;
    simp +zetaDelta at *;
    unfold matrix_U matrix_V; norm_num [ h_entries i j, h_entries_C i j ] ;
    rcases h_entries i j with ha | ha <;> rcases h_entries_C i ( Fin.rev j ) with hb | hb <;> norm_num [ ha, hb, matrix_mul_J_apply ]
  have h_U_entries : ∀ i j, U i j = 0 ∨ U i j = 1 ∨ U i j = -1 := by
    intro i j; specialize h_disj i j; specialize h_sum i j; rcases h_sum with h | h <;> rcases lt_trichotomy ( U i j ) 0 with h' | h' | h' <;> first | exact Or.inl <| by nlinarith | exact Or.inr <| Or.inl <| by nlinarith | exact Or.inr <| Or.inr <| by nlinarith;
  have h_V_entries : ∀ i j, V i j = 0 ∨ V i j = 1 ∨ V i j = -1 := by
    intro i j; specialize h_sum i j; specialize h_U_entries i j; specialize h_disj i j; rcases h_U_entries with ( h | h | h ) <;> rcases h_sum with ( h' | h' ) <;> norm_num [ h ] at h_disj ⊢ <;> omega;
  refine ⟨⟨h_U_entries, h_U_weight⟩, ⟨h_V_entries, h_V_weight⟩, h_disj, h_sum⟩

/-
Lemmas: X X^T = 2n I and Y Y^T = 2n I given the Hadamard block equations.
-/
theorem matrix_X_mul_transpose_eq {n : ℕ} (B C : Matrix (Fin n) (Fin n) ℤ)
  (h1 : B * B.transpose + C * C.transpose = (2 * n : ℤ) • 1)
  (h2 : B * matrix_J n * C.transpose + C * matrix_J n * B.transpose = 0) :
  matrix_X B C * (matrix_X B C).transpose = (2 * n : ℤ) • 1 := by
  rw [matrix_X_mul_transpose]
  rw [h1, h2]
  simp

theorem matrix_Y_mul_transpose_eq {n : ℕ} (B C : Matrix (Fin n) (Fin n) ℤ)
  (h1 : B * B.transpose + C * C.transpose = (2 * n : ℤ) • 1)
  (h2 : B * matrix_J n * C.transpose + C * matrix_J n * B.transpose = 0) :
  matrix_Y B C * (matrix_Y B C).transpose = (2 * n : ℤ) • 1 := by
  rw [matrix_Y_mul_transpose]
  rw [h1, h2]
  simp

/-
X and Y are disjoint (v2).
-/
theorem matrix_X_Y_disjoint_v2 {n : ℕ} (B C : Matrix (Fin n) (Fin n) ℤ)
  (hB : ∀ i j, B i j = 1 ∨ B i j = -1)
  (hC : ∀ i j, C i j = 1 ∨ C i j = -1) :
  ∀ i j, matrix_X B C i j * matrix_Y B C i j = 0 := by
  intro i j
  rw [matrix_X_Y_pointwise]
  have hB_sq : (B i j)^2 = 1 := by
    cases hB i j <;> simp_all
  have hC_sq : (C i (Fin.rev j))^2 = 1 := by
    cases hC i (Fin.rev j) <;> simp_all
  rw [hB_sq, hC_sq]
  norm_num

/-
Auxiliary lemma: Centrosymmetric Hadamard implies disjoint weighing pair (with explicit m=2k).
Corrected proof with explicit construction of IsWeighing and linarith fixes.
-/
theorem disjoint_weighing_of_centrosymmetric_hadamard_aux {m k : ℕ} (hm : m = 2 * k)
  (A : Matrix (Fin (m + m)) (Fin (m + m)) ℤ)
  (hA_centro : IsCentrosymmetric A) (hA_had : IsHadamard A) :
  let (B, C) := extract_blocks A
  let U := matrix_U B C
  let V := matrix_V B C
  IsDisjointWeighingPair k U V := by
    have := disjoint_weighing_of_centrosymmetric_hadamard ( show m % 2 = 0 from by norm_num [ hm ] ) A hA_centro hA_had; aesop;

/-
Auxiliary lemma: Centrosymmetric Hadamard implies disjoint weighing pair (with explicit m=2k).
Corrected proof with explicit construction of IsWeighing and linarith fixes.
Using `Matrix.fromBlocks` instead of `fromBlocks_apply`.
-/
theorem disjoint_weighing_of_centrosymmetric_hadamard_aux_v2 {m k : ℕ} (hm : m = 2 * k)
  (A : Matrix (Fin (m + m)) (Fin (m + m)) ℤ)
  (hA_centro : IsCentrosymmetric A) (hA_had : IsHadamard A) :
  let (B, C) := extract_blocks A
  let U := matrix_U B C
  let V := matrix_V B C
  IsDisjointWeighingPair k U V := by
    exact?

/-
Definitions of B and C from U and V.
-/
def matrix_B_from_UV {n : ℕ} (U V : Matrix (Fin n) (Fin n) ℤ) : Matrix (Fin n) (Fin n) ℤ :=
  U + V

def matrix_C_from_UV {n : ℕ} (U V : Matrix (Fin n) (Fin n) ℤ) : Matrix (Fin n) (Fin n) ℤ :=
  (U - V) * matrix_J n

/-
Lemma: B and C constructed from disjoint weighing matrices have entries ±1.
-/
theorem matrix_B_C_entries_from_UV {n : ℕ} (U V : Matrix (Fin n) (Fin n) ℤ)
  (h : IsDisjointWeighingPair (n/2) U V) :
  let B := matrix_B_from_UV U V
  let C := matrix_C_from_UV U V
  (∀ i j, B i j = 1 ∨ B i j = -1) ∧ (∀ i j, C i j = 1 ∨ C i j = -1) := by
    obtain ⟨hU, hV, hUV⟩ := h;
    have hB : ∀ i j, U i j + V i j = 1 ∨ U i j + V i j = -1 := by
      exact hUV.2
    have hC : ∀ i j, U i j - V i j = 1 ∨ U i j - V i j = -1 := by
      intro i j; specialize hB i j; specialize hUV; rcases hU.1 i j with ha | ha <;> rcases hV.1 i j with hb | hb <;> simp_all +decide ;
      · grind;
      · grind;
    unfold matrix_B_from_UV matrix_C_from_UV;
    simp_all +decide [ Matrix.mul_apply, matrix_J ];
    intro i j; rw [ Finset.sum_eq_single ( Fin.rev j ) ] <;> aesop;

/-
Lemma: BB^T + CC^T = 4k I for B, C constructed from weighing matrices U, V.
-/
theorem matrix_B_C_mul_transpose_add {n k : ℕ} (U V : Matrix (Fin n) (Fin n) ℤ)
  (hU : IsWeighing k U) (hV : IsWeighing k V) :
  let B := matrix_B_from_UV U V
  let C := matrix_C_from_UV U V
  B * B.transpose + C * C.transpose = (4 * k : ℤ) • 1 := by
    unfold matrix_B_from_UV matrix_C_from_UV;
    -- We can simplify the expression using the properties of matrix multiplication and the given conditions.
    have h_simp : (U + V) * (U + V).transpose + (U - V) * (matrix_J n) * ((matrix_J n).transpose * (U - V).transpose) = 2 * (U * U.transpose + V * V.transpose) := by
      norm_num [ Matrix.mul_assoc, two_mul ];
      rw [ matrix_J_transpose ];
      norm_num [ ← Matrix.mul_assoc, matrix_J_sq ];
      norm_num [ add_mul, mul_add, sub_mul, mul_sub ] ; abel_nf;
    simp_all +decide [ Matrix.mul_assoc, IsWeighing ];
    grind

/-
Lemma: BJC^T + CJB^T = 0 for B, C constructed from weighing matrices U, V.
-/
theorem matrix_B_C_mixed_term_eq_zero {n k : ℕ} (U V : Matrix (Fin n) (Fin n) ℤ)
  (hU : IsWeighing k U) (hV : IsWeighing k V) :
  let B := matrix_B_from_UV U V
  let C := matrix_C_from_UV U V
  B * matrix_J n * C.transpose + C * matrix_J n * B.transpose = 0 := by
    -- We'll use that $J$ is its own inverse to simplify the expression.
    have hJ_inv : matrix_J n * matrix_J n = 1 := by
      exact?;
    unfold matrix_B_from_UV matrix_C_from_UV; ext i j; simp +decide [ *, Matrix.mul_assoc ] ; ring;
    -- Using the fact that $J$ is symmetric, we can simplify the expression.
    have hJ_symm : (matrix_J n).transpose = matrix_J n := by
      exact?;
    simp +decide [ ← Matrix.mul_assoc, hJ_symm, hJ_inv ];
    simp +decide [ Matrix.mul_add, Matrix.add_mul, Matrix.mul_sub, Matrix.sub_mul, hU.2, hV.2 ];
    ring

/-
Lemma: The entries of the centrosymmetric block matrix are ±1.
-/
theorem centrosymmetric_blocks_entries {n : ℕ} (B C : Matrix (Fin n) (Fin n) ℤ)
  (h_entries_B : ∀ i j, B i j = 1 ∨ B i j = -1)
  (h_entries_C : ∀ i j, C i j = 1 ∨ C i j = -1) :
  ∀ i j, (centrosymmetric_blocks B C) i j = 1 ∨ (centrosymmetric_blocks B C) i j = -1 := by
    unfold centrosymmetric_blocks;
    intro i j; rcases finSumFinEquiv.symm i with ( i | i ) <;> rcases finSumFinEquiv.symm j with ( j | j ) <;> simp +decide [ *, Matrix.mul_apply ] ;
    · rename_i k l;
      rcases finSumFinEquiv.symm k with ( k | k ) <;> rcases finSumFinEquiv.symm l with ( l | l ) <;> simp +decide [ *, Matrix.mul_apply ];
      · simp +decide [ matrix_J, Finset.sum_ite ];
        rw [ Finset.sum_eq_single ( Fin.rev l ) ] <;> aesop;
      · unfold matrix_J;
        rw [ Finset.sum_eq_single ( Fin.rev l ) ] <;> aesop;
    · rename_i k l;
      rcases finSumFinEquiv.symm k with ( k | k ) <;> rcases finSumFinEquiv.symm l with ( l | l ) <;> simp +decide [ *, Matrix.mul_apply ];
      · simp +decide [ matrix_J, Finset.sum_ite ];
        rw [ Finset.sum_eq_single ( Fin.rev l ) ] <;> aesop;
      · unfold matrix_J;
        rw [ Finset.sum_eq_single ( Fin.rev l ) ] <;> aesop;
    · rename_i k l;
      rcases finSumFinEquiv.symm k with ( k | k ) <;> rcases finSumFinEquiv.symm l with ( l | l ) <;> simp +decide [ *, Matrix.mul_apply ];
      · simp +decide [ matrix_J, Finset.sum_ite ];
        rw [ Finset.sum_eq_single ( Fin.rev l ) ] <;> aesop;
      · unfold matrix_J;
        rw [ Finset.sum_eq_single ( Fin.rev l ) ] <;> aesop;
    · rename_i k l;
      rcases finSumFinEquiv.symm k with ( k | k ) <;> rcases finSumFinEquiv.symm l with ( l | l ) <;> simp +decide [ *, Matrix.mul_apply ];
      · simp +decide [ matrix_J, Finset.sum_ite ];
        rw [ Finset.sum_eq_single ( Fin.rev l ) ] <;> aesop;
      · unfold matrix_J;
        rw [ Finset.sum_eq_single ( Fin.rev l ) ] <;> aesop

/-
Lemma: The entries of the centrosymmetric block matrix are ±1 (v2).
-/
theorem centrosymmetric_blocks_entries_v2 {n : ℕ} (B C : Matrix (Fin n) (Fin n) ℤ)
  (h_entries_B : ∀ i j, B i j = 1 ∨ B i j = -1)
  (h_entries_C : ∀ i j, C i j = 1 ∨ C i j = -1) :
  ∀ i j, (centrosymmetric_blocks B C) i j = 1 ∨ (centrosymmetric_blocks B C) i j = -1 := by
    exact?

/-
Lemma: Sufficient conditions for the block matrix to be Hadamard.
Proof uses block multiplication properties and `submatrix_mul_equiv`.
Explicitly calculating blocks.
-/
theorem is_hadamard_of_centrosymmetric_blocks {n : ℕ} (B C : Matrix (Fin n) (Fin n) ℤ)
  (h_entries_B : ∀ i j, B i j = 1 ∨ B i j = -1)
  (h_entries_C : ∀ i j, C i j = 1 ∨ C i j = -1)
  (h_orth1 : B * B.transpose + C * C.transpose = (2 * n : ℤ) • 1)
  (h_orth2 : B * matrix_J n * C.transpose + C * matrix_J n * B.transpose = 0) :
  IsHadamard (centrosymmetric_blocks B C) := by
    -- By combining the results from the orthogonality conditions and the block matrix multiplication, we can conclude that the centrosymmetric block matrix is Hadamard.
    have h_hadamard : let A := centrosymmetric_blocks B C; A * A.transpose = (2 * n : ℤ) • 1 := by
      have h_hadamard : let A := Matrix.fromBlocks B C (matrix_J n * C * matrix_J n) (matrix_J n * B * matrix_J n); A * A.transpose = (2 * n : ℤ) • 1 := by
        simp_all +decide [ Matrix.fromBlocks_multiply, Matrix.fromBlocks_transpose, Matrix.mul_assoc ];
        -- By definition of matrix_J, we know that (matrix_J n).transpose = matrix_J n.
        have hJ_transpose : (matrix_J n).transpose = matrix_J n := by
          exact?;
        simp_all +decide [ ← Matrix.mul_assoc, ← eq_sub_iff_add_eq' ];
        simp_all +decide [ Matrix.mul_assoc, show matrix_J n * matrix_J n = 1 from matrix_J_sq n ];
        simp_all +decide [ two_mul, add_mul, mul_add, sub_mul, mul_sub, ← Matrix.mul_assoc ];
        simp +decide [ ← Matrix.ext_iff, Fin.forall_fin_succ, Matrix.mul_apply, Matrix.one_apply ];
        simp +decide [ matrix_J ];
        erw [ show ( n : Matrix ( Fin n ) ( Fin n ) ℤ ) = n • 1 by simp +decide [ Algebra.smul_def ] ] ; simp +decide [ Matrix.smul_eq_diagonal_mul ] ;
        erw [ show ( n : Matrix ( Fin n ⊕ Fin n ) ( Fin n ⊕ Fin n ) ℤ ) = n • 1 by simp +decide [ Algebra.smul_def ] ] ; simp +decide [ Matrix.smul_eq_diagonal_mul ] ;
        simp +decide [ Matrix.one_apply, Finset.sum_ite ];
        simp +decide [ eq_comm ];
      unfold centrosymmetric_blocks;
      ext i j;
      convert congr_fun ( congr_fun h_hadamard ( finSumFinEquiv.symm i ) ) ( finSumFinEquiv.symm j ) using 1;
      · norm_num [ Finset.sum_range_add, Finset.sum_range, Fin.sum_univ_add ];
      · simp +decide [ Matrix.one_apply, Matrix.smul_apply ];
    constructor;
    · exact?;
    · convert h_hadamard using 1 ; push_cast ; ring

/-
Reverse direction: Disjoint weighing pair implies Centrosymmetric Hadamard.
Uses the lemmas proved earlier.
Explicitly handling `n = 2*k`.
-/
theorem centrosymmetric_hadamard_of_disjoint_weighing {k : ℕ}
  (U V : Matrix (Fin (2*k)) (Fin (2*k)) ℤ)
  (h : IsDisjointWeighingPair k U V) :
  let B := U + V
  let C := (U - V) * matrix_J (2*k)
  let A := centrosymmetric_blocks B C
  IsCentrosymmetric A ∧ IsHadamard A := by
    refine' ⟨ _, _ ⟩;
    · exact?;
    · apply is_hadamard_of_centrosymmetric_blocks;
      · cases h ; aesop;
      · have := @matrix_B_C_entries_from_UV;
        specialize @this ( 2 * k ) U V ; aesop;
      · convert matrix_B_C_mul_transpose_add U V h.1 h.2.1 using 1 ; ring;
        push_cast; ring;
      · convert matrix_B_C_mixed_term_eq_zero U V h.1 h.2.1 using 1

/-
Helper lemma: Block multiplication for centrosymmetric blocks.
-/
theorem centrosymmetric_blocks_mul_transpose {n : ℕ} (B C : Matrix (Fin n) (Fin n) ℤ) :
  (centrosymmetric_blocks B C) * (centrosymmetric_blocks B C).transpose =
  Matrix.reindex finSumFinEquiv finSumFinEquiv (
    Matrix.fromBlocks
      (B * B.transpose + C * C.transpose)
      (B * (matrix_J n * C * matrix_J n).transpose + C * (matrix_J n * B * matrix_J n).transpose)
      (matrix_J n * C * matrix_J n * B.transpose + matrix_J n * B * matrix_J n * C.transpose)
      (matrix_J n * C * matrix_J n * (matrix_J n * C * matrix_J n).transpose + matrix_J n * B * matrix_J n * (matrix_J n * B * matrix_J n).transpose)
  ) := by
    simp +decide [ centrosymmetric_blocks ];
    simp +decide [ Matrix.fromBlocks_transpose, Matrix.fromBlocks_multiply ]

/-
Lemma: Sufficient conditions for the block matrix to be Hadamard (v2).
Proof uses block multiplication properties and `submatrix_mul_equiv`.
Explicitly calculating blocks.
-/
theorem is_hadamard_of_centrosymmetric_blocks_v2 {n : ℕ} (B C : Matrix (Fin n) (Fin n) ℤ)
  (h_entries_B : ∀ i j, B i j = 1 ∨ B i j = -1)
  (h_entries_C : ∀ i j, C i j = 1 ∨ C i j = -1)
  (h_orth1 : B * B.transpose + C * C.transpose = (2 * n : ℤ) • 1)
  (h_orth2 : B * matrix_J n * C.transpose + C * matrix_J n * B.transpose = 0) :
  IsHadamard (centrosymmetric_blocks B C) := by
    exact?

/-
Reverse direction: Disjoint weighing pair implies Centrosymmetric Hadamard (v2).
-/
theorem centrosymmetric_hadamard_of_disjoint_weighing_v2 {k : ℕ}
  (U V : Matrix (Fin (2*k)) (Fin (2*k)) ℤ)
  (h : IsDisjointWeighingPair k U V) :
  let B := U + V
  let C := (U - V) * matrix_J (2*k)
  let A := centrosymmetric_blocks B C
  IsCentrosymmetric A ∧ IsHadamard A := by
    convert centrosymmetric_hadamard_of_disjoint_weighing U V h using 1

/-
k is a sum of two squares iff 4k is a sum of two squares.
-/
theorem is_sum_of_two_squares_mul_4 {k : ℕ} :
  IsSumOfTwoSquares k ↔ IsSumOfTwoSquares (4 * k) := by
    constructor <;> rintro ⟨ x, y, h ⟩;
    · exact ⟨ 2 * x, 2 * y, by linarith ⟩;
    · -- Since $x^2 + y^2 \equiv 0 \pmod{4}$, both $x$ and $y$ must be even.
      have h_even : Even x ∧ Even y := by
        replace h := congr_arg ( · % 4 ) h ; rcases Nat.even_or_odd' x with ⟨ b, rfl | rfl ⟩ <;> rcases Nat.even_or_odd' y with ⟨ c, rfl | rfl ⟩ <;> ring_nf at * <;> norm_num at *;
      obtain ⟨ ⟨ x, rfl ⟩, ⟨ y, rfl ⟩ ⟩ := h_even; exact ⟨ x, y, by linarith ⟩ ;

/-
Forward direction: Centrosymmetric Hadamard implies disjoint weighing pair.
Corrected proof handling reindexing and `n=4k`.
-/
theorem centrosymmetric_hadamard_implies_disjoint_weighing {n : ℕ} (h : n % 4 = 0) :
  (∃ A : Matrix (Fin n) (Fin n) ℤ, IsCentrosymmetric A ∧ IsHadamard A) →
  (∃ U V : Matrix (Fin (n/2)) (Fin (n/2)) ℤ, IsDisjointWeighingPair (n/4) U V) := by
    intro hA_had;
    -- Apply the lemma `disjoint_weighing_of_centrosymmetric_hadamard_aux` with `m = n / 2` and `k = n / 4`.
    obtain ⟨A, hA_centro, hA_had⟩ := hA_had;
    have h_m_k : n = 2 * (n / 2) := by
      omega;
    have h_k : n / 2 = 2 * (n / 4) := by
      omega;
    exact (by
    have := @disjoint_weighing_of_centrosymmetric_hadamard_aux_v2 ( n / 2 ) ( n / 4 ) ?_ ?_ ?_ ?_ <;> norm_num at *;
    exact ⟨ _, _, this ⟩;
    exact h_k;
    refine' A.submatrix ( fun i => ⟨ i.val, by linarith [ Fin.is_lt i ] ⟩ ) ( fun i => ⟨ i.val, by linarith [ Fin.is_lt i ] ⟩ );
    · intro i j;
      convert hA_centro _ _ using 1;
      norm_num [ Fin.rev ];
      congr <;> omega;
    · refine' ⟨ _, _ ⟩;
      · exact fun i j => hA_had.1 _ _;
      · ext i j;
        convert congr_fun ( congr_fun hA_had.2 ⟨ i, by linarith [ Fin.is_lt i, Nat.div_mul_le_self n 2 ] ⟩ ) ⟨ j, by linarith [ Fin.is_lt j, Nat.div_mul_le_self n 2 ] ⟩ using 1;
        · simp +decide [ Matrix.mul_apply ];
          refine' Finset.sum_bij ( fun x hx => ⟨ x, by linarith [ Fin.is_lt x ] ⟩ ) _ _ _ _ <;> simp +decide;
          · exact fun a₁ a₂ h => Fin.ext h;
          · exact fun b => ⟨ ⟨ b, by linarith [ Fin.is_lt b ] ⟩, rfl ⟩;
        · simp +decide [ Fin.ext_iff, Matrix.one_apply ];
          grind)

/-
Reverse direction: Disjoint weighing pair implies Centrosymmetric Hadamard (final version).
Renamed to avoid "already declared" error.
Explicitly unfolding definitions to help `rw`.
-/
theorem centrosymmetric_hadamard_of_disjoint_weighing_final {k : ℕ}
  (U V : Matrix (Fin (2*k)) (Fin (2*k)) ℤ)
  (h : IsDisjointWeighingPair k U V) :
  let B := U + V
  let C := (U - V) * matrix_J (2*k)
  let A := centrosymmetric_blocks B C
  IsCentrosymmetric A ∧ IsHadamard A := by
  let n := 2*k
  let B := U + V
  let C := (U - V) * matrix_J n
  let A := centrosymmetric_blocks B C
  have h_centro : IsCentrosymmetric A := centrosymmetric_blocks_is_centrosymmetric B C
  have h_k_eq : n / 2 = k := by simp [n]
  have h' : IsDisjointWeighingPair (n/2) U V := by
    rw [h_k_eq]
    exact h
  have h_entries := matrix_B_C_entries_from_UV U V h'
  have h_entries_B := h_entries.1
  have h_entries_C := h_entries.2
  have hU : IsWeighing k U := h.1
  have hV : IsWeighing k V := h.2.1
  have h_orth1 := matrix_B_C_mul_transpose_add U V hU hV
  have h_orth2 := matrix_B_C_mixed_term_eq_zero U V hU hV
  have h_orth1' : B * B.transpose + C * C.transpose = (2 * n : ℤ) • 1 := by
    dsimp [B, C]
    -- h_orth1 is in terms of matrix_B_from_UV U V, which is defeq to U + V
    -- But we need to be careful with rw.
    -- Let's convert h_orth1 to the exact form we need.
    have h_orth1_expanded : (matrix_B_from_UV U V) * (matrix_B_from_UV U V).transpose + (matrix_C_from_UV U V) * (matrix_C_from_UV U V).transpose = (4 * k : ℤ) • 1 := h_orth1
    unfold matrix_B_from_UV matrix_C_from_UV at h_orth1_expanded
    rw [h_orth1_expanded]
    simp [n]
    norm_cast
    ring
  have h_orth2' : B * matrix_J n * C.transpose + C * matrix_J n * B.transpose = 0 := by
    dsimp [B, C]
    have h_orth2_expanded : (matrix_B_from_UV U V) * matrix_J n * (matrix_C_from_UV U V).transpose + (matrix_C_from_UV U V) * matrix_J n * (matrix_B_from_UV U V).transpose = 0 := h_orth2
    unfold matrix_B_from_UV matrix_C_from_UV at h_orth2_expanded
    exact h_orth2_expanded
  have h_had := is_hadamard_of_centrosymmetric_blocks_v2 B C h_entries_B h_entries_C h_orth1' h_orth2'
  exact ⟨h_centro, h_had⟩