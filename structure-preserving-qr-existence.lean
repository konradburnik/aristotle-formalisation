/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 541372c8-4d9f-4756-a6a4-62d8238221bd
-/

/-
We have formalized the theory of structure-preserving QR decomposition for centrosymmetric matrices.
We defined the transformation to the decoupled block diagonal space (`to_blocks`, `from_blocks`) and proved that it preserves multiplication (`to_blocks_mul`) and centrosymmetry.
We proved that a centrosymmetric matrix `A` can be decomposed into a centrosymmetric orthogonal `Q` and a centrosymmetric `R` which is block diagonal in the K-basis (`exists_structure_preserving_QR_proven`).
We also showed that this decomposition can be constructed from the QR decompositions of the two decoupled blocks (`construct_SPQR_original`), which justifies the algorithmic reduction from one `2m x 2m` problem to two `m x m` problems, providing a speedup.
Note: The user's definition of `StructurePreservingQR` did not explicitly require `R` to be upper triangular, so the existence is technically trivial (`Q=I`), but we provided the reduction machinery which works for the intended triangular case as well (as shown in `construct_SPQR_Corrected`).
-/

/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 5fb11814-8ddf-43a5-97ed-11e20a32d482
-/

/-
We defined centrosymmetric matrices and the exchange matrix $J$. We proved that a $2m \times 2m$ centrosymmetric matrix $A$ can be block-diagonalized by the orthogonal matrix $K = \frac{1}{\sqrt{2}} \begin{pmatrix} I & I \\ J & -J \end{pmatrix}$ into two $m \times m$ blocks $D_1$ and $D_2$. We then defined a structure-preserving QR decomposition and proved its existence by constructing it from the QR decompositions of $D_1$ and $D_2$. This reduction from one $2m \times 2m$ problem to two $m \times m$ problems represents the faster algorithm.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

#check Fin.rev

#check Matrix

/-
The exchange matrix J has 1s on the antidiagonal. A matrix A is centrosymmetric if AJ = JA.
-/
def exchangeMatrix (n : ℕ) : Matrix (Fin n) (Fin n) ℝ :=
  fun i j => if i.rev = j then 1 else 0

def IsCentrosymmetric {n : ℕ} (A : Matrix (Fin n) (Fin n) ℝ) : Prop :=
  let J := exchangeMatrix n
  A * J = J * A

/-
The exchange matrix is symmetric, i.e., J^T = J.
-/
lemma exchangeMatrix_transpose (n : ℕ) : (exchangeMatrix n).transpose = exchangeMatrix n := by
  ext i j; unfold exchangeMatrix; aesop;

/-
The square of the exchange matrix is the identity matrix, i.e., J^2 = I.
-/
lemma exchangeMatrix_mul_exchangeMatrix (n : ℕ) : exchangeMatrix n * exchangeMatrix n = 1 := by
  ext i j;
  unfold exchangeMatrix;
  rw [ Matrix.mul_apply ];
  rw [ Finset.sum_eq_single ( Fin.rev i ) ] <;> aesop

/-
The matrix K is defined as 1/sqrt(2) * [[I, I], [J, -J]].
-/
open Matrix

def K_matrix (m : ℕ) : Matrix (Fin m ⊕ Fin m) (Fin m ⊕ Fin m) ℝ :=
  let I := (1 : Matrix (Fin m) (Fin m) ℝ)
  let J := exchangeMatrix m
  let s := (1 / Real.sqrt 2 : ℝ)
  s • fromBlocks I I J (-J)

/-
For a centrosymmetric matrix A constructed from blocks A11, A12, A21, A22 satisfying the centrosymmetry conditions, the matrix K^T * A * K is block diagonal with blocks A11 + A12 * J and A11 - A12 * J.
-/
open Matrix

theorem centrosymmetric_decomposition (m : ℕ) (A11 A12 : Matrix (Fin m) (Fin m) ℝ) :
  let J := exchangeMatrix m
  let A21 := J * A12 * J
  let A22 := J * A11 * J
  let A := fromBlocks A11 A12 A21 A22
  let K := K_matrix m
  let D1 := A11 + A12 * J
  let D2 := A11 - A12 * J
  K.transpose * A * K = fromBlocks D1 0 0 D2 := by
    -- Let's simplify the expression by expanding the products.
    simp [K_matrix];
    norm_num [ Matrix.fromBlocks_multiply, Matrix.fromBlocks_transpose ];
    -- Since $J^2 = I$, we have $J^T * J = I$ and $J^2 = I$.
    have hJ : (exchangeMatrix m).transpose * exchangeMatrix m = 1 ∧ (exchangeMatrix m) ^ 2 = 1 := by
      exact ⟨ by rw [ exchangeMatrix_transpose ] ; exact? , by rw [ sq, exchangeMatrix_mul_exchangeMatrix ] ⟩;
    simp_all +decide [ ← mul_assoc, sq ];
    simp_all +decide [ add_mul, mul_assoc, sub_eq_add_neg ];
    ext i j ; norm_num ; ring;
    rcases i with ( i | i ) <;> rcases j with ( j | j ) <;> norm_num <;> ring

/-
The matrix K is orthogonal, i.e., K^T * K = I.
-/
theorem K_matrix_orthogonal (m : ℕ) :
  let K := K_matrix m
  K.transpose * K = 1 := by
    -- Let's simplify the expression for $K^T K$.
    simp [K_matrix, exchangeMatrix];
    ext i j;
    rcases i with ( i | i ) <;> rcases j with ( j | j ) <;> norm_num [ Matrix.mul_apply ];
    · simp +decide [ Matrix.one_apply, exchangeMatrix ];
      split_ifs <;> simp_all +decide [ Finset.sum_ite, Finset.filter_eq', Finset.filter_ne' ];
      rw [ show ( Finset.univ.filter fun x : Fin m => Fin.rev x = j ) = { Fin.rev j } by ext x; aesop ] ; norm_num ; ring ; norm_num;
    · unfold exchangeMatrix; norm_num [ Matrix.one_apply ];
      rw [ Finset.sum_eq_single ( Fin.rev j ) ] <;> aesop;
    · unfold exchangeMatrix; norm_num [ Matrix.one_apply ] ; ring ; norm_num;
      rw [ Finset.sum_eq_single ( Fin.rev j ) ] <;> aesop;
    · simp +decide [ Matrix.one_apply, exchangeMatrix ];
      split_ifs <;> simp_all +decide [ Finset.sum_ite, Finset.filter_eq', Finset.filter_ne' ];
      rw [ show ( Finset.univ.filter fun x : Fin m => Fin.rev x = j ) = { Fin.rev j } by ext x; aesop ] ; norm_num ; ring ; norm_num

/-
The reconstructed matrix M commutes with the block exchange matrix J_sum, meaning M is centrosymmetric.
-/
open Matrix

def exchangeMatrixSum (m : ℕ) : Matrix (Fin m ⊕ Fin m) (Fin m ⊕ Fin m) ℝ :=
  let J := exchangeMatrix m
  fromBlocks 0 J J 0

theorem reconstruction_commutes_with_J (m : ℕ) (D1 D2 : Matrix (Fin m) (Fin m) ℝ) :
  let K := K_matrix m
  let M := K * fromBlocks D1 0 0 D2 * K.transpose
  let J_sum := exchangeMatrixSum m
  M * J_sum = J_sum * M := by
    unfold K_matrix exchangeMatrixSum;
    simp +decide [ Matrix.fromBlocks_multiply, Matrix.fromBlocks_transpose ];
    norm_num [ Matrix.mul_add, add_mul, mul_assoc, exchangeMatrix_transpose ];
    norm_num [ ← mul_assoc, exchangeMatrix_mul_exchangeMatrix ]

/-
A structure-preserving QR decomposition exists for any centrosymmetric matrix A. This decomposition consists of an orthogonal centrosymmetric Q and a centrosymmetric R that is block diagonal in the K-basis. This implies the problem can be reduced to two smaller QR decompositions.
-/
open Matrix

def IsBlockDiagonal {m : ℕ} (M : Matrix (Fin m ⊕ Fin m) (Fin m ⊕ Fin m) ℝ) : Prop :=
  ∀ (i j : Fin m ⊕ Fin m), (Sum.isLeft i ≠ Sum.isLeft j) → M i j = 0

def IsCentrosymmetricBlock {m : ℕ} (A : Matrix (Fin m ⊕ Fin m) (Fin m ⊕ Fin m) ℝ) : Prop :=
  let J := exchangeMatrixSum m
  A * J = J * A

structure StructurePreservingQR (m : ℕ) (A : Matrix (Fin m ⊕ Fin m) (Fin m ⊕ Fin m) ℝ) where
  Q : Matrix (Fin m ⊕ Fin m) (Fin m ⊕ Fin m) ℝ
  R : Matrix (Fin m ⊕ Fin m) (Fin m ⊕ Fin m) ℝ
  h_prod : A = Q * R
  h_Q_orth : Q.transpose * Q = 1
  h_Q_centro : IsCentrosymmetricBlock Q
  h_R_centro : IsCentrosymmetricBlock R
  h_R_struct : IsBlockDiagonal ((K_matrix m).transpose * R * (K_matrix m))

theorem exists_structure_preserving_QR (m : ℕ) (A : Matrix (Fin m ⊕ Fin m) (Fin m ⊕ Fin m) ℝ)
  (hA : IsCentrosymmetricBlock A) : Nonempty (StructurePreservingQR m A) := by
    use 1, A;
    · norm_num;
    · norm_num;
    · unfold IsCentrosymmetricBlock at * ; aesop;
    · -- By definition of $K$, we know that $K^T * A * K$ is block diagonal.
      have h_block_diag : ∃ D1 D2 : Matrix (Fin m) (Fin m) ℝ, (K_matrix m).transpose * A * K_matrix m = fromBlocks D1 0 0 D2 := by
        -- Let's denote the blocks of A as A11, A12, A21, and A22.
        obtain ⟨A11, A12, A21, A22, hA⟩ : ∃ A11 A12 A21 A22 : Matrix (Fin m) (Fin m) ℝ, A = fromBlocks A11 A12 A21 A22 ∧ A21 = exchangeMatrix m * A12 * exchangeMatrix m ∧ A22 = exchangeMatrix m * A11 * exchangeMatrix m := by
          unfold IsCentrosymmetricBlock at hA;
          refine' ⟨ A.submatrix ( Sum.inl ) ( Sum.inl ), A.submatrix ( Sum.inl ) ( Sum.inr ), A.submatrix ( Sum.inr ) ( Sum.inl ), A.submatrix ( Sum.inr ) ( Sum.inr ), _, _, _ ⟩ <;> simp +decide [ ← Matrix.ext_iff, Fin.forall_fin_two, Matrix.mul_apply, Fin.sum_univ_succ ] at *;
          · unfold exchangeMatrixSum at * ; simp_all +decide [ Finset.sum_add_distrib, mul_assoc, mul_comm, mul_left_comm, Finset.mul_sum _ _ _ ];
            intro i j; specialize hA; have := hA.2 i; simp_all +decide [ ← mul_assoc, ← Finset.mul_sum _ _ _, ← Finset.sum_mul, exchangeMatrix ] ;
          · unfold exchangeMatrixSum at *; simp +decide [ Finset.sum_apply, Matrix.mul_apply, Finset.mul_sum _ _ _, Finset.sum_mul ] at *;
            simp_all +decide [ ← mul_assoc, ← Finset.mul_sum _ _ _, ← Finset.sum_mul, exchangeMatrix ];
        use A11 + A12 * exchangeMatrix m, A11 - A12 * exchangeMatrix m;
        rw [ hA.1 ];
        convert centrosymmetric_decomposition m A11 A12 using 1;
        rw [ hA.2.1, hA.2.2 ];
      unfold IsBlockDiagonal; aesop;

/-
Construct a centrosymmetric matrix from two blocks D1 and D2.
-/
def merge_matrix (m : ℕ) (D1 D2 : Matrix (Fin m) (Fin m) ℝ) : Matrix (Fin m ⊕ Fin m) (Fin m ⊕ Fin m) ℝ :=
  let J := exchangeMatrix m
  let A11 := (1/2 : ℝ) • (D1 + D2)
  let A12 := (1/2 : ℝ) • (D1 - D2) * J
  let A21 := J * A12 * J
  let A22 := J * A11 * J
  fromBlocks A11 A12 A21 A22

/-
Define the maps between the full matrix space and the decoupled block space.
-/
def to_blocks (m : ℕ) (A : Matrix (Fin m ⊕ Fin m) (Fin m ⊕ Fin m) ℝ) : Matrix (Fin m) (Fin m) ℝ × Matrix (Fin m) (Fin m) ℝ :=
  let K := K_matrix m
  let B := K.transpose * A * K
  (B.submatrix Sum.inl Sum.inl, B.submatrix Sum.inr Sum.inr)

def from_blocks (m : ℕ) (D : Matrix (Fin m) (Fin m) ℝ × Matrix (Fin m) (Fin m) ℝ) : Matrix (Fin m ⊕ Fin m) (Fin m ⊕ Fin m) ℝ :=
  let K := K_matrix m
  K * fromBlocks D.1 0 0 D.2 * K.transpose

/-
Multiplication of block diagonal matrices.
-/
lemma fromBlocks_mul_block_diagonal {m : ℕ} (A B C D : Matrix (Fin m) (Fin m) ℝ) :
  fromBlocks A 0 0 B * fromBlocks C 0 0 D = fromBlocks (A * C) 0 0 (B * D) := by
    simp +decide [ fromBlocks_multiply ]

/-
K is orthogonal, so K * K^T = I.
-/
lemma K_matrix_mul_transpose (m : ℕ) :
  let K := K_matrix m
  K * K.transpose = 1 := by
    convert K_matrix_orthogonal m using 1;
    rw [ Matrix.mul_eq_one_comm ]

/-
A centrosymmetric matrix has a specific block structure determined by its top-left and top-right blocks.
-/
lemma centrosymmetric_block_form (m : ℕ) (A : Matrix (Fin m ⊕ Fin m) (Fin m ⊕ Fin m) ℝ)
  (hA : IsCentrosymmetricBlock A) :
  let J := exchangeMatrix m
  A = fromBlocks (A.submatrix Sum.inl Sum.inl) (A.submatrix Sum.inl Sum.inr)
                 (J * (A.submatrix Sum.inl Sum.inr) * J) (J * (A.submatrix Sum.inl Sum.inl) * J) := by
                   unfold IsCentrosymmetricBlock at hA;
                   simp_all +decide [ ← Matrix.ext_iff, Fin.forall_fin_two, Matrix.mul_apply, Matrix.submatrix_apply ];
                   unfold exchangeMatrixSum at *;
                   unfold exchangeMatrix at *; simp_all +decide [ Finset.sum_ite, Finset.filter_eq', Finset.filter_ne' ] ;

/-
For a centrosymmetric matrix, the transformed matrix is block diagonal.
-/
lemma transform_eq_blocks (m : ℕ) (A : Matrix (Fin m ⊕ Fin m) (Fin m ⊕ Fin m) ℝ)
  (hA : IsCentrosymmetricBlock A) :
  let K := K_matrix m
  K.transpose * A * K = fromBlocks (to_blocks m A).1 0 0 (to_blocks m A).2 := by
    have := @centrosymmetric_decomposition;
    rw [ centrosymmetric_block_form m A hA ];
    unfold to_blocks; aesop;

/-
The transformation to blocks preserves multiplication for centrosymmetric matrices.
-/
lemma to_blocks_mul (m : ℕ) (A B : Matrix (Fin m ⊕ Fin m) (Fin m ⊕ Fin m) ℝ)
  (hA : IsCentrosymmetricBlock A) (hB : IsCentrosymmetricBlock B) :
  to_blocks m (A * B) = ( (to_blocks m A).1 * (to_blocks m B).1, (to_blocks m A).2 * (to_blocks m B).2 ) := by
    -- By definition of to_blocks, we know that K^T * (A * B) * K is block diagonal.
    have h_block_diag : let K := K_matrix m
      K.transpose * (A * B) * K = fromBlocks ((to_blocks m A).1 * (to_blocks m B).1) 0 0 ((to_blocks m A).2 * (to_blocks m B).2) := by
        have h_transform_mul : ∀ (A B : Matrix (Fin m ⊕ Fin m) (Fin m ⊕ Fin m) ℝ), IsCentrosymmetricBlock A → IsCentrosymmetricBlock B → let K := K_matrix m; K.transpose * (A * B) * K = (K.transpose * A * K) * (K.transpose * B * K) := by
          simp +decide [ Matrix.mul_assoc ];
          simp_all +decide [ ← Matrix.mul_assoc, K_matrix_mul_transpose ];
        have h_transform_mul : let K := K_matrix m; K.transpose * (A * B) * K = (fromBlocks ((to_blocks m A).1) 0 0 ((to_blocks m A).2)) * (fromBlocks ((to_blocks m B).1) 0 0 ((to_blocks m B).2)) := by
          have h_transform_mul : let K := K_matrix m; K.transpose * A * K = fromBlocks ((to_blocks m A).1) 0 0 ((to_blocks m A).2) ∧ K.transpose * B * K = fromBlocks ((to_blocks m B).1) 0 0 ((to_blocks m B).2) := by
            exact ⟨ transform_eq_blocks m A hA, transform_eq_blocks m B hB ⟩;
          grind;
        exact h_transform_mul.trans ( fromBlocks_mul_block_diagonal _ _ _ _ );
    unfold to_blocks at *; aesop;

/-
The identity matrix is centrosymmetric.
-/
lemma IsCentrosymmetricBlock_one (m : ℕ) : IsCentrosymmetricBlock (1 : Matrix (Fin m ⊕ Fin m) (Fin m ⊕ Fin m) ℝ) := by
  unfold IsCentrosymmetricBlock
  simp

/-
A matrix constructed from blocks is block diagonal.
-/
lemma is_block_diagonal_from_blocks (m : ℕ) (D1 D2 : Matrix (Fin m) (Fin m) ℝ) :
  IsBlockDiagonal (fromBlocks D1 0 0 D2) := by
    unfold IsBlockDiagonal; aesop;

/-
Define Upper Triangular matrices, standard QR decomposition, and the corrected Structure Preserving QR decomposition (with triangularity condition).
-/
def IsUpperTriangular {n : ℕ} (R : Matrix (Fin n) (Fin n) ℝ) : Prop :=
  ∀ i j, i > j → R i j = 0

structure QR_decomposition (n : ℕ) (M : Matrix (Fin n) (Fin n) ℝ) where
  Q : Matrix (Fin n) (Fin n) ℝ
  R : Matrix (Fin n) (Fin n) ℝ
  h_prod : M = Q * R
  h_Q_orth : Q.transpose * Q = 1
  h_R_upper : IsUpperTriangular R

structure StructurePreservingQR_Corrected (m : ℕ) (A : Matrix (Fin m ⊕ Fin m) (Fin m ⊕ Fin m) ℝ) where
  Q : Matrix (Fin m ⊕ Fin m) (Fin m ⊕ Fin m) ℝ
  R : Matrix (Fin m ⊕ Fin m) (Fin m ⊕ Fin m) ℝ
  h_prod : A = Q * R
  h_Q_orth : Q.transpose * Q = 1
  h_Q_centro : IsCentrosymmetricBlock Q
  h_R_centro : IsCentrosymmetricBlock R
  h_R_upper_blocks : IsUpperTriangular (to_blocks m R).1 ∧ IsUpperTriangular (to_blocks m R).2

/-
Prove that the user's definition of StructurePreservingQR is trivially satisfied by Q=I, R=A.
-/
theorem exists_structure_preserving_QR_trivial (m : ℕ) (A : Matrix (Fin m ⊕ Fin m) (Fin m ⊕ Fin m) ℝ)
  (hA : IsCentrosymmetricBlock A) : Nonempty (StructurePreservingQR m A) := by
    exact?

/-
The transformation from blocks to the full matrix is the inverse of the transformation to blocks.
-/
lemma from_blocks_to_blocks (m : ℕ) (A : Matrix (Fin m ⊕ Fin m) (Fin m ⊕ Fin m) ℝ)
  (hA : IsCentrosymmetricBlock A) :
  from_blocks m (to_blocks m A) = A := by
  let K := K_matrix m
  have hK_orth : K.transpose * K = 1 := K_matrix_orthogonal m
  have hK_trans : K * K.transpose = 1 := K_matrix_mul_transpose m
  have h_diag : K.transpose * A * K = fromBlocks (to_blocks m A).1 0 0 (to_blocks m A).2 := transform_eq_blocks m A hA
  unfold from_blocks
  rw [← h_diag]
  simp only [Matrix.mul_assoc]
  rw [hK_trans, Matrix.mul_one]
  -- Now we have K * K^T * A.
  -- Wait, K * (K^T * A * K) * K^T = K * K^T * A * K * K^T = I * A * I = A.
  -- The associativity might be tricky.
  -- K * (K^T * A * K) * K^T
  -- = (K * K^T) * A * (K * K^T)
  -- = 1 * A * 1 = A.
  repeat rw [Matrix.mul_assoc]
  -- K * K^T * A * K * K^T
  -- We need to group K * K^T.
  -- The current expression is K * K^T * A * K * K^T ? No.
  -- from_blocks is K * (...) * K^T.
  -- (...) is K^T * A * K.
  -- So K * (K^T * A * K) * K^T.
  -- = (K * K^T) * A * (K * K^T) ? No.
  -- = (K * K^T) * A * K * K^T
  -- = 1 * A * K * K^T
  -- = A * (K * K^T)
  -- = A * 1 = A.
  rw [ ← Matrix.mul_assoc, hK_trans, Matrix.one_mul ]

/-
The transformation to blocks preserves multiplication for centrosymmetric matrices.
-/
lemma to_blocks_mul_eq (m : ℕ) (A B : Matrix (Fin m ⊕ Fin m) (Fin m ⊕ Fin m) ℝ)
  (hA : IsCentrosymmetricBlock A) (hB : IsCentrosymmetricBlock B) :
  to_blocks m (A * B) = ( (to_blocks m A).1 * (to_blocks m B).1, (to_blocks m A).2 * (to_blocks m B).2 ) := by
    exact?

/-
Conjugation by K preserves multiplication.
-/
lemma conjugate_mul (m : ℕ) (A B : Matrix (Fin m ⊕ Fin m) (Fin m ⊕ Fin m) ℝ) :
  let K := K_matrix m
  K.transpose * (A * B) * K = (K.transpose * A * K) * (K.transpose * B * K) := by
    simp +decide [ ← Matrix.mul_assoc ];
    -- Since $K$ is orthogonal, we have $K * K^T = I$.
    have hK_orth : K_matrix m * (K_matrix m).transpose = 1 := by
      exact?;
    simp +decide [ mul_assoc, hK_orth ]

/-
A matrix constructed from diagonal blocks in the K-basis is centrosymmetric.
-/
lemma from_blocks_is_centrosymmetric (m : ℕ) (D1 D2 : Matrix (Fin m) (Fin m) ℝ) :
  IsCentrosymmetricBlock (from_blocks m (D1, D2)) := by
    have := @reconstruction_commutes_with_J;
    exact?

/-
The transformation to blocks is the inverse of the transformation from blocks.
-/
lemma to_blocks_from_blocks (m : ℕ) (D : Matrix (Fin m) (Fin m) ℝ × Matrix (Fin m) (Fin m) ℝ) :
  to_blocks m (from_blocks m D) = D := by
    unfold from_blocks to_blocks;
    norm_num [ ← mul_assoc, K_matrix_mul_transpose ];
    norm_num [ Matrix.mul_assoc, K_matrix_orthogonal ];
    exact?

/-
Multiplication of matrices constructed from blocks corresponds to multiplication of the blocks.
-/
lemma from_blocks_mul (m : ℕ) (D1 D2 : Matrix (Fin m) (Fin m) ℝ × Matrix (Fin m) (Fin m) ℝ) :
  from_blocks m D1 * from_blocks m D2 = from_blocks m (D1.1 * D2.1, D1.2 * D2.2) := by
    -- By definition of from_blocks, we can write the product as:
    obtain ⟨D11, D12⟩ := D1
    obtain ⟨D21, D22⟩ := D2
    simp [from_blocks];
    simp +decide [ ← mul_assoc, K_matrix_mul_transpose ];
    simp +decide [ Matrix.mul_assoc, K_matrix_orthogonal ];
    simp +decide [ ← Matrix.mul_assoc, fromBlocks_mul_block_diagonal ]

/-
Construct a structure-preserving QR decomposition from the QR decompositions of the blocks.
-/
def construct_SPQR (m : ℕ) (A : Matrix (Fin m ⊕ Fin m) (Fin m ⊕ Fin m) ℝ)
  (hA : IsCentrosymmetricBlock A)
  (Q1 R1 Q2 R2 : Matrix (Fin m) (Fin m) ℝ)
  (h1 : (to_blocks m A).1 = Q1 * R1)
  (h2 : (to_blocks m A).2 = Q2 * R2)
  (hQ1 : Q1.transpose * Q1 = 1)
  (hQ2 : Q2.transpose * Q2 = 1)
  (hR1 : IsUpperTriangular R1)
  (hR2 : IsUpperTriangular R2) :
  StructurePreservingQR_Corrected m A :=
  let Q := from_blocks m (Q1, Q2)
  let R := from_blocks m (R1, R2)
  { Q := Q,
    R := R,
    h_prod := by
      -- By definition of matrix multiplication and the properties of the transformation to blocks, we have:
      have h_mul : from_blocks m (to_blocks m A) = A := by
        exact?;
      rw [ ← h_mul, eq_comm ];
      convert from_blocks_mul m ( Q1, Q2 ) ( R1, R2 ) using 1;
      exact congr_arg _ ( Prod.ext h1 h2 ),
    h_Q_orth := by
      -- By definition of Q, we have Q = fromBlocks Q1 0 0 Q2.
      simp [Q];
      simp_all +decide [ from_blocks, Matrix.mul_assoc ];
      simp_all +decide [ ← Matrix.mul_assoc, K_matrix_orthogonal ];
      simp_all +decide [ Matrix.mul_assoc, Matrix.fromBlocks_transpose ];
      -- Since $K$ is orthogonal, we have $K * Kᵀ = 1$.
      have hK_orth : K_matrix m * (K_matrix m)ᵀ = 1 := by
        apply K_matrix_mul_transpose;
      simp_all +decide [ ← Matrix.mul_assoc, fromBlocks_mul_block_diagonal ],
    h_Q_centro := by
      -- By definition of $from_blocks$, we know that $Q$ is centrosymmetric.
      apply from_blocks_is_centrosymmetric,
    h_R_centro := by
      -- By definition of R, we know that R = from_blocks (R1, R2).
      apply from_blocks_is_centrosymmetric m R1 R2,
    h_R_upper_blocks := by
      -- By definition of `from_blocks`, the blocks of `R` are `R1` and `R2`.
      have h_blocks_R : to_blocks m R = (R1, R2) := by
        -- By definition of `to_blocks`, we know that `to_blocks m R = (R1, R2)`.
        apply to_blocks_from_blocks;
      aesop }

/-
Construct a StructurePreservingQR decomposition from the QR decompositions of the blocks.
-/
def construct_SPQR_original (m : ℕ) (A : Matrix (Fin m ⊕ Fin m) (Fin m ⊕ Fin m) ℝ)
  (hA : IsCentrosymmetricBlock A)
  (Q1 R1 Q2 R2 : Matrix (Fin m) (Fin m) ℝ)
  (h1 : (to_blocks m A).1 = Q1 * R1)
  (h2 : (to_blocks m A).2 = Q2 * R2)
  (hQ1 : Q1.transpose * Q1 = 1)
  (hQ2 : Q2.transpose * Q2 = 1) :
  StructurePreservingQR m A :=
  let Q := from_blocks m (Q1, Q2)
  let R := from_blocks m (R1, R2)
  { Q := Q,
    R := R,
    h_prod := by
      rw [ ← from_blocks_to_blocks m A hA ];
      rw [ from_blocks_mul ];
      grind,
    h_Q_orth := by
      unfold IsCentrosymmetricBlock at hA;
      simp +zetaDelta at *;
      simp_all +decide [ from_blocks, Matrix.fromBlocks_transpose ];
      simp_all +decide [ Matrix.mul_assoc, K_matrix_mul_transpose ];
      simp_all +decide [ ← Matrix.mul_assoc, K_matrix_orthogonal ];
      simp_all +decide [ fromBlocks_mul_block_diagonal, Matrix.mul_assoc ];
      rw [ ← Matrix.mul_eq_one_comm, K_matrix_orthogonal ],
    h_Q_centro := from_blocks_is_centrosymmetric m Q1 Q2,
    h_R_centro := from_blocks_is_centrosymmetric m R1 R2,
    h_R_struct := by
      -- By definition of $from_blocks$, we know that $(K_matrix m).transpose * R * K_matrix m = fromBlocks (R1) 0 0 (R2)$.
      have hR_transformed : (K_matrix m).transpose * R * K_matrix m = fromBlocks (R1) 0 0 (R2) := by
        have hR_transformed : (K_matrix m).transpose * R * K_matrix m = (K_matrix m).transpose * (from_blocks m (R1, R2)) * K_matrix m := by
          rfl;
        convert transform_eq_blocks m ( from_blocks m ( R1, R2 ) ) _ using 1;
        · rw [ to_blocks_from_blocks ];
        · exact?;
      intro i j hij; aesop; }

/-
Construct a corrected structure-preserving QR decomposition from the QR decompositions of the blocks.
-/
def construct_SPQR_Corrected (m : ℕ) (A : Matrix (Fin m ⊕ Fin m) (Fin m ⊕ Fin m) ℝ)
  (hA : IsCentrosymmetricBlock A)
  (Q1 R1 Q2 R2 : Matrix (Fin m) (Fin m) ℝ)
  (h1 : (to_blocks m A).1 = Q1 * R1)
  (h2 : (to_blocks m A).2 = Q2 * R2)
  (hQ1 : Q1.transpose * Q1 = 1)
  (hQ2 : Q2.transpose * Q2 = 1)
  (hR1 : IsUpperTriangular R1)
  (hR2 : IsUpperTriangular R2) :
  StructurePreservingQR_Corrected m A :=
  let Q := from_blocks m (Q1, Q2)
  let R := from_blocks m (R1, R2)
  { Q := Q,
    R := R,
    h_prod := by
      have h_prod : A = from_blocks m (to_blocks m A) := by
        exact?;
      rw [ h_prod, show to_blocks m A = ( Q1 * R1, Q2 * R2 ) from Prod.ext h1 h2, from_blocks_mul ],
    h_Q_orth := by
      simp +zetaDelta at *;
      simp_all +decide [ from_blocks, Matrix.mul_assoc ];
      -- By definition of $K$, we know that $K^T K = I$.
      have hK_ortho : (K_matrix m).transpose * K_matrix m = 1 := by
        exact K_matrix_orthogonal m;
      simp_all +decide [ ← Matrix.mul_assoc, fromBlocks_transpose ];
      simp_all +decide [ fromBlocks_multiply, Matrix.mul_assoc ];
      rw [ ← Matrix.mul_eq_one_comm, hK_ortho ],
    h_Q_centro := from_blocks_is_centrosymmetric m Q1 Q2,
    h_R_centro := from_blocks_is_centrosymmetric m R1 R2,
    h_R_upper_blocks := by
      have h_to_blocks_R : to_blocks m R = (R1, R2) := by
        exact to_blocks_from_blocks _ _;
      aesop }

/-
Prove the existence of a structure-preserving QR decomposition by reducing to trivial decompositions of the blocks.
-/
theorem exists_structure_preserving_QR_proven (m : ℕ) (A : Matrix (Fin m ⊕ Fin m) (Fin m ⊕ Fin m) ℝ)
  (hA : IsCentrosymmetricBlock A) : Nonempty (StructurePreservingQR m A) := by
    exact?

/-
Extract QR decompositions of the blocks from a structure-preserving QR decomposition.
-/
def extract_QR_blocks (m : ℕ) (A : Matrix (Fin m ⊕ Fin m) (Fin m ⊕ Fin m) ℝ)
  (hA : IsCentrosymmetricBlock A)
  (spqr : StructurePreservingQR_Corrected m A) :
  QR_decomposition m (to_blocks m A).1 × QR_decomposition m (to_blocks m A).2 :=
  let Q := spqr.Q
  let R := spqr.R
  let Q_blocks := to_blocks m Q
  let R_blocks := to_blocks m R
  let Q1 := Q_blocks.1
  let Q2 := Q_blocks.2
  let R1 := R_blocks.1
  let R2 := R_blocks.2
  have h_prod : (to_blocks m A).1 = Q1 * R1 ∧ (to_blocks m A).2 = Q2 * R2 := by
    have h_QR : (to_blocks m (Q * R)).1 = Q1 * R1 ∧ (to_blocks m (Q * R)).2 = Q2 * R2 := by
      have := to_blocks_mul m Q R spqr.h_Q_centro spqr.h_R_centro; aesop;
    cases spqr ; aesop
  have h_Q1_orth : Q1.transpose * Q1 = 1 := by
    have hQ1 : (K_matrix m).transpose * Q * K_matrix m = fromBlocks Q1 0 0 Q2 := by
      convert transform_eq_blocks m Q ( spqr.h_Q_centro ) using 1;
    have hQ1 : (K_matrix m).transpose * Q.transpose * Q * K_matrix m = fromBlocks (Q1.transpose * Q1) 0 0 (Q2.transpose * Q2) := by
      convert congr_arg ( fun x => x.transpose * x ) hQ1 using 1;
      · norm_num [ ← Matrix.mul_assoc, K_matrix_orthogonal ];
        simp +decide [ Matrix.mul_assoc, K_matrix_mul_transpose ];
      · norm_num [ Matrix.fromBlocks_transpose, Matrix.fromBlocks_multiply ];
    have hQ1 : (K_matrix m).transpose * Q.transpose * Q * K_matrix m = 1 := by
      have hQ1 : Q.transpose * Q = 1 := by
        exact spqr.h_Q_orth;
      simp +decide [ Matrix.mul_assoc, hQ1, K_matrix_orthogonal ];
    simp_all +decide [ ← Matrix.ext_iff ];
    simp_all +decide [ Matrix.one_apply ]
  have h_Q2_orth : Q2.transpose * Q2 = 1 := by
    have h_Q2_orth : Q.transpose * Q = 1 := by
      exact spqr.h_Q_orth;
    have h_Q2_orth : (K_matrix m).transpose * Q.transpose * Q * (K_matrix m) = (K_matrix m).transpose * (K_matrix m) := by
      simp +decide [ h_Q2_orth, Matrix.mul_assoc ];
    have h_Q2_orth : (K_matrix m).transpose * Q.transpose * Q * (K_matrix m) = fromBlocks (Q_blocks.1.transpose * Q_blocks.1) 0 0 (Q_blocks.2.transpose * Q_blocks.2) := by
      have h_Q2_orth : (K_matrix m).transpose * Q.transpose * Q * (K_matrix m) = ((K_matrix m).transpose * Q * (K_matrix m)).transpose * ((K_matrix m).transpose * Q * (K_matrix m)) := by
        simp +decide [ Matrix.mul_assoc, Matrix.transpose_mul ];
        simp +decide [ ← Matrix.mul_assoc, K_matrix_mul_transpose ];
      rw [h_Q2_orth];
      have h_Q2_orth : (K_matrix m).transpose * Q * (K_matrix m) = fromBlocks Q_blocks.1 0 0 Q_blocks.2 := by
        apply transform_eq_blocks;
        exact spqr.h_Q_centro;
      rw [h_Q2_orth];
      simp +decide [ Matrix.fromBlocks_transpose, Matrix.fromBlocks_multiply ];
    simp_all +decide [ K_matrix_orthogonal ];
    simp_all +decide [ ← Matrix.ext_iff, Fin.forall_fin_two ];
    simp_all +decide [ Matrix.one_apply ];
    grind
  have h_R1_upper : IsUpperTriangular R1 := spqr.h_R_upper_blocks.1
  have h_R2_upper : IsUpperTriangular R2 := spqr.h_R_upper_blocks.2
  ({ Q := Q1, R := R1, h_prod := h_prod.1, h_Q_orth := h_Q1_orth, h_R_upper := h_R1_upper },
   { Q := Q2, R := R2, h_prod := h_prod.2, h_Q_orth := h_Q2_orth, h_R_upper := h_R2_upper })

/-
The transformation to blocks preserves multiplication for centrosymmetric matrices.
-/
lemma to_blocks_mul_new (m : ℕ) (A B : Matrix (Fin m ⊕ Fin m) (Fin m ⊕ Fin m) ℝ)
  (hA : IsCentrosymmetricBlock A) (hB : IsCentrosymmetricBlock B) :
  to_blocks m (A * B) = ( (to_blocks m A).1 * (to_blocks m B).1, (to_blocks m A).2 * (to_blocks m B).2 ) := by
    exact?

#check Matrix.fromBlocks_apply₁₁

/-
The transformation to blocks preserves multiplication for centrosymmetric matrices.
-/
lemma to_blocks_mul_final (m : ℕ) (A B : Matrix (Fin m ⊕ Fin m) (Fin m ⊕ Fin m) ℝ)
  (hA : IsCentrosymmetricBlock A) (hB : IsCentrosymmetricBlock B) :
  to_blocks m (A * B) = ( (to_blocks m A).1 * (to_blocks m B).1, (to_blocks m A).2 * (to_blocks m B).2 ) := by
    exact?

/-
The transpose of a matrix constructed from blocks corresponds to the transpose of the blocks.
-/
lemma from_blocks_transpose (m : ℕ) (D1 D2 : Matrix (Fin m) (Fin m) ℝ) :
  (from_blocks m (D1, D2)).transpose = from_blocks m (D1.transpose, D2.transpose) := by
    unfold from_blocks;
    unfold K_matrix; norm_num [ Matrix.fromBlocks_transpose ] ;
    rw [ Matrix.mul_assoc ]

/-
The transformation to blocks preserves multiplication for centrosymmetric matrices (easy proof).
-/
lemma to_blocks_mul_easy (m : ℕ) (A B : Matrix (Fin m ⊕ Fin m) (Fin m ⊕ Fin m) ℝ)
  (hA : IsCentrosymmetricBlock A) (hB : IsCentrosymmetricBlock B) :
  to_blocks m (A * B) = ( (to_blocks m A).1 * (to_blocks m B).1, (to_blocks m A).2 * (to_blocks m B).2 ) := by
    exact?