/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 7a9370cb-b056-48dd-93a2-bb88ed623fef
-/

/-
We define Fibonacci primes and the set of prime factors of Fibonacci numbers.
As the infinitude of Fibonacci primes is an open problem, we instead prove that
the set of prime factors of Fibonacci numbers is infinite.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

#check Nat.fib
#check Nat.Prime

/-
The set of Fibonacci primes.
-/
def FibonacciPrimes : Set ℕ := { p | Nat.Prime p ∧ ∃ n, p = Nat.fib n }

/-
The set of prime factors of Fibonacci numbers is infinite.
-/
def FibonacciPrimeFactors : Set ℕ := { p | Nat.Prime p ∧ ∃ n, p ∣ Nat.fib n }

theorem infinite_fibonacci_prime_factors : Set.Infinite FibonacciPrimeFactors := by
  -- Consider the set of Fibonacci numbers with prime indices, $\{F_p \mid p \text{ is prime}\}$.
  have h_fib_prime_indices : Set.Infinite {p : ℕ | Nat.Prime p ∧ ∃ q : ℕ, Nat.Prime q ∧ q ∣ Nat.fib p} := by
    rw [ Set.infinite_iff_exists_gt ] at *;
    exact fun n => by rcases Nat.exists_infinite_primes ( n + 3 ) with ⟨ p, hp ⟩ ; exact ⟨ p, ⟨ by aesop, Nat.minFac ( Nat.fib p ), Nat.minFac_prime ( Nat.ne_of_gt <| by linarith [ Nat.le_fib_add_one p ] ), Nat.minFac_dvd _ ⟩, by linarith ⟩ ;
  -- Since the Fibonacci numbers with prime indices are pairwise coprime, their prime factors must also be distinct.
  have h_distinct_prime_factors : ∀ p q : ℕ, Nat.Prime p → Nat.Prime q → p ≠ q → ∀ r : ℕ, Nat.Prime r → r ∣ Nat.fib p → r ∣ Nat.fib q → False := by
    intros p q hp hq hpq r hr hrp hrq
    have h_coprime : Nat.gcd (Nat.fib p) (Nat.fib q) = 1 := by
      have h_coprime : Nat.gcd (Nat.fib p) (Nat.fib q) = Nat.fib (Nat.gcd p q) := by
        exact?;
      have := Nat.coprime_primes hp hq; aesop;
    exact Nat.Prime.not_dvd_one hr ( h_coprime ▸ Nat.dvd_gcd hrp hrq );
  choose! f hf using fun p ( hp : Nat.Prime p ∧ ∃ q : ℕ, Nat.Prime q ∧ q ∣ Nat.fib p ) => hp.2;
  have h_distinct_prime_factors : Set.Infinite (Set.image f {p : ℕ | Nat.Prime p ∧ ∃ q : ℕ, Nat.Prime q ∧ q ∣ Nat.fib p}) := by
    refine h_fib_prime_indices.image ?_;
    exact fun p hp q hq hpq => Classical.not_not.1 fun hpq' => h_distinct_prime_factors p q hp.1 hq.1 hpq' ( f p ) ( hf p hp |>.1 ) ( hf p hp |>.2 ) ( hpq.symm ▸ hf q hq |>.2 );
  exact h_distinct_prime_factors.mono fun x hx => by obtain ⟨ p, hp, rfl ⟩ := hx; exact ⟨ hf p hp |>.1, p, hf p hp |>.2 ⟩ ;