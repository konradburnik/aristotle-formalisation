/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 141a3417-b938-4616-939d-ab92036ff86a

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

/-
We define the split-complex numbers and prove that the product of two complex matrices can be computed using 3 real matrix multiplications via a transformation to the split-complex basis. Specifically, we show that the real and imaginary parts of the product (A+Bi)(C+Di) can be expressed in terms of X = (A+B)(C+D)/2 and Y = (A-B)(C-D)/2.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
Proof that complex matrix multiplication can be performed using 3 real matrix multiplications via the split-complex basis method.
-/
structure SplitComplex (R : Type*) where
  re : R
  im : R

def SplitComplex.j {R : Type*} [CommRing R] : SplitComplex R := ⟨0, 1⟩

instance {R : Type*} [Add R] : Add (SplitComplex R) := ⟨fun z w => ⟨z.re + w.re, z.im + w.im⟩⟩
instance {R : Type*} [Sub R] : Sub (SplitComplex R) := ⟨fun z w => ⟨z.re - w.re, z.im - w.im⟩⟩
instance {R : Type*} [Neg R] : Neg (SplitComplex R) := ⟨fun z => ⟨-z.re, -z.im⟩⟩
instance {R : Type*} [CommRing R] : Mul (SplitComplex R) := ⟨fun z w => ⟨z.re * w.re + z.im * w.im, z.re * w.im + z.im * w.re⟩⟩

variable {n : Type*} [Fintype n] [DecidableEq n]
variable {R : Type*} [CommRing R] [Invertible (2 : R)]

open Matrix

theorem matrix_multiplication_trick (A B C D : Matrix n n R) :
  let X := (⅟2 : R) • ((A + B) * (C + D))
  let Y := (⅟2 : R) • ((A - B) * (C - D))
  (A * C - B * D = X + Y - (2 : R) • (B * D)) ∧
  (A * D + B * C = X - Y) := by
    norm_num [ two_mul, mul_assoc, mul_add, add_mul, sub_mul, mul_sub ];
    constructor <;> ext i j <;> norm_num <;> ring;
    · rw [ mul_assoc, mul_assoc ] ; simp +decide [ ← mul_assoc, ← two_mul ] ; ring;
    · simp +decide [ mul_assoc ]