/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: e4f879ff-2c3c-4997-b276-318692d1766a

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

/-
We define split-complex numbers and prove that they form a commutative ring. We then show that the ring of split-complex numbers is isomorphic to the product ring ℝ × ℝ. This isomorphism allows us to prove that multiplying two n × n split-complex matrices is equivalent to performing two n × n real matrix multiplications. In contrast, we formally verify that naive complex matrix multiplication requires four real matrix multiplications, and Gauss's algorithm reduces this to three. Thus, split-complex matrix multiplication is computationally more efficient (2 real multiplications) than complex matrix multiplication (3 or 4 real multiplications).
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
Definition of split-complex numbers.
-/
structure SplitComplex where
  re : ℝ
  im : ℝ

/-
Operations on split-complex numbers.
-/
def SplitComplex.zero : SplitComplex := ⟨0, 0⟩
def SplitComplex.one : SplitComplex := ⟨1, 0⟩
def SplitComplex.j : SplitComplex := ⟨0, 1⟩

def SplitComplex.add (z w : SplitComplex) : SplitComplex := ⟨z.re + w.re, z.im + w.im⟩
def SplitComplex.sub (z w : SplitComplex) : SplitComplex := ⟨z.re - w.re, z.im - w.im⟩
def SplitComplex.neg (z : SplitComplex) : SplitComplex := ⟨-z.re, -z.im⟩
def SplitComplex.mul (z w : SplitComplex) : SplitComplex := ⟨z.re * w.re + z.im * w.im, z.re * w.im + z.im * w.re⟩

instance : Add SplitComplex := ⟨SplitComplex.add⟩
instance : Sub SplitComplex := ⟨SplitComplex.sub⟩
instance : Neg SplitComplex := ⟨SplitComplex.neg⟩
instance : Mul SplitComplex := ⟨SplitComplex.mul⟩
instance : Zero SplitComplex := ⟨SplitComplex.zero⟩
instance : One SplitComplex := ⟨SplitComplex.one⟩

@[ext]
theorem SplitComplex.ext (z w : SplitComplex) (hre : z.re = w.re) (him : z.im = w.im) : z = w := by
  cases z ; cases w ; aesop

/-
Multiplication in split-complex numbers corresponds to component-wise multiplication in the diagonal basis.
-/
def SplitComplex.toRealPair (z : SplitComplex) : ℝ × ℝ := (z.re + z.im, z.re - z.im)
def SplitComplex.ofRealPair (p : ℝ × ℝ) : SplitComplex := ⟨(p.1 + p.2) / 2, (p.1 - p.2) / 2⟩

theorem SplitComplex.toRealPair_mul (z w : SplitComplex) :
    toRealPair (z * w) = ((toRealPair z).1 * (toRealPair w).1, (toRealPair z).2 * (toRealPair w).2) := by
      unfold SplitComplex.toRealPair;
      -- By definition of multiplication in the split-complex numbers, we have:
      have h_mul : (z * w).re = z.re * w.re + z.im * w.im ∧ (z * w).im = z.re * w.im + z.im * w.re := by
        exact ⟨ rfl, rfl ⟩;
      grind

/-
Split-complex numbers form a commutative ring.
-/
instance : CommRing SplitComplex where
  add := SplitComplex.add
  add_assoc := by
    -- By associativity of addition on the reals, we can rearrange the terms.
    have h_assoc : ∀ a b c : ℝ, a + b + c = a + (b + c) := by
      exact fun a b c => add_assoc a b c;
    aesop
  zero := SplitComplex.zero
  zero_add := by
    intro a;
    exact congr_arg₂ _ ( zero_add _ ) ( zero_add _ )
  add_zero := by
    intro z;
    exact congr_arg₂ _ ( add_zero z.re ) ( add_zero z.im )
  neg := SplitComplex.neg
  sub := SplitComplex.sub
  neg_add_cancel := by
    -- Let's choose any arbitrary split-complex number $a = (a₁, a₂)$.
    intro a
    -- By definition of negation, we have $-a = (-a₁, -a₂)$.
    simp [SplitComplex.neg];
    -- By definition of addition in the split-complex numbers, we have:
    have h_add : (⟨-a.re, -a.im⟩ + a) = ⟨-a.re + a.re, -a.im + a.im⟩ := by
      exact?;
    aesop
  add_comm := by
    -- By definition of addition in the split-complex numbers, we have $a + b = (a.re + b.re, a.im + b.im)$ and $b + a = (b.re + a.re, b.im + a.im)$.
    have h_comm : ∀ (a b : SplitComplex), a + b = ⟨a.re + b.re, a.im + b.im⟩ ∧ b + a = ⟨b.re + a.re, b.im + a.im⟩ := by
      aesop;
    simp_all +decide [ add_comm ]
  mul := SplitComplex.mul
  mul_assoc := by
    intro a b c;
    -- By definition of multiplication in the split-complex numbers, we have:
    have h_mul_def : ∀ (z w : SplitComplex), z * w = ⟨z.re * w.re + z.im * w.im, z.re * w.im + z.im * w.re⟩ := by
      exact?;
    rw [ h_mul_def, h_mul_def, h_mul_def, h_mul_def ];
    exact congr_arg₂ _ ( by ring ) ( by ring )
  one := SplitComplex.one
  one_mul := by
    intro z;
    -- Let's express the multiplication and simplify.
    have h_mul : (1 * z) = ⟨1 * z.re + 0 * z.im, 1 * z.im + 0 * z.re⟩ := by
      exact?;
    aesop
  mul_one := by
    rintro ⟨ a, b ⟩ ; exact (by
    -- By definition of multiplication, we have:
    have h_mul : (⟨a, b⟩ : SplitComplex) * 1 = ⟨a * 1 + b * 0, a * 0 + b * 1⟩ := by
      exact?;
    aesop)
  zero_mul := by
    -- By definition of multiplication, we know that $0 * a = 0$ for any split-complex number $a$.
    have h_zero_mul : ∀ (a : SplitComplex), 0 * a = ⟨0 * a.re + 0 * a.im, 0 * a.im + 0 * a.re⟩ := by
      exact?;
    aesop
  mul_zero := by
    -- By definition of multiplication in the split-complex numbers, we have:
    have h_mul_zero : ∀ a : SplitComplex, a * 0 = ⟨a.re * 0 + a.im * 0, a.re * 0 + a.im * 0⟩ := by
      exact?;
    aesop
  left_distrib := by
    -- Expand both sides using the definition of multiplication and addition for split-complex numbers.
    intro a b c
    ext;
    · exact show ( a.re * ( b.re + c.re ) + a.im * ( b.im + c.im ) ) = ( a.re * b.re + a.im * b.im ) + ( a.re * c.re + a.im * c.im ) by ring;
    · exact show a.re * ( b.im + c.im ) + a.im * ( b.re + c.re ) = a.re * b.im + a.im * b.re + ( a.re * c.im + a.im * c.re ) by ring;
  right_distrib := by
    intros a b c;
    -- By definition of multiplication in the split-complex numbers, we have:
    have h_mul_def : ∀ z w : SplitComplex, z * w = ⟨z.re * w.re + z.im * w.im, z.re * w.im + z.im * w.re⟩ := by
      exact?;
    erw [ h_mul_def, h_mul_def, h_mul_def ];
    erw [ show ( a + b ).re = a.re + b.re from rfl, show ( a + b ).im = a.im + b.im from rfl ] ; ring!;
    exact congr_arg₂ _ ( by ring ) ( by ring )
  mul_comm := by
    -- By definition of multiplication in the split-complex numbers, we have:
    have h_mul : ∀ (a b : SplitComplex), a * b = SplitComplex.mk (a.re * b.re + a.im * b.im) (a.re * b.im + a.im * b.re) := by
      exact?;
    simp +decide [ h_mul, add_comm, mul_comm ]
  zsmul := zsmulRec
  nsmul := nsmulRec

/-
Matrix multiplication over split-complex numbers reduces to two real matrix multiplications.
-/
open Matrix

def SplitComplex.toRealMatrixPair {n : Type*} (M : Matrix n n SplitComplex) : Matrix n n ℝ × Matrix n n ℝ :=
  (of fun i j => (M i j).re + (M i j).im, of fun i j => (M i j).re - (M i j).im)

def SplitComplex.ofRealMatrixPair {n : Type*} (P : Matrix n n ℝ × Matrix n n ℝ) : Matrix n n SplitComplex :=
  of fun i j => ⟨(P.1 i j + P.2 i j) / 2, (P.1 i j - P.2 i j) / 2⟩

theorem SplitComplex.toRealMatrixPair_mul {n : Type*} [Fintype n] (A B : Matrix n n SplitComplex) :
    toRealMatrixPair (A * B) = (toRealMatrixPair A * toRealMatrixPair B) := by
      unfold SplitComplex.toRealMatrixPair; ext i j; simp +decide [ Matrix.mul_apply ] ;
      · -- Apply the linearity of addition and multiplication over the reals.
        have h_linear : ∀ z : Finset n, (∑ x ∈ z, A i x * B x j).re + (∑ x ∈ z, A i x * B x j).im = ∑ x ∈ z, ((A i x).re + (A i x).im) * ((B x j).re + (B x j).im) := by
          intro z
          induction' z using Finset.induction with x z hx ih;
          · exact?;
          · simp +decide [ *, Finset.sum_insert hx ];
            rw [ ← ih ] ; ring!;
            rw [ show ( A i x * B x j + ∑ x ∈ z, A i x * B x j ).re = ( A i x * B x j ).re + ( ∑ x ∈ z, A i x * B x j ).re by rfl, show ( A i x * B x j + ∑ x ∈ z, A i x * B x j ).im = ( A i x * B x j ).im + ( ∑ x ∈ z, A i x * B x j ).im by rfl ] ; ring!;
            rw [ show ( A i x * B x j ).re = ( A i x ).re * ( B x j ).re + ( A i x ).im * ( B x j ).im by rfl, show ( A i x * B x j ).im = ( A i x ).re * ( B x j ).im + ( A i x ).im * ( B x j ).re by rfl ] ; ring!;
        exact h_linear Finset.univ;
      · simp +decide [ Matrix.mul_apply ];
        unfold SplitComplex.re SplitComplex.im; simp +decide [ Finset.sum_mul _ _ _, mul_sub, sub_mul ] ;
        -- By definition of split-complex numbers, we can split the sum into real and imaginary parts.
        have h_split : ∀ (z : n → SplitComplex), (∑ x, z x).1 = ∑ x, (z x).1 ∧ (∑ x, z x).2 = ∑ x, (z x).2 := by
          intro z
          induction' (Finset.univ : Finset n) using Finset.induction with x s hx ih;
          · exact ⟨ rfl, rfl ⟩;
          · simp +decide [ *, Finset.sum_insert hx ];
            exact ⟨ by rw [ ← ih.1 ] ; rfl, by rw [ ← ih.2 ] ; rfl ⟩;
        simp +decide [ h_split, SplitComplex.mul ] ; ring;
        -- By definition of split-complex multiplication, we can expand the real and imaginary parts.
        have h_expand : ∀ (z w : SplitComplex), (z * w).re = z.re * w.re + z.im * w.im ∧ (z * w).im = z.re * w.im + z.im * w.re := by
          exact fun z w => ⟨ rfl, rfl ⟩;
        simp +decide [ h_expand, Finset.sum_add_distrib, Finset.sum_sub_distrib ] ; ring

/-
The transformation from split-complex matrices to pairs of real matrices is invertible.
-/
theorem SplitComplex.ofRealMatrixPair_toRealMatrixPair {n : Type*} (M : Matrix n n SplitComplex) :
    ofRealMatrixPair (toRealMatrixPair M) = M := by
      unfold SplitComplex.ofRealMatrixPair SplitComplex.toRealMatrixPair at * ; aesop;

/-
Naive expansion of split-complex matrix multiplication requires 4 real matrix multiplications.
-/
theorem SplitComplex.matrix_mul_expansion {n : Type*} [Fintype n] (A B : Matrix n n SplitComplex) :
    (A * B).map SplitComplex.re = (A.map SplitComplex.re) * (B.map SplitComplex.re) + (A.map SplitComplex.im) * (B.map SplitComplex.im) ∧
    (A * B).map SplitComplex.im = (A.map SplitComplex.re) * (B.map SplitComplex.im) + (A.map SplitComplex.im) * (B.map SplitComplex.re) := by
      constructor <;> ext i j <;> simp +decide [ Matrix.mul_apply, SplitComplex.mul ] ; ring!;
      · -- By definition of split-complex multiplication, the real part of the sum is the sum of the real parts.
        have h_real_part : ∀ (x : n), (A i x * B x j).re = (A i x).re * (B x j).re + (A i x).im * (B x j).im := by
          exact?;
        -- By definition of sum, the real part of the sum is the sum of the real parts.
        have h_real_sum : ∀ (s : Finset n), (∑ x ∈ s, A i x * B x j).re = ∑ x ∈ s, (A i x * B x j).re := by
          intro s; induction s using Finset.induction <;> simp_all +decide ; ring;
          · rfl;
          · exact?;
        rw [ h_real_sum, Finset.sum_congr rfl fun _ _ => h_real_part _, Finset.sum_add_distrib ];
      · -- By definition of multiplication in the split-complex numbers, we can expand the imaginary part of the sum.
        have h_expand : ∀ (z w : SplitComplex), (z * w).im = z.re * w.im + z.im * w.re := by
          exact?;
        -- Apply the expansion to each term in the sum.
        have h_sum_expand : ∀ (s : Finset n) (f : n → SplitComplex), (∑ x ∈ s, f x).im = ∑ x ∈ s, (f x).im := by
          intro s f; induction s using Finset.induction <;> simp +decide [ * ] ;
          · rfl;
          · exact congr_arg₂ _ rfl ‹_›;
        simp +decide only [h_sum_expand, h_expand, Finset.sum_add_distrib]

/-
Complex matrix multiplication can be performed using 3 real matrix multiplications.
-/
theorem Complex.matrix_mul_gauss {n : Type*} [Fintype n] (A B : Matrix n n ℂ) :
    let A_re := A.map Complex.re
    let A_im := A.map Complex.im
    let B_re := B.map Complex.re
    let B_im := B.map Complex.im
    let M1 := A_re * B_re
    let M2 := A_im * B_im
    let M3 := (A_re + A_im) * (B_re + B_im)
    (A * B).map Complex.re = M1 - M2 ∧
    (A * B).map Complex.im = M3 - M1 - M2 := by
      -- By definition of matrix multiplication, we can split the multiplication into real and imaginary parts.
      have h_mul_split : (A * B).map Complex.re = (A.map Complex.re) * (B.map Complex.re) - (A.map Complex.im) * (B.map Complex.im) ∧ (A * B).map Complex.im = (A.map Complex.re) * (B.map Complex.im) + (A.map Complex.im) * (B.map Complex.re) := by
        simp +decide [ ← Matrix.ext_iff, Matrix.mul_apply, Complex.ext_iff ];
        exact fun i j => Finset.sum_add_distrib;
      simp_all +decide [ add_mul, mul_add ];
      abel1

/-
Naive expansion of complex matrix multiplication requires 4 real matrix multiplications.
-/
theorem Complex.matrix_mul_naive {n : Type*} [Fintype n] (A B : Matrix n n ℂ) :
    (A * B).map Complex.re = (A.map Complex.re) * (B.map Complex.re) - (A.map Complex.im) * (B.map Complex.im) ∧
    (A * B).map Complex.im = (A.map Complex.re) * (B.map Complex.im) + (A.map Complex.im) * (B.map Complex.re) := by
      constructor <;> ext i j <;> simp +decide [ Complex.add_re, Complex.add_im, Complex.mul_re, Complex.mul_im, Matrix.mul_apply ];
      rw [ Finset.sum_add_distrib ]