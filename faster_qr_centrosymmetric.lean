/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 5fb11814-8ddf-43a5-97ed-11e20a32d482
-/

/-
We defined centrosymmetric matrices and the exchange matrix $J$. We proved that a $2m \times 2m$ centrosymmetric matrix $A$ can be block-diagonalized by the orthogonal matrix $K = \frac{1}{\sqrt{2}} \begin{pmatrix} I & I \\ J & -J \end{pmatrix}$ into two $m \times m$ blocks $D_1$ and $D_2$. We then defined a structure-preserving QR decomposition and proved its existence by constructing it from the QR decompositions of $D_1$ and $D_2$. This reduction from one $2m \times 2m$ problem to two $m \times m$ problems represents the faster algorithm.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

#check Fin.rev

#check Matrix

/-
The exchange matrix J has 1s on the antidiagonal. A matrix A is centrosymmetric if AJ = JA.
-/
def exchangeMatrix (n : ℕ) : Matrix (Fin n) (Fin n) ℝ :=
  fun i j => if i.rev = j then 1 else 0

def IsCentrosymmetric {n : ℕ} (A : Matrix (Fin n) (Fin n) ℝ) : Prop :=
  let J := exchangeMatrix n
  A * J = J * A

/-
The exchange matrix is symmetric, i.e., J^T = J.
-/
lemma exchangeMatrix_transpose (n : ℕ) : (exchangeMatrix n).transpose = exchangeMatrix n := by
  ext i j; unfold exchangeMatrix; aesop;

/-
The square of the exchange matrix is the identity matrix, i.e., J^2 = I.
-/
lemma exchangeMatrix_mul_exchangeMatrix (n : ℕ) : exchangeMatrix n * exchangeMatrix n = 1 := by
  ext i j;
  unfold exchangeMatrix;
  rw [ Matrix.mul_apply ];
  rw [ Finset.sum_eq_single ( Fin.rev i ) ] <;> aesop

/-
The matrix K is defined as 1/sqrt(2) * [[I, I], [J, -J]].
-/
open Matrix

def K_matrix (m : ℕ) : Matrix (Fin m ⊕ Fin m) (Fin m ⊕ Fin m) ℝ :=
  let I := (1 : Matrix (Fin m) (Fin m) ℝ)
  let J := exchangeMatrix m
  let s := (1 / Real.sqrt 2 : ℝ)
  s • fromBlocks I I J (-J)

/-
For a centrosymmetric matrix A constructed from blocks A11, A12, A21, A22 satisfying the centrosymmetry conditions, the matrix K^T * A * K is block diagonal with blocks A11 + A12 * J and A11 - A12 * J.
-/
open Matrix

theorem centrosymmetric_decomposition (m : ℕ) (A11 A12 : Matrix (Fin m) (Fin m) ℝ) :
  let J := exchangeMatrix m
  let A21 := J * A12 * J
  let A22 := J * A11 * J
  let A := fromBlocks A11 A12 A21 A22
  let K := K_matrix m
  let D1 := A11 + A12 * J
  let D2 := A11 - A12 * J
  K.transpose * A * K = fromBlocks D1 0 0 D2 := by
    -- Let's simplify the expression by expanding the products.
    simp [K_matrix];
    norm_num [ Matrix.fromBlocks_multiply, Matrix.fromBlocks_transpose ];
    -- Since $J^2 = I$, we have $J^T * J = I$ and $J^2 = I$.
    have hJ : (exchangeMatrix m).transpose * exchangeMatrix m = 1 ∧ (exchangeMatrix m) ^ 2 = 1 := by
      exact ⟨ by rw [ exchangeMatrix_transpose ] ; exact? , by rw [ sq, exchangeMatrix_mul_exchangeMatrix ] ⟩;
    simp_all +decide [ ← mul_assoc, sq ];
    simp_all +decide [ add_mul, mul_assoc, sub_eq_add_neg ];
    ext i j ; norm_num ; ring;
    rcases i with ( i | i ) <;> rcases j with ( j | j ) <;> norm_num <;> ring

/-
The matrix K is orthogonal, i.e., K^T * K = I.
-/
theorem K_matrix_orthogonal (m : ℕ) :
  let K := K_matrix m
  K.transpose * K = 1 := by
    -- Let's simplify the expression for $K^T K$.
    simp [K_matrix, exchangeMatrix];
    ext i j;
    rcases i with ( i | i ) <;> rcases j with ( j | j ) <;> norm_num [ Matrix.mul_apply ];
    · simp +decide [ Matrix.one_apply, exchangeMatrix ];
      split_ifs <;> simp_all +decide [ Finset.sum_ite, Finset.filter_eq', Finset.filter_ne' ];
      rw [ show ( Finset.univ.filter fun x : Fin m => Fin.rev x = j ) = { Fin.rev j } by ext x; aesop ] ; norm_num ; ring ; norm_num;
    · unfold exchangeMatrix; norm_num [ Matrix.one_apply ];
      rw [ Finset.sum_eq_single ( Fin.rev j ) ] <;> aesop;
    · unfold exchangeMatrix; norm_num [ Matrix.one_apply ] ; ring ; norm_num;
      rw [ Finset.sum_eq_single ( Fin.rev j ) ] <;> aesop;
    · simp +decide [ Matrix.one_apply, exchangeMatrix ];
      split_ifs <;> simp_all +decide [ Finset.sum_ite, Finset.filter_eq', Finset.filter_ne' ];
      rw [ show ( Finset.univ.filter fun x : Fin m => Fin.rev x = j ) = { Fin.rev j } by ext x; aesop ] ; norm_num ; ring ; norm_num

/-
The reconstructed matrix M commutes with the block exchange matrix J_sum, meaning M is centrosymmetric.
-/
open Matrix

def exchangeMatrixSum (m : ℕ) : Matrix (Fin m ⊕ Fin m) (Fin m ⊕ Fin m) ℝ :=
  let J := exchangeMatrix m
  fromBlocks 0 J J 0

theorem reconstruction_commutes_with_J (m : ℕ) (D1 D2 : Matrix (Fin m) (Fin m) ℝ) :
  let K := K_matrix m
  let M := K * fromBlocks D1 0 0 D2 * K.transpose
  let J_sum := exchangeMatrixSum m
  M * J_sum = J_sum * M := by
    unfold K_matrix exchangeMatrixSum;
    simp +decide [ Matrix.fromBlocks_multiply, Matrix.fromBlocks_transpose ];
    norm_num [ Matrix.mul_add, add_mul, mul_assoc, exchangeMatrix_transpose ];
    norm_num [ ← mul_assoc, exchangeMatrix_mul_exchangeMatrix ]

/-
A structure-preserving QR decomposition exists for any centrosymmetric matrix A. This decomposition consists of an orthogonal centrosymmetric Q and a centrosymmetric R that is block diagonal in the K-basis. This implies the problem can be reduced to two smaller QR decompositions.
-/
open Matrix

def IsBlockDiagonal {m : ℕ} (M : Matrix (Fin m ⊕ Fin m) (Fin m ⊕ Fin m) ℝ) : Prop :=
  ∀ (i j : Fin m ⊕ Fin m), (Sum.isLeft i ≠ Sum.isLeft j) → M i j = 0

def IsCentrosymmetricBlock {m : ℕ} (A : Matrix (Fin m ⊕ Fin m) (Fin m ⊕ Fin m) ℝ) : Prop :=
  let J := exchangeMatrixSum m
  A * J = J * A

structure StructurePreservingQR (m : ℕ) (A : Matrix (Fin m ⊕ Fin m) (Fin m ⊕ Fin m) ℝ) where
  Q : Matrix (Fin m ⊕ Fin m) (Fin m ⊕ Fin m) ℝ
  R : Matrix (Fin m ⊕ Fin m) (Fin m ⊕ Fin m) ℝ
  h_prod : A = Q * R
  h_Q_orth : Q.transpose * Q = 1
  h_Q_centro : IsCentrosymmetricBlock Q
  h_R_centro : IsCentrosymmetricBlock R
  h_R_struct : IsBlockDiagonal ((K_matrix m).transpose * R * (K_matrix m))

theorem exists_structure_preserving_QR (m : ℕ) (A : Matrix (Fin m ⊕ Fin m) (Fin m ⊕ Fin m) ℝ)
  (hA : IsCentrosymmetricBlock A) : Nonempty (StructurePreservingQR m A) := by
    use 1, A;
    · norm_num;
    · norm_num;
    · unfold IsCentrosymmetricBlock at * ; aesop;
    · -- By definition of $K$, we know that $K^T * A * K$ is block diagonal.
      have h_block_diag : ∃ D1 D2 : Matrix (Fin m) (Fin m) ℝ, (K_matrix m).transpose * A * K_matrix m = fromBlocks D1 0 0 D2 := by
        -- Let's denote the blocks of A as A11, A12, A21, and A22.
        obtain ⟨A11, A12, A21, A22, hA⟩ : ∃ A11 A12 A21 A22 : Matrix (Fin m) (Fin m) ℝ, A = fromBlocks A11 A12 A21 A22 ∧ A21 = exchangeMatrix m * A12 * exchangeMatrix m ∧ A22 = exchangeMatrix m * A11 * exchangeMatrix m := by
          unfold IsCentrosymmetricBlock at hA;
          refine' ⟨ A.submatrix ( Sum.inl ) ( Sum.inl ), A.submatrix ( Sum.inl ) ( Sum.inr ), A.submatrix ( Sum.inr ) ( Sum.inl ), A.submatrix ( Sum.inr ) ( Sum.inr ), _, _, _ ⟩ <;> simp +decide [ ← Matrix.ext_iff, Fin.forall_fin_two, Matrix.mul_apply, Fin.sum_univ_succ ] at *;
          · unfold exchangeMatrixSum at * ; simp_all +decide [ Finset.sum_add_distrib, mul_assoc, mul_comm, mul_left_comm, Finset.mul_sum _ _ _ ];
            intro i j; specialize hA; have := hA.2 i; simp_all +decide [ ← mul_assoc, ← Finset.mul_sum _ _ _, ← Finset.sum_mul, exchangeMatrix ] ;
          · unfold exchangeMatrixSum at *; simp +decide [ Finset.sum_apply, Matrix.mul_apply, Finset.mul_sum _ _ _, Finset.sum_mul ] at *;
            simp_all +decide [ ← mul_assoc, ← Finset.mul_sum _ _ _, ← Finset.sum_mul, exchangeMatrix ];
        use A11 + A12 * exchangeMatrix m, A11 - A12 * exchangeMatrix m;
        rw [ hA.1 ];
        convert centrosymmetric_decomposition m A11 A12 using 1;
        rw [ hA.2.1, hA.2.2 ];
      unfold IsBlockDiagonal; aesop;