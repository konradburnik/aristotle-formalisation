/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: ce97d05f-533d-42fe-a47c-76b30d74da8f

Aristotle's budget for this request has been reached.
If there is partial progress, it will appear in this file.
If you would like to continue working off of this partial progress,
please submit the same prompt, and add this .lean file in "Optional: Attach a Lean file as context" field.
-/

/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 9313c7dc-e131-43b8-bb39-54f5ddb32148

Aristotle's budget for this request has been reached.
If there is partial progress, it will appear in this file.
If you would like to continue working off of this partial progress,
please submit the same prompt, and add this .lean file in "Optional: Attach a Lean file as context" field.
-/

/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 327174c4-2ef6-480b-8c14-162fa1ef536e

Aristotle's budget for this request has been reached.
If there is partial progress, it will appear in this file.
If you would like to continue working off of this partial progress,
please submit the same prompt, and add this .lean file in "Optional: Attach a Lean file as context" field.
-/

/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: d0de4923-bf61-45ef-82c0-885c927acae1

Aristotle's budget for this request has been reached.
If there is partial progress, it will appear in this file.
If you would like to continue working off of this partial progress,
please submit the same prompt, and add this .lean file in "Optional: Attach a Lean file as context" field.
-/

/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: eec221bf-822e-4e23-9415-640408233651

Aristotle's budget for this request has been reached.
If there is partial progress, it will appear in this file.
If you would like to continue working off of this partial progress,
please submit the same prompt, and add this .lean file in "Optional: Attach a Lean file as context" field.
-/

/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: ba98c3c6-1075-4e75-8d1f-e765e2249769

Aristotle's budget for this request has been reached.
If there is partial progress, it will appear in this file.
If you would like to continue working off of this partial progress,
please submit the same prompt, and add this .lean file in "Optional: Attach a Lean file as context" field.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
In a strongly regular graph, if two distinct non-adjacent vertices have the same neighborhood, then k = μ.
-/
lemma srg_twins_implies_k_eq_mu {V : Type} [Fintype V] {G : SimpleGraph V} {n k l m : ℕ}
  (hG : G.IsSRGWith n k l m) (x y : V) (hneq : x ≠ y) (h_non_adj : ¬ G.Adj x y)
  (h_twins : G.neighborSet x = G.neighborSet y) : k = m := by
    have := hG;
    -- By definition of SRG, we know that the number of common neighbors of two distinct non-adjacent vertices is equal to μ.
    have h_common_neighbors : ∀ (u v : V), u ≠ v → ¬G.Adj u v → (G.neighborFinset u ∩ G.neighborFinset v).card = m := by
      intros u v huv h_non_adj
      have := this
      simp_all +decide [ SimpleGraph.neighborFinset_eq_filter ];
      convert this.of_not_adj huv h_non_adj;
      rw [ Fintype.subtype_card ] ; congr ; ext ; simp +decide [ SimpleGraph.adj_comm, SimpleGraph.commonNeighbors ];
    have := hG.regular; simp_all +decide [ SimpleGraph.degree, SimpleGraph.neighborFinset_def ] ;
    specialize h_common_neighbors x y hneq h_non_adj; specialize this x; simp_all +decide [ SimpleGraph.degree, SimpleGraph.neighborFinset_def ] ;

/-
In a strongly regular graph with λ=1, the neighborhood of any vertex has size k, and every neighbor has exactly 1 neighbor within the neighborhood.
-/
lemma srg_lambda_1_implies_neighbor_matching {V : Type} [Fintype V] {G : SimpleGraph V} {n k m : ℕ}
  (hG : G.IsSRGWith n k 1 m) (v : V) :
  (G.neighborFinset v).card = k ∧
  ∀ w ∈ G.neighborFinset v, (G.neighborFinset w ∩ G.neighborFinset v).card = 1 := by
    have := hG.regular;
    -- Since $G$ is an SRG with parameters $(n, k, 1, \mu)$, it is $k$-regular, so $|N(v)| = k$. Use this fact.
    have h_card_neighbors : (G.neighborFinset v).card = k := by
      exact this v;
    -- Since $G$ is an SRG with parameters $(n, k, 1, \mu)$, for any $w \in N(v)$, the number of common neighbors of $v$ and $w$ is $\lambda = 1$.
    have h_common_neighbors : ∀ w ∈ G.neighborFinset v, (G.commonNeighbors v w).ncard = 1 := by
      intro w hw;
      have := hG.of_adj v w;
      simp_all +decide [ Set.ncard_eq_toFinset_card' ];
    simp_all +decide [ Set.ncard_eq_toFinset_card', SimpleGraph.commonNeighbors ];
    simpa only [ Finset.inter_comm ] using h_common_neighbors

/-
In a strongly regular graph with λ=1, if two vertices have at least 2 common neighbors, they cannot be adjacent.
-/
lemma srg_lambda_1_implies_not_adj_if_2_common {V : Type} [Fintype V] {G : SimpleGraph V} {n k m : ℕ}
  (hG : G.IsSRGWith n k 1 m) (x y : V) (h_common : (G.commonNeighbors x y).ncard ≥ 2) : ¬ G.Adj x y := by
    -- If $x$ and $y$ are adjacent, then their common neighbors must be exactly the neighbors of $x$ that are also neighbors of $y$, which would be $\lambda = 1$.
    by_contra h_adj
    have h_common_adj : (G.commonNeighbors x y).ncard = 1 := by
      have := hG.3 x y;
      simpa [ Set.ncard_eq_toFinset_card' ] using this h_adj;
    linarith

/-
In an SRG with λ=1, any two distinct neighbors of v have no common neighbors within N(v).
-/
lemma srg_lambda_1_no_common_neighbor_in_neighborhood {V : Type} [Fintype V] {G : SimpleGraph V} {n k m : ℕ}
  (hG : G.IsSRGWith n k 1 m) (v : V) (a b : V)
  (ha : a ∈ G.neighborFinset v) (hb : b ∈ G.neighborFinset v) (hab : a ≠ b) :
  (G.neighborFinset a ∩ G.neighborFinset b ∩ G.neighborFinset v) = ∅ := by
    -- Suppose that $a$ and $b$ have a common neighbor $x$ in $N(v)$.
    by_contra h_common_neighbor
    obtain ⟨x, hx⟩ : ∃ x, x ∈ (G.neighborFinset a) ∩ (G.neighborFinset b) ∩ (G.neighborFinset v) := by
      exact Finset.nonempty_of_ne_empty h_common_neighbor;
    have h_neighborhood : (G.neighborFinset x ∩ G.neighborFinset v).card ≤ 1 := by
      have := srg_lambda_1_implies_neighbor_matching hG v; aesop;
    refine' h_neighborhood.not_lt _;
    refine' Finset.one_lt_card.mpr ⟨ a, _, b, _, _ ⟩ <;> simp_all +decide [ SimpleGraph.adj_comm ]

/-
Checking if SimpleGraph.IsSRGWith is available.
-/
#check SimpleGraph.IsSRGWith

/-
In an SRG with λ=1, if x is not adjacent to v, then any two neighbors of x in N(v) are non-adjacent.
-/
lemma srg_lambda_1_neighbors_of_nonadj_are_nonadj {V : Type} [Fintype V] {G : SimpleGraph V} {n k m : ℕ}
  (hG : G.IsSRGWith n k 1 m) (v x : V) (h_non_adj : ¬ G.Adj v x) (h_neq : v ≠ x)
  (a b : V) (ha : a ∈ G.neighborFinset v) (hb : b ∈ G.neighborFinset v)
  (hax : G.Adj a x) (hbx : G.Adj b x) (hab : a ≠ b) : ¬ G.Adj a b := by
    -- If $a$ and $b$ were adjacent, then they would have at least 2 common neighbors: $v$ and $x$.
    by_contra h_adj
    have h_common : (G.commonNeighbors a b).ncard ≥ 2 := by
      have h_common : (G.commonNeighbors a b) ⊇ {v, x} := by
        simp_all +decide [ Set.insert_subset_iff, SimpleGraph.commonNeighbors ];
        exact ⟨ ha.symm, hb.symm ⟩;
      exact le_trans ( by rw [ Set.ncard_pair h_neq ] ) ( Set.ncard_le_ncard h_common );
    -- Apply the lemma that states if two vertices have at least two common neighbors, they cannot be adjacent.
    apply srg_lambda_1_implies_not_adj_if_2_common hG a b h_common h_adj

/-
In SRG(99,14,1,2), if two vertices in X2 have the same neighbors in X1, then they have no common neighbors in X2.
-/
lemma srg_99_14_1_2_same_pair_implies_disjoint_in_X2 {V : Type} [Fintype V] {G : SimpleGraph V}
  (hG : G.IsSRGWith 99 14 1 2) (v : V)
  (pairs : Finset (Finset V))
  (hpairs_partition : pairs.card = 7 ∧ (∀ p ∈ pairs, p.card = 2) ∧ (∀ p ∈ pairs, p ⊆ G.neighborFinset v) ∧
                      (∀ p ∈ pairs, ∀ q ∈ pairs, p ≠ q → Disjoint p q) ∧
                      (G.neighborFinset v = pairs.biUnion id))
  (p q : Finset V) (hp : p ∈ pairs) (hq : q ∈ pairs) (hpq : p ≠ q)
  (x y : V) (hx : x ∉ insert v (G.neighborFinset v)) (hy : y ∉ insert v (G.neighborFinset v))
  (hxp : (G.neighborFinset x ∩ p).card = 1) (hxq : (G.neighborFinset x ∩ q).card = 1)
  (hyp : (G.neighborFinset y ∩ p).card = 1) (hyq : (G.neighborFinset y ∩ q).card = 1)
  (hx_other : ∀ r ∈ pairs, r ≠ p → r ≠ q → (G.neighborFinset x ∩ r).card = 0)
  (hy_other : ∀ r ∈ pairs, r ≠ p → r ≠ q → (G.neighborFinset y ∩ r).card = 0)
  (hxy_neq : x ≠ y)
  (h_same_neighbors_X1 : G.neighborFinset x ∩ G.neighborFinset v = G.neighborFinset y ∩ G.neighborFinset v) :
  Disjoint (G.neighborFinset x ∩ (Finset.univ \ insert v (G.neighborFinset v)))
           (G.neighborFinset y ∩ (Finset.univ \ insert v (G.neighborFinset v))) := by
             -- Since $x$ and $y$ have the same neighbors in $X_1$, any neighbor of $x$ in $X_2$ must be adjacent to exactly one neighbor of $y$ in $X_1$.
             have h_common_neighbors_X2 : (G.degree x = 14 ∧ G.degree y = 14) ∧ (G.commonNeighbors x y).ncard = 2 := by
               have h_common_neighbors_X2 : (G.degree x = 14 ∧ G.degree y = 14) := by
                 exact ⟨ hG.regular x, hG.regular y ⟩;
               have h_common_neighbors_X2 : (G.commonNeighbors x y).ncard = 2 := by
                 have h_non_adj : ¬ G.Adj x y := by
                   apply srg_lambda_1_implies_not_adj_if_2_common hG x y;
                   have h_common_neighbors_X2 : (G.commonNeighbors x y).ncard ≥ (G.neighborFinset x ∩ (G.neighborFinset v)).card := by
                     rw [ ← Set.ncard_coe_finset ];
                     apply Set.ncard_le_ncard;
                     · simp_all +decide [ Finset.ext_iff, Set.subset_def, SimpleGraph.commonNeighbors ];
                       grind;
                     · exact Set.toFinite _;
                   have h_common_neighbors_X2 : (G.neighborFinset x ∩ p).card + (G.neighborFinset x ∩ q).card ≤ (G.neighborFinset x ∩ G.neighborFinset v).card := by
                     have h_common_neighbors_X2 : (G.neighborFinset x ∩ p) ∪ (G.neighborFinset x ∩ q) ⊆ G.neighborFinset x ∩ G.neighborFinset v := by
                       grind;
                     have := Finset.card_mono h_common_neighbors_X2;
                     rwa [ Finset.card_union_of_disjoint ( Finset.disjoint_left.mpr fun z hz₁ hz₂ => by have := hpairs_partition.2.2.2.1 p hp q hq hpq; exact Finset.disjoint_left.mp this ( Finset.mem_of_mem_inter_right hz₁ ) ( Finset.mem_of_mem_inter_right hz₂ ) ) ] at this;
                   linarith
                 have := hG.4;
                 simpa [ Set.ncard_eq_toFinset_card' ] using this hxy_neq h_non_adj;
               exact ⟨ by assumption, h_common_neighbors_X2 ⟩;
             have h_common_neighbors_X1 : (G.neighborFinset x ∩ G.neighborFinset y ∩ G.neighborFinset v).card = 2 := by
               have h_common_neighbors_X1 : (G.neighborFinset x ∩ G.neighborFinset y ∩ G.neighborFinset v).card = (G.neighborFinset x ∩ G.neighborFinset v).card := by
                 congr 1 with z ; simp_all +decide [ Finset.ext_iff, SimpleGraph.adj_comm ];
                 exact fun hz a ha ha' => h_same_neighbors_X1 _ _ ha ha' |>.1 hz;
               have h_common_neighbors_X1 : (G.neighborFinset x ∩ G.neighborFinset v).card = (G.neighborFinset x ∩ p).card + (G.neighborFinset x ∩ q).card + ∑ r ∈ pairs \ {p, q}, (G.neighborFinset x ∩ r).card := by
                 have h_common_neighbors_X1 : (G.neighborFinset x ∩ G.neighborFinset v).card = ∑ r ∈ pairs, (G.neighborFinset x ∩ r).card := by
                   rw [ hpairs_partition.2.2.2.2, Finset.inter_biUnion ];
                   rw [ Finset.card_biUnion ];
                   · rfl;
                   · exact fun p hp q hq hpq => Disjoint.mono inf_le_right inf_le_right ( hpairs_partition.2.2.2.1 p hp q hq hpq );
                 rw [ h_common_neighbors_X1, ← Finset.sum_sdiff ( Finset.insert_subset hp ( Finset.singleton_subset_iff.mpr hq ) ) ];
                 rw [ Finset.sum_pair hpq, add_comm ];
               rw [ Finset.sum_eq_zero ] at h_common_neighbors_X1 <;> aesop;
             have h_common_neighbors_X2 : (G.neighborFinset x ∩ G.neighborFinset y).card = 2 := by
               convert h_common_neighbors_X2.2 using 1;
               rw [ ← Set.ncard_coe_finset ] ; congr ; ext ; simp +decide [ SimpleGraph.commonNeighbors ] ;
             have h_common_neighbors_X2 : (G.neighborFinset x ∩ G.neighborFinset y ∩ (Finset.univ \ Insert.insert v (G.neighborFinset v))).card = 0 := by
               have h_common_neighbors_X2 : (G.neighborFinset x ∩ G.neighborFinset y ∩ (Finset.univ \ Insert.insert v (G.neighborFinset v))) ⊆ (G.neighborFinset x ∩ G.neighborFinset y) \ (G.neighborFinset x ∩ G.neighborFinset y ∩ G.neighborFinset v) := by
                 simp +contextual [ Finset.subset_iff ];
               have := Finset.card_le_card h_common_neighbors_X2; simp_all +decide [ Finset.card_sdiff ] ;
               simp_all +decide [ Finset.inter_left_comm, Finset.inter_comm ];
             simp_all +decide [ Finset.disjoint_iff_inter_eq_empty ];
             simp_all +decide [ Finset.inter_left_comm, Finset.inter_comm, Finset.inter_assoc ]

/-
In SRG(99,14,1,2), two vertices in X2 connecting to the same pair of edges cannot be twins.
-/
lemma srg_99_14_1_2_no_twins_in_X2ij {V : Type} [Fintype V] {G : SimpleGraph V}
  (hG : G.IsSRGWith 99 14 1 2) (v : V)
  (pairs : Finset (Finset V))
  (hpairs_partition : pairs.card = 7 ∧ (∀ p ∈ pairs, p.card = 2) ∧ (∀ p ∈ pairs, p ⊆ G.neighborFinset v) ∧
                      (∀ p ∈ pairs, ∀ q ∈ pairs, p ≠ q → Disjoint p q) ∧
                      (G.neighborFinset v = pairs.biUnion id))
  (p q : Finset V) (hp : p ∈ pairs) (hq : q ∈ pairs) (hpq : p ≠ q)
  (x y : V) (hx : x ∉ insert v (G.neighborFinset v)) (hy : y ∉ insert v (G.neighborFinset v))
  (hxp : (G.neighborFinset x ∩ p).card = 1) (hxq : (G.neighborFinset x ∩ q).card = 1)
  (hyp : (G.neighborFinset y ∩ p).card = 1) (hyq : (G.neighborFinset y ∩ q).card = 1)
  (hx_other : ∀ r ∈ pairs, r ≠ p → r ≠ q → (G.neighborFinset x ∩ r).card = 0)
  (hy_other : ∀ r ∈ pairs, r ≠ p → r ≠ q → (G.neighborFinset y ∩ r).card = 0)
  (hxy_neq : x ≠ y)
  (h_twins : G.neighborFinset x = G.neighborFinset y) :
  False := by
    have h_contradiction : x ∉ insert v (G.neighborFinset v) → y ∉ insert v (G.neighborFinset v) → (G.neighborFinset x ∩ (Finset.univ \ insert v (G.neighborFinset v))).card = 0 := by
      have h_contradiction : Disjoint (G.neighborFinset x ∩ (Finset.univ \ insert v (G.neighborFinset v))) (G.neighborFinset y ∩ (Finset.univ \ insert v (G.neighborFinset v))) := by
        apply srg_99_14_1_2_same_pair_implies_disjoint_in_X2 hG v pairs hpairs_partition p q hp hq hpq x y hx hy hxp hxq hyp hyq hx_other hy_other hxy_neq;
        rw [h_twins];
      simp_all +decide [ Finset.disjoint_iff_inter_eq_empty ];
    have h_card : (G.neighborFinset x ∩ (Finset.univ \ insert v (G.neighborFinset v))).card + (G.neighborFinset x ∩ insert v (G.neighborFinset v)).card = 14 := by
      rw [ ← Finset.card_union_of_disjoint ];
      · rw [ show G.neighborFinset x ∩ ( Finset.univ \ Insert.insert v ( G.neighborFinset v ) ) ∪ G.neighborFinset x ∩ Insert.insert v ( G.neighborFinset v ) = G.neighborFinset x from ?_ ];
        · exact hG.regular x;
        · ext w; by_cases hw : w ∈ Insert.insert v ( G.neighborFinset v ) <;> simp +decide [ hw ] ;
      · exact Finset.disjoint_left.mpr fun z hz₁ hz₂ => Finset.mem_sdiff.mp ( Finset.mem_inter.mp hz₁ |>.2 ) |>.2 ( Finset.mem_inter.mp hz₂ |>.2 );
    have h_card_insert : (G.neighborFinset x ∩ insert v (G.neighborFinset v)).card = (G.neighborFinset x ∩ G.neighborFinset v).card := by
      rw [ Finset.inter_comm ];
      congr 1 with w ; simp +decide [ SimpleGraph.adj_comm ];
      by_cases hw : w = v <;> simp +decide [ hw, SimpleGraph.adj_comm ];
      · exact fun h => hx <| Finset.mem_insert_of_mem <| by simpa [ SimpleGraph.adj_comm ] using h;
      · grind;
    have h_card_union : (G.neighborFinset x ∩ G.neighborFinset v).card = (G.neighborFinset x ∩ p).card + (G.neighborFinset x ∩ q).card + ∑ r ∈ pairs \ {p, q}, (G.neighborFinset x ∩ r).card := by
      have h_card_union : (G.neighborFinset x ∩ G.neighborFinset v).card = ∑ r ∈ pairs, (G.neighborFinset x ∩ r).card := by
        rw [ hpairs_partition.2.2.2.2, Finset.inter_biUnion ];
        rw [ Finset.card_biUnion ];
        · rfl;
        · exact fun p hp q hq hpq => Disjoint.mono inf_le_right inf_le_right ( hpairs_partition.2.2.2.1 p hp q hq hpq );
      rw [ h_card_union, ← Finset.sum_sdiff ( Finset.insert_subset hp ( Finset.singleton_subset_iff.mpr hq ) ) ];
      rw [ Finset.sum_pair hpq, add_comm ];
    rw [ Finset.sum_eq_zero ] at h_card_union <;> aesop

#check SimpleGraph.IsSRGWith

/-
In an SRG(99,14,1,2), the neighborhood of any vertex can be partitioned into 7 disjoint edges.
-/
lemma srg_99_14_1_2_X1_partition {V : Type} [Fintype V] {G : SimpleGraph V}
  (hG : G.IsSRGWith 99 14 1 2) (v : V) :
  ∃ pairs : Finset (Finset V),
    pairs.card = 7 ∧ (∀ p ∈ pairs, p.card = 2) ∧ (∀ p ∈ pairs, p ⊆ G.neighborFinset v) ∧
    (∀ p ∈ pairs, ∀ q ∈ pairs, p ≠ q → Disjoint p q) ∧
    (G.neighborFinset v = pairs.biUnion id) := by
      have h_pairs_partition : (G.neighborFinset v).card = 14 := by
        exact hG.regular v;
      have h_pairs_partition : ∀ (S : Finset V), S.card = 14 → ∃ pairs : Finset (Finset V), pairs.card = 7 ∧ (∀ p ∈ pairs, p.card = 2) ∧ (∀ p ∈ pairs, p ⊆ S) ∧ (∀ p ∈ pairs, ∀ q ∈ pairs, p ≠ q → Disjoint p q) ∧ S = pairs.biUnion id := by
        intro S hS_card
        obtain ⟨pairs, hpairs⟩ : ∃ pairs : Finset (Finset V), pairs.card = 7 ∧ (∀ p ∈ pairs, p.card = 2) ∧ (∀ p ∈ pairs, p ⊆ S) ∧ (∀ p ∈ pairs, ∀ q ∈ pairs, p ≠ q → Disjoint p q) ∧ S = pairs.biUnion id := by
          have h_partition : ∃ f : Fin 14 → V, Function.Injective f ∧ S = Finset.image f Finset.univ := by
            have h_partition : Nonempty (Fin 14 ≃ S) := by
              exact ⟨ Fintype.equivOfCardEq <| by simp +decide [ hS_card ] ⟩;
            obtain ⟨ f ⟩ := h_partition;
            use fun i => f i |>.1;
            exact ⟨ Subtype.coe_injective.comp f.injective, by ext x; exact ⟨ fun hx => Finset.mem_image.mpr ⟨ f.symm ⟨ x, hx ⟩, Finset.mem_univ _, by simp +decide ⟩, fun hx => by obtain ⟨ i, _, hi ⟩ := Finset.mem_image.mp hx; aesop ⟩ ⟩
          obtain ⟨ f, hf_inj, hf_image ⟩ := h_partition;
          use { { f 0, f 1 }, { f 2, f 3 }, { f 4, f 5 }, { f 6, f 7 }, { f 8, f 9 }, { f 10, f 11 }, { f 12, f 13 } };
          simp +decide [ Finset.subset_iff, hf_image ];
          simp +decide [ Finset.Subset.antisymm_iff, Finset.subset_iff, hf_inj.eq_iff ];
        use pairs;
      exact h_pairs_partition _ ‹_›

/-
In an SRG with λ=1, if two neighbors of v are adjacent, then v is their unique common neighbor.
-/
lemma srg_lambda_1_edge_in_neighborhood_common_neighbors {V : Type} [Fintype V] {G : SimpleGraph V} {n k m : ℕ}
  (hG : G.IsSRGWith n k 1 m) (v : V) (a b : V)
  (ha : a ∈ G.neighborFinset v) (hb : b ∈ G.neighborFinset v) (hab : G.Adj a b) :
  G.commonNeighbors a b = {v} := by
    -- Since $a$ and $b$ are adjacent, they have exactly one common neighbor by the definition of an SRG with $\lambda = 1$.
    have h_common_neighbor_count : (G.commonNeighbors a b).ncard = 1 := by
      convert hG.3 a b hab using 1;
      rw [ Set.ncard_eq_toFinset_card' ] ; aesop;
    simp_all +decide [ Set.eq_singleton_iff_unique_mem ];
    simp_all +decide [ SimpleGraph.commonNeighbors ];
    exact ⟨ ⟨ ha.symm, hb.symm ⟩, fun x hx₁ hx₂ => h_common_neighbor_count.choose_spec.2 x hx₁ hx₂ ▸ h_common_neighbor_count.choose_spec.2 v ha.symm hb.symm ▸ rfl ⟩

/-
In SRG(99,14,1,2), the neighborhood of any vertex can be partitioned into 7 disjoint edges.
-/
lemma srg_99_14_1_2_X1_edge_partition {V : Type} [Fintype V] {G : SimpleGraph V}
  (hG : G.IsSRGWith 99 14 1 2) (v : V) :
  ∃ pairs : Finset (Finset V),
    pairs.card = 7 ∧ (∀ p ∈ pairs, p.card = 2) ∧ (∀ p ∈ pairs, p ⊆ G.neighborFinset v) ∧
    (∀ p ∈ pairs, ∀ q ∈ pairs, p ≠ q → Disjoint p q) ∧
    (G.neighborFinset v = pairs.biUnion id) ∧
    (∀ p ∈ pairs, ∀ a ∈ p, ∀ b ∈ p, a ≠ b → G.Adj a b) := by
      have := @srg_lambda_1_implies_neighbor_matching V _ G 99 14 2 hG v;
      have h_partition : ∀ w ∈ G.neighborFinset v, ∃ w' ∈ G.neighborFinset v, w' ≠ w ∧ G.Adj w w' ∧ ∀ x ∈ G.neighborFinset v, x ≠ w → x ≠ w' → ¬G.Adj w x := by
        intro w hw
        obtain ⟨w', hw'⟩ : ∃ w' ∈ G.neighborFinset v, w' ≠ w ∧ G.Adj w w' := by
          have := this.2 w hw; obtain ⟨ x, hx ⟩ := Finset.card_pos.mp ( by linarith ) ; use x; aesop;
        use w';
        have := this.2 w hw; simp_all +decide [ Finset.card_eq_one ] ;
        intro x hx hx' hx''; specialize this; have := this.2 w hw; simp_all +decide [ Finset.eq_singleton_iff_unique_mem ] ;
        grind;
      choose! f hf₁ hf₂ hf₃ hf₄ using h_partition;
      have h_partition : ∀ w ∈ G.neighborFinset v, f (f w) = w := by
        intros w hw
        have h_adj : G.Adj w (f w) ∧ G.Adj (f w) (f (f w)) := by
          exact ⟨ hf₃ w hw, hf₃ ( f w ) ( hf₁ w hw ) ⟩;
        have := hf₄ ( f w ) ( hf₁ w hw ) w hw; simp_all +decide [ SimpleGraph.adj_comm ] ;
        grind;
      have h_partition : Finset.card (Finset.image (fun w => {w, f w} : V → Finset V) (G.neighborFinset v)) = 7 := by
        have h_partition : Finset.card (Finset.image (fun w => {w, f w} : V → Finset V) (G.neighborFinset v)) * 2 = Finset.card (G.neighborFinset v) := by
          have h_partition : ∀ s ∈ Finset.image (fun w => {w, f w} : V → Finset V) (G.neighborFinset v), Finset.card (Finset.filter (fun w => {w, f w} = s) (G.neighborFinset v)) = 2 := by
            intros s hs
            obtain ⟨w, hw⟩ : ∃ w ∈ G.neighborFinset v, {w, f w} = s := by
              aesop;
            have h_filter : Finset.filter (fun x => {x, f x} = s) (G.neighborFinset v) = {w, f w} := by
              grind;
            rw [ h_filter, Finset.card_pair ( Ne.symm ( hf₂ w hw.1 ) ) ];
          have h_partition : Finset.card (G.neighborFinset v) = Finset.sum (Finset.image (fun w => {w, f w} : V → Finset V) (G.neighborFinset v)) (fun s => Finset.card (Finset.filter (fun w => {w, f w} = s) (G.neighborFinset v))) := by
            exact?;
          rw [ h_partition, Finset.sum_congr rfl ‹_›, Finset.sum_const, smul_eq_mul, mul_comm ];
        linarith;
      refine' ⟨ _, h_partition, _, _, _, _, _ ⟩;
      · simp +zetaDelta at *;
        exact fun w hw => Finset.card_pair ( Ne.symm ( hf₂ w hw ) );
      · aesop_cat;
      · simp +zetaDelta at *;
        grind +ring;
      · ext w; aesop;
      · simp +zetaDelta at *;
        exact fun w hw => ⟨ fun _ => hf₃ w hw, fun _ => by simpa only [ SimpleGraph.adj_comm ] using hf₃ w hw ⟩

/-
In SRG(99,14,1,2), a vertex in X2 cannot be adjacent to both endpoints of an edge in X1.
-/
lemma srg_99_14_1_2_X2_intersection_le_1 {V : Type} [Fintype V] {G : SimpleGraph V}
  (hG : G.IsSRGWith 99 14 1 2) (v : V)
  (pairs : Finset (Finset V))
  (hpairs_partition : pairs.card = 7 ∧ (∀ p ∈ pairs, p.card = 2) ∧ (∀ p ∈ pairs, p ⊆ G.neighborFinset v) ∧
                      (∀ p ∈ pairs, ∀ q ∈ pairs, p ≠ q → Disjoint p q) ∧
                      (G.neighborFinset v = pairs.biUnion id))
  (hpairs_adj : ∀ p ∈ pairs, ∀ a ∈ p, ∀ b ∈ p, a ≠ b → G.Adj a b)
  (x : V) (hx : x ∉ insert v (G.neighborFinset v))
  (p : Finset V) (hp : p ∈ pairs) :
  (G.neighborFinset x ∩ p).card ≤ 1 := by
    by_contra h_contra;
    -- Since $|N(x) \cap p| > 1$, there exist $a, b \in p$ such that $a \neq b$ and $a, b \in N(x)$.
    obtain ⟨a, b, ha, hb, hab⟩ : ∃ a b : V, a ∈ p ∧ b ∈ p ∧ a ≠ b ∧ a ∈ G.neighborFinset x ∧ b ∈ G.neighborFinset x := by
      obtain ⟨ a, ha, b, hb, hab ⟩ := Finset.one_lt_card.mp ( not_le.mp h_contra ) ; use a, b; aesop;
    -- Since $a$ and $b$ are adjacent and both are neighbors of $x$, by `srg_lambda_1_neighbors_of_nonadj_are_nonadj`, $x$ must be adjacent to $v$.
    have hx_adj_v : G.Adj x v := by
      have := srg_lambda_1_neighbors_of_nonadj_are_nonadj hG v x; simp_all +decide [ SimpleGraph.adj_comm ] ;
      grind;
    exact hx <| Finset.mem_insert_of_mem <| by simpa [ SimpleGraph.adj_comm ] using hx_adj_v;

/-
In SRG(99,14,1,2), every vertex in X2 (non-neighbors of v) has exactly two neighbors in X1 (neighbors of v), and these two neighbors belong to distinct edges in the partition of X1.
-/
lemma srg_99_14_1_2_X2_structure {V : Type} [Fintype V] {G : SimpleGraph V}
  (hG : G.IsSRGWith 99 14 1 2) (v : V)
  (pairs : Finset (Finset V))
  (hpairs_partition : pairs.card = 7 ∧ (∀ p ∈ pairs, p.card = 2) ∧ (∀ p ∈ pairs, p ⊆ G.neighborFinset v) ∧
                      (∀ p ∈ pairs, ∀ q ∈ pairs, p ≠ q → Disjoint p q) ∧
                      (G.neighborFinset v = pairs.biUnion id))
  (hpairs_adj : ∀ p ∈ pairs, ∀ a ∈ p, ∀ b ∈ p, a ≠ b → G.Adj a b)
  (x : V) (hx : x ∉ insert v (G.neighborFinset v)) :
  ∃ p q : Finset V, p ∈ pairs ∧ q ∈ pairs ∧ p ≠ q ∧
    (G.neighborFinset x ∩ p).card = 1 ∧
    (G.neighborFinset x ∩ q).card = 1 ∧
    ∀ r ∈ pairs, r ≠ p → r ≠ q → (G.neighborFinset x ∩ r).card = 0 := by
      have h_two_neighbors : (Finset.biUnion pairs (fun p => G.neighborFinset x ∩ p)).card = 2 := by
        have h_two_neighbors : (G.neighborFinset x ∩ G.neighborFinset v).card = 2 := by
          -- Since x is not adjacent to v and x is not v, we can apply the definition of a strongly regular graph with λ=1.
          have h_common_neighbors : ∀ x v : V, x ≠ v → ¬G.Adj x v → (G.neighborFinset x ∩ G.neighborFinset v).card = 2 := by
            intros x v hxv h_not_adj;
            have := hG;
            convert this.of_not_adj hxv h_not_adj;
            rw [ Fintype.card_of_subtype ] ; aesop;
          simp +zetaDelta at *;
          exact h_common_neighbors x v hx.1 ( by simpa only [ SimpleGraph.adj_comm ] using hx.2 );
        convert h_two_neighbors using 2 ; ext ; aesop;
      have h_two_neighbors : ∀ p ∈ pairs, (G.neighborFinset x ∩ p).card ≤ 1 := by
        exact?;
      have h_two_neighbors : (Finset.filter (fun p => (G.neighborFinset x ∩ p).card = 1) pairs).card = 2 := by
        have h_two_neighbors : (Finset.biUnion pairs (fun p => G.neighborFinset x ∩ p)).card = Finset.sum pairs (fun p => (G.neighborFinset x ∩ p).card) := by
          rw [ Finset.card_biUnion ];
          exact fun p hp q hq hpq => Disjoint.mono inf_le_right inf_le_right ( hpairs_partition.2.2.2.1 p hp q hq hpq );
        rw [ Finset.sum_congr rfl fun p hp => show ( G.neighborFinset x ∩ p ).card = if ( G.neighborFinset x ∩ p ).card = 1 then 1 else 0 from by specialize ‹∀ p ∈ pairs, ( G.neighborFinset x ∩ p ).card ≤ 1› p hp; interval_cases ( G.neighborFinset x ∩ p ).card <;> trivial ] at h_two_neighbors ; aesop;
      obtain ⟨ p, hp, q, hq, hpq ⟩ := Finset.one_lt_card.mp ( by linarith );
      simp +zetaDelta at *;
      refine' ⟨ p, hp.1, q, hq.1, hpq, hp.2, hq.2, fun r hr hrp hrq => _ ⟩;
      have := ‹∀ p ∈ pairs, ( G.neighborFinset x ∩ p ).card ≤ 1› r hr; interval_cases _ : ( G.neighborFinset x ∩ r ).card <;> simp_all +decide ;
      exact absurd h_two_neighbors ( by exact ne_of_gt ( Finset.two_lt_card.mpr ⟨ p, by aesop, q, by aesop, r, by aesop ⟩ ) )

/-
In SRG(99,14,1,2), two vertices from different edges in X1 have no common neighbors in X1.
-/
lemma srg_99_14_1_2_no_common_neighbor_in_X1 {V : Type} [Fintype V] {G : SimpleGraph V}
  (hG : G.IsSRGWith 99 14 1 2) (v : V)
  (pairs : Finset (Finset V))
  (hpairs_partition : pairs.card = 7 ∧ (∀ p ∈ pairs, p.card = 2) ∧ (∀ p ∈ pairs, p ⊆ G.neighborFinset v) ∧
                      (∀ p ∈ pairs, ∀ q ∈ pairs, p ≠ q → Disjoint p q) ∧
                      (G.neighborFinset v = pairs.biUnion id))
  (hpairs_adj : ∀ p ∈ pairs, ∀ a ∈ p, ∀ b ∈ p, a ≠ b → G.Adj a b)
  (p q : Finset V) (hp : p ∈ pairs) (hq : q ∈ pairs) (hpq : p ≠ q)
  (u : V) (hu : u ∈ p) (w : V) (hw : w ∈ q) :
  G.neighborFinset u ∩ G.neighborFinset w ∩ G.neighborFinset v = ∅ := by
    -- By definition of neighborhood, if $z \in G.neighborFinset u \cap G.neighborFinset w \cap G.neighborFinset v$, then $z$ must be a common neighbor of $u$ and $w$ that is also a neighbor of $v$.
    apply srg_lambda_1_no_common_neighbor_in_neighborhood hG v u w (by
    exact hpairs_partition.2.2.1 p hp hu) (by
    grind) (by
    exact fun h => Finset.disjoint_left.mp ( hpairs_partition.2.2.2.1 p hp q hq hpq ) hu ( h.symm ▸ hw ))

/-
In SRG(99,14,1,2), vertices in different edges of the neighborhood partition are non-adjacent.
-/
lemma srg_99_14_1_2_X1_edges_disjoint_adj {V : Type} [Fintype V] {G : SimpleGraph V}
  (hG : G.IsSRGWith 99 14 1 2) (v : V)
  (pairs : Finset (Finset V))
  (hpairs_partition : pairs.card = 7 ∧ (∀ p ∈ pairs, p.card = 2) ∧ (∀ p ∈ pairs, p ⊆ G.neighborFinset v) ∧
                      (∀ p ∈ pairs, ∀ q ∈ pairs, p ≠ q → Disjoint p q) ∧
                      (G.neighborFinset v = pairs.biUnion id))
  (hpairs_adj : ∀ p ∈ pairs, ∀ a ∈ p, ∀ b ∈ p, a ≠ b → G.Adj a b)
  (p q : Finset V) (hp : p ∈ pairs) (hq : q ∈ pairs) (hpq : p ≠ q)
  (u : V) (hu : u ∈ p) (w : V) (hw : w ∈ q) :
  ¬ G.Adj u w := by
    have h_induced : ∀ x ∈ G.neighborFinset v, (G.neighborFinset x ∩ G.neighborFinset v).card = 1 := by
      have := srg_lambda_1_implies_neighbor_matching hG;
      exact this v |>.2;
    contrapose! h_induced;
    refine' ⟨ u, _, _ ⟩ <;> simp_all +decide [ Finset.subset_iff ];
    · exact ⟨ p, hp, hu ⟩;
    · refine' ne_of_gt ( Finset.one_lt_card.mpr _ );
      refine' ⟨ w, _, _ ⟩ <;> simp_all +decide [ Finset.disjoint_left ];
      · exact ⟨ q, hq, hw ⟩;
      · -- Since $u$ and $w$ are adjacent, and $u$ is in $p$, and $p$ is part of the partition, there must be another vertex in $p$ that is adjacent to $u$.
        obtain ⟨b, hb⟩ : ∃ b ∈ p, b ≠ u := by
          exact Finset.exists_mem_ne ( by linarith [ hpairs_partition.2.1 p hp ] ) u;
        grind

/-
In SRG(99,14,1,2), any two vertices from distinct edges in X1 have exactly one common neighbor in X2.
-/
lemma srg_99_14_1_2_unique_common_neighbor_in_X2 {V : Type} [Fintype V] {G : SimpleGraph V}
  (hG : G.IsSRGWith 99 14 1 2) (v : V)
  (pairs : Finset (Finset V))
  (hpairs_partition : pairs.card = 7 ∧ (∀ p ∈ pairs, p.card = 2) ∧ (∀ p ∈ pairs, p ⊆ G.neighborFinset v) ∧
                      (∀ p ∈ pairs, ∀ q ∈ pairs, p ≠ q → Disjoint p q) ∧
                      (G.neighborFinset v = pairs.biUnion id))
  (hpairs_adj : ∀ p ∈ pairs, ∀ a ∈ p, ∀ b ∈ p, a ≠ b → G.Adj a b)
  (p q : Finset V) (hp : p ∈ pairs) (hq : q ∈ pairs) (hpq : p ≠ q)
  (u : V) (hu : u ∈ p) (w : V) (hw : w ∈ q) :
  ∃! z, z ∈ G.neighborFinset u ∩ G.neighborFinset w ∩ (Finset.univ \ insert v (G.neighborFinset v)) := by
    -- By `srg_99_14_1_2_X1_edges_disjoint_adj`, u and w are non-adjacent.
    have h_non_adj : ¬ G.Adj u w := by
      apply srg_99_14_1_2_X1_edges_disjoint_adj hG v pairs hpairs_partition hpairs_adj p q hp hq hpq u hu w hw;
    -- By `srg_99_14_1_2_no_common_neighbor_in_X1`, u and w have no common neighbors in N(v).
    have h_no_common_neighbor_in_X1 : G.neighborFinset u ∩ G.neighborFinset w ∩ G.neighborFinset v = ∅ := by
      apply srg_99_14_1_2_no_common_neighbor_in_X1 hG v pairs hpairs_partition hpairs_adj p q hp hq hpq u hu w hw;
    -- By `h_common_neighbors`, u and w have exactly two common neighbors.
    have h_common_neighbors_count : (G.commonNeighbors u w).ncard = 2 := by
      have := hG.3;
      have := hG.4;
      simpa [ Set.ncard_eq_toFinset_card' ] using this ( show u ≠ w from by rintro rfl; exact h_non_adj <| by have := hpairs_partition.2.2.2.1 p hp q hq hpq; simp_all +decide [ Finset.disjoint_left ] ) h_non_adj;
    -- By `h_common_neighbors`, u and w have exactly two common neighbors, one of which is v.
    have h_common_neighbors_v : v ∈ G.commonNeighbors u w := by
      exact ⟨ by simpa [ SimpleGraph.adj_comm ] using hpairs_partition.2.2.1 p hp hu, by simpa [ SimpleGraph.adj_comm ] using hpairs_partition.2.2.1 q hq hw ⟩;
    -- By `h_common_neighbors`, u and w have exactly two common neighbors, one of which is v, and the other is in X2.
    obtain ⟨z, hz⟩ : ∃ z, z ∈ G.commonNeighbors u w ∧ z ≠ v ∧ z ∉ G.neighborFinset v := by
      obtain ⟨ z, hz ⟩ := Set.exists_ne_of_one_lt_ncard ( by linarith ) v;
      simp_all +decide [ Finset.ext_iff, Set.ext_iff ];
      exact ⟨ z, hz.1, hz.2, fun x hx => h_no_common_neighbor_in_X1 z ( by simpa using hz.1.1 ) ( by simpa using hz.1.2 ) x hx ⟩;
    refine' ⟨ z, _, _ ⟩ <;> simp_all +decide [ Set.ext_iff ];
    · exact ⟨ hz.1.1, hz.1.2 ⟩;
    · intro y hyu hyw hyv hy; rw [ Set.ncard_eq_two ] at h_common_neighbors_count; obtain ⟨ a, b, hab ⟩ := h_common_neighbors_count; simp_all +decide [ Set.Subset.antisymm_iff, Set.subset_def ] ;
      cases hab.2.1 y ⟨ hyu, hyw ⟩ <;> aesop

/-
The set of vertices in X2 that have exactly one neighbor in p and exactly one neighbor in q.
-/
def X2_sub {V : Type} [Fintype V] (G : SimpleGraph V) (v : V) (p q : Finset V) : Finset V :=
  (Finset.univ \ insert v (G.neighborFinset v)).filter (fun x => (G.neighborFinset x ∩ p).card = 1 ∧ (G.neighborFinset x ∩ q).card = 1)

/-
In SRG(99,14,1,2), the unique common neighbor in X2 of two vertices from different edges in X1 belongs to the corresponding X2 subset.
-/
lemma srg_99_14_1_2_common_neighbor_in_X2_sub {V : Type} [Fintype V] {G : SimpleGraph V}
  (hG : G.IsSRGWith 99 14 1 2) (v : V)
  (pairs : Finset (Finset V))
  (hpairs_partition : pairs.card = 7 ∧ (∀ p ∈ pairs, p.card = 2) ∧ (∀ p ∈ pairs, p ⊆ G.neighborFinset v) ∧
                      (∀ p ∈ pairs, ∀ q ∈ pairs, p ≠ q → Disjoint p q) ∧
                      (G.neighborFinset v = pairs.biUnion id))
  (hpairs_adj : ∀ p ∈ pairs, ∀ a ∈ p, ∀ b ∈ p, a ≠ b → G.Adj a b)
  (p q : Finset V) (hp : p ∈ pairs) (hq : q ∈ pairs) (hpq : p ≠ q)
  (u : V) (hu : u ∈ p) (w : V) (hw : w ∈ q)
  (z : V) (hz : z ∈ G.neighborFinset u ∩ G.neighborFinset w ∩ (Finset.univ \ insert v (G.neighborFinset v))) :
  z ∈ X2_sub G v p q := by
    unfold X2_sub;
    have := srg_99_14_1_2_X2_structure hG v pairs hpairs_partition hpairs_adj z (by
    aesop);
    obtain ⟨ p', q', hp', hq', hpq', hp', hq', h ⟩ := this;
    have hp'' : p = p' ∨ p = q' := by
      contrapose! hp';
      have := h p hp hp'.1 hp'.2; simp_all +decide [ Finset.ext_iff ] ;
      exact False.elim <| this _ hz.1.symm hu
    have hq'' : q = p' ∨ q = q' := by
      contrapose! h;
      use q;
      simp_all +decide [ Finset.ext_iff ];
      exact ⟨ w, hz.2.1.symm, hw ⟩;
    grind

/-
In SRG(99,14,1,2), for any two distinct edges p, q in the neighborhood partition, the set of vertices in X2 connected to both p and q has size 4.
-/
lemma srg_99_14_1_2_X2_sub_card {V : Type} [Fintype V] {G : SimpleGraph V}
  (hG : G.IsSRGWith 99 14 1 2) (v : V)
  (pairs : Finset (Finset V))
  (hpairs_partition : pairs.card = 7 ∧ (∀ p ∈ pairs, p.card = 2) ∧ (∀ p ∈ pairs, p ⊆ G.neighborFinset v) ∧
                      (∀ p ∈ pairs, ∀ q ∈ pairs, p ≠ q → Disjoint p q) ∧
                      (G.neighborFinset v = pairs.biUnion id))
  (hpairs_adj : ∀ p ∈ pairs, ∀ a ∈ p, ∀ b ∈ p, a ≠ b → G.Adj a b)
  (p q : Finset V) (hp : p ∈ pairs) (hq : q ∈ pairs) (hpq : p ≠ q) :
  (X2_sub G v p q).card = 4 := by
    have h_card : ∀ u ∈ p, ∀ w ∈ q, ∃! z, z ∈ G.neighborFinset u ∩ G.neighborFinset w ∩ (Finset.univ \ insert v (G.neighborFinset v)) := by
      intros u hu w hw; exact srg_99_14_1_2_unique_common_neighbor_in_X2 hG v pairs hpairs_partition hpairs_adj p q hp hq hpq u hu w hw;
    choose! f hf₁ hf₂ using h_card;
    have h_inj : ∀ u ∈ p, ∀ w ∈ q, ∀ u' ∈ p, ∀ w' ∈ q, f u w = f u' w' → u = u' ∧ w = w' := by
      intros u hu w hw u' hu' w' hw' h_eq
      have h_adj : G.Adj u (f u w) ∧ G.Adj w (f u w) ∧ G.Adj u' (f u w) ∧ G.Adj w' (f u w) := by
        simp +zetaDelta at *;
        grind;
      have h_unique : ∀ x ∈ p, ∀ y ∈ p, x ≠ y → ¬G.Adj x (f u w) ∨ ¬G.Adj y (f u w) := by
        intros x hx y hy hxy
        have h_unique : ∀ x ∈ p, ∀ y ∈ p, x ≠ y → ¬G.Adj x (f u w) ∨ ¬G.Adj y (f u w) := by
          intro x hx y hy hxy
          have h_common_neighbors : G.commonNeighbors x y = {v} := by
            apply srg_lambda_1_edge_in_neighborhood_common_neighbors hG v x y;
            · exact hpairs_partition.2.2.1 p hp hx;
            · exact hpairs_partition.2.2.1 p hp hy;
            · exact hpairs_adj p hp x hx y hy hxy
          contrapose! hxy; simp_all +decide [ Set.Subset.antisymm_iff, Set.subset_def ] ;
          have := h_common_neighbors.1 ( f u' w' ) ; simp_all +decide [ SimpleGraph.commonNeighbors ] ;
        exact h_unique x hx y hy hxy;
      have h_unique_q : ∀ x ∈ q, ∀ y ∈ q, x ≠ y → ¬G.Adj x (f u w) ∨ ¬G.Adj y (f u w) := by
        intros x hx y hy hxy
        by_contra h_contra
        push_neg at h_contra;
        have h_common_neighbors : G.commonNeighbors x y = {v} := by
          apply srg_lambda_1_edge_in_neighborhood_common_neighbors;
          exact hG;
          · exact hpairs_partition.2.2.1 q hq hx;
          · exact hpairs_partition.2.2.1 q hq hy;
          · exact hpairs_adj q hq x hx y hy hxy;
        simp_all +decide [ SimpleGraph.commonNeighbors ];
        replace h_common_neighbors := Set.ext_iff.mp h_common_neighbors ( f u' w' ) ; simp_all +decide [ SimpleGraph.adj_comm ] ;
      grind;
    have h_surj : ∀ z ∈ X2_sub G v p q, ∃ u ∈ p, ∃ w ∈ q, z = f u w := by
      intros z hz
      obtain ⟨u, hu⟩ : ∃ u ∈ p, u ∈ G.neighborFinset z := by
        have := Finset.card_pos.mp ( show 0 < ( G.neighborFinset z ∩ p |> Finset.card ) from by linarith [ Finset.mem_filter.mp hz ] ) ; obtain ⟨ u, hu ⟩ := this; use u; aesop;
      obtain ⟨w, hw⟩ : ∃ w ∈ q, w ∈ G.neighborFinset z := by
        have := Finset.card_pos.mp ( show 0 < ( G.neighborFinset z ∩ q ).card from ?_ );
        · exact ⟨ this.choose, Finset.mem_of_mem_inter_right this.choose_spec, Finset.mem_of_mem_inter_left this.choose_spec ⟩;
        · exact Nat.pos_of_ne_zero ( by rw [ X2_sub ] at hz; aesop )
      use u, hu.left, w, hw.left;
      apply hf₂ u hu.left w hw.left z;
      simp +zetaDelta at *;
      exact ⟨ hu.2.symm, hw.2.symm, by rintro rfl; exact absurd hz ( by simp +decide [ X2_sub ] ), by rintro h; exact absurd hz ( by simp +decide [ X2_sub, h ] ) ⟩;
    have h_card : (X2_sub G v p q).card = Finset.card (Finset.image (fun (uw : V × V) => f uw.1 uw.2) (p ×ˢ q)) := by
      congr with z ; simp +contextual [ h_surj ];
      apply Iff.intro;
      · exact fun hz => by obtain ⟨ u, hu, w, hw, rfl ⟩ := h_surj z hz; exact ⟨ u, w, ⟨ hu, hw ⟩, rfl ⟩ ;
      · rintro ⟨ u, w, ⟨ hu, hw ⟩, rfl ⟩;
        apply srg_99_14_1_2_common_neighbor_in_X2_sub;
        all_goals tauto;
    rw [ h_card, Finset.card_image_of_injOn ];
    · norm_num [ hpairs_partition.2.1 p hp, hpairs_partition.2.1 q hq ];
    · exact fun x hx y hy hxy => Prod.ext ( h_inj _ ( Finset.mem_product.mp hx |>.1 ) _ ( Finset.mem_product.mp hx |>.2 ) _ ( Finset.mem_product.mp hy |>.1 ) _ ( Finset.mem_product.mp hy |>.2 ) hxy |>.1 ) ( h_inj _ ( Finset.mem_product.mp hx |>.1 ) _ ( Finset.mem_product.mp hx |>.2 ) _ ( Finset.mem_product.mp hy |>.1 ) _ ( Finset.mem_product.mp hy |>.2 ) hxy |>.2 )

#check srg_99_14_1_2_same_pair_implies_disjoint_in_X2

/-
The set of neighbors of a in X2.
-/
def S_a {V : Type} [Fintype V] (G : SimpleGraph V) (v a : V) : Finset V :=
  G.neighborFinset a ∩ (Finset.univ \ insert v (G.neighborFinset v))

/-
Elements of X2_sub satisfy the conditions: they are in X2, connect to p and q with 1 edge, and to no other pairs in the partition.
-/
lemma srg_99_14_1_2_X2_sub_prop {V : Type} [Fintype V] {G : SimpleGraph V}
  (hG : G.IsSRGWith 99 14 1 2) (v : V)
  (pairs : Finset (Finset V))
  (hpairs_partition : pairs.card = 7 ∧ (∀ p ∈ pairs, p.card = 2) ∧ (∀ p ∈ pairs, p ⊆ G.neighborFinset v) ∧
                      (∀ p ∈ pairs, ∀ q ∈ pairs, p ≠ q → Disjoint p q) ∧
                      (G.neighborFinset v = pairs.biUnion id))
  (p q : Finset V) (hp : p ∈ pairs) (hq : q ∈ pairs) (hpq : p ≠ q)
  (x : V) (hx : x ∈ X2_sub G v p q) :
  x ∉ insert v (G.neighborFinset v) ∧
  (G.neighborFinset x ∩ p).card = 1 ∧
  (G.neighborFinset x ∩ q).card = 1 ∧
  (∀ r ∈ pairs, r ≠ p → r ≠ q → (G.neighborFinset x ∩ r).card = 0) := by
    have h_card : (G.neighborFinset x ∩ G.neighborFinset v).card = 2 := by
      -- Since $x$ is in $X2$, it is not adjacent to $v$, so $x$ must have exactly $\mu = 2$ neighbors in $X1$.
      have h_card_x1 : (G.neighborFinset x ∩ G.neighborFinset v).card = 2 := by
        have h_mu : ∀ x : V, x ∉ insert v (G.neighborFinset v) → (G.neighborFinset x ∩ G.neighborFinset v).card = 2 := by
          intros x hx_not_adj
          have h_mu : (G.neighborFinset x ∩ G.neighborFinset v).card = 2 := by
            have h_mu_def : ∀ u w : V, u ≠ w → ¬G.Adj u w → (G.neighborFinset u ∩ G.neighborFinset w).card = 2 := by
              intros u w hu hw; exact (by
              have := hG;
              obtain ⟨ h₁, h₂, h₃ ⟩ := this;
              convert ‹Pairwise fun v w => ¬G.Adj v w → Fintype.card ↑ ( G.commonNeighbors v w ) = 2› hu hw using 1;
              rw [ Fintype.card_of_subtype ] ; aesop)
            norm_num +zetaDelta at *;
            simpa only [ SimpleGraph.adj_comm, Finset.inter_comm ] using h_mu_def x v hx_not_adj.1 ( by simpa only [ SimpleGraph.adj_comm ] using hx_not_adj.2 );
          exact h_mu
        exact h_mu x (by
        unfold X2_sub at hx; aesop;);
      exact h_card_x1;
    have h_card : ∑ r ∈ pairs, (G.neighborFinset x ∩ r).card = 2 := by
      rw [ ← h_card, hpairs_partition.2.2.2.2, Finset.inter_biUnion ];
      rw [ Finset.card_biUnion ] ; aesop;
      exact fun p hp q hq hpq => Disjoint.mono inf_le_right inf_le_right ( hpairs_partition.2.2.2.1 p hp q hq hpq );
    have h_card : (G.neighborFinset x ∩ p).card = 1 ∧ (G.neighborFinset x ∩ q).card = 1 := by
      unfold X2_sub at hx; aesop;
    have h_card : ∑ r ∈ pairs \ {p, q}, (G.neighborFinset x ∩ r).card = 0 := by
      rw [ ← Finset.sum_sdiff ( Finset.insert_subset hp ( Finset.singleton_subset_iff.mpr hq ) ) ] at * ; aesop;
    unfold X2_sub at hx; aesop;

/-
Vertices in X2_sub p q are uniquely determined by their neighbors in p and q.
-/
lemma srg_99_14_1_2_X2_sub_injective {V : Type} [Fintype V] {G : SimpleGraph V}
  (hG : G.IsSRGWith 99 14 1 2) (v : V)
  (pairs : Finset (Finset V))
  (hpairs_partition : pairs.card = 7 ∧ (∀ p ∈ pairs, p.card = 2) ∧ (∀ p ∈ pairs, p ⊆ G.neighborFinset v) ∧
                      (∀ p ∈ pairs, ∀ q ∈ pairs, p ≠ q → Disjoint p q) ∧
                      (G.neighborFinset v = pairs.biUnion id))
  (hpairs_adj : ∀ p ∈ pairs, ∀ a ∈ p, ∀ b ∈ p, a ≠ b → G.Adj a b)
  (p q : Finset V) (hp : p ∈ pairs) (hq : q ∈ pairs) (hpq : p ≠ q)
  (x y : V) (hx : x ∈ X2_sub G v p q) (hy : y ∈ X2_sub G v p q)
  (h_same_p : G.neighborFinset x ∩ p = G.neighborFinset y ∩ p)
  (h_same_q : G.neighborFinset x ∩ q = G.neighborFinset y ∩ q) :
  x = y := by
    have := srg_99_14_1_2_X2_sub_prop hG v pairs hpairs_partition p q hp hq hpq x hx;
    obtain ⟨u, hu⟩ : ∃ u ∈ p, u ∈ G.neighborFinset x := by
      exact Exists.elim ( Finset.card_pos.mp ( by linarith ) ) fun u hu => ⟨ u, Finset.mem_of_mem_inter_right hu, Finset.mem_of_mem_inter_left hu ⟩
    obtain ⟨w, hw⟩ : ∃ w ∈ q, w ∈ G.neighborFinset x := by
      exact Exists.elim ( Finset.card_pos.mp ( by linarith ) ) fun w hw => ⟨ w, Finset.mem_inter.mp hw |>.2, Finset.mem_inter.mp hw |>.1 ⟩
    have h_unique : ∀ z ∈ G.neighborFinset u ∩ G.neighborFinset w ∩ (Finset.univ \ insert v (G.neighborFinset v)), z = x := by
      have h_unique : ∃! z, z ∈ G.neighborFinset u ∩ G.neighborFinset w ∩ (Finset.univ \ insert v (G.neighborFinset v)) := by
        have := srg_99_14_1_2_unique_common_neighbor_in_X2 hG v pairs hpairs_partition hpairs_adj p q hp hq hpq u hu.1 w hw.1; aesop;
      simp_all +decide [ SimpleGraph.neighborFinset_def ];
      exact fun z hz₁ hz₂ hz₃ hz₄ => h_unique.unique ⟨ hz₁, hz₂, hz₃, hz₄ ⟩ ⟨ hu.2.symm, hw.2.symm, this.1.1, this.1.2 ⟩;
    have := srg_99_14_1_2_X2_sub_prop hG v pairs hpairs_partition p q hp hq hpq y hy;
    norm_num +zetaDelta at *;
    -- Since $u \in p$ and $w \in q$, and the intersections are the same, $u$ must be adjacent to $y$ and $w$ must be adjacent to $y$.
    have hu_y : u ∈ G.neighborFinset y := by
      replace h_same_p := Finset.ext_iff.mp h_same_p u; aesop;
    have hw_y : w ∈ G.neighborFinset y := by
      replace h_same_q := Finset.ext_iff.mp h_same_q w; aesop;
    exact h_unique y ( by simpa [ SimpleGraph.adj_comm ] using hu_y ) ( by simpa [ SimpleGraph.adj_comm ] using hw_y ) this.1.1 this.1.2 ▸ rfl

/-
For every pair of vertices u in p and w in q, there is a vertex z in X2_sub connected to exactly u in p and w in q.
-/
lemma srg_99_14_1_2_X2_sub_image_surj {V : Type} [Fintype V] {G : SimpleGraph V}
  (hG : G.IsSRGWith 99 14 1 2) (v : V)
  (pairs : Finset (Finset V))
  (hpairs_partition : pairs.card = 7 ∧ (∀ p ∈ pairs, p.card = 2) ∧ (∀ p ∈ pairs, p ⊆ G.neighborFinset v) ∧
                      (∀ p ∈ pairs, ∀ q ∈ pairs, p ≠ q → Disjoint p q) ∧
                      (G.neighborFinset v = pairs.biUnion id))
  (hpairs_adj : ∀ p ∈ pairs, ∀ a ∈ p, ∀ b ∈ p, a ≠ b → G.Adj a b)
  (p q : Finset V) (hp : p ∈ pairs) (hq : q ∈ pairs) (hpq : p ≠ q)
  (u : V) (hu : u ∈ p) (w : V) (hw : w ∈ q) :
  ∃ z ∈ X2_sub G v p q, G.neighborFinset z ∩ p = {u} ∧ G.neighborFinset z ∩ q = {w} := by
    -- By Lemma 2, there exists a unique z in X2 that is a common neighbor of u and w.
    obtain ⟨z, hz⟩ : ∃ z ∈ G.neighborFinset u ∩ G.neighborFinset w ∩ (Finset.univ \ insert v (G.neighborFinset v)), True := by
      exact Exists.elim ( srg_99_14_1_2_unique_common_neighbor_in_X2 hG v pairs hpairs_partition hpairs_adj p q hp hq hpq u hu w hw ) fun x hx => ⟨ x, hx.1, trivial ⟩;
    have hz_X2_sub : z ∈ X2_sub G v p q := by
      apply srg_99_14_1_2_common_neighbor_in_X2_sub hG v pairs hpairs_partition hpairs_adj p q hp hq hpq u hu w hw z hz.left;
    have hz_u : u ∈ G.neighborFinset z ∩ p := by
      simp +zetaDelta at *;
      exact ⟨ hz.1.symm, hu ⟩
    have hz_w : w ∈ G.neighborFinset z ∩ q := by
      simp_all +decide [ SimpleGraph.adj_comm ];
    have hz_u_card : (G.neighborFinset z ∩ p).card = 1 := by
      exact Finset.mem_filter.mp hz_X2_sub |>.2.1
    have hz_w_card : (G.neighborFinset z ∩ q).card = 1 := by
      unfold X2_sub at hz_X2_sub; aesop;
    exact ⟨ z, hz_X2_sub, Finset.card_eq_one.mp hz_u_card |> fun ⟨ x, hx ⟩ => by aesop, Finset.card_eq_one.mp hz_w_card |> fun ⟨ x, hx ⟩ => by aesop ⟩

/-
The set of pairs of singleton neighbors has size 4.
-/
def pairs_neighbors {V : Type} [Fintype V] (p q : Finset V) : Finset (Finset V × Finset V) :=
  (p.product q).image (fun x => ({x.1}, {x.2}))

lemma pairs_neighbors_card {V : Type} [Fintype V] (p q : Finset V) (hp : p.card = 2) (hq : q.card = 2) :
  (pairs_neighbors p q).card = 4 := by
    erw [ Finset.card_image_of_injective ] <;> norm_num [ Function.Injective, hp, hq ]

/-
The number of sharing and disjoint fiber pairs is 20 each.
-/
def sharing_fibers {V : Type} [Fintype V] (pairs : Finset (Finset V)) (p q : Finset V) : Finset (Finset V × Finset V) :=
  (pairs.product pairs).filter (fun (r, s) => r ≠ s ∧ r.card = 2 ∧ s.card = 2 ∧ ({r, s} : Finset (Finset V)) ≠ {p, q} ∧ ({r, s} ∩ {p, q} : Finset (Finset V)).card = 1)

def disjoint_fibers {V : Type} [Fintype V] (pairs : Finset (Finset V)) (p q : Finset V) : Finset (Finset V × Finset V) :=
  (pairs.product pairs).filter (fun (r, s) => r ≠ s ∧ r.card = 2 ∧ s.card = 2 ∧ ({r, s} : Finset (Finset V)) ≠ {p, q} ∧ ({r, s} ∩ {p, q} : Finset (Finset V)).card = 0)

lemma srg_99_14_1_2_fiber_counts {V : Type} [Fintype V] {G : SimpleGraph V}
  (hG : G.IsSRGWith 99 14 1 2) (v : V)
  (pairs : Finset (Finset V))
  (hpairs_partition : pairs.card = 7 ∧ (∀ p ∈ pairs, p.card = 2) ∧ (∀ p ∈ pairs, p ⊆ G.neighborFinset v) ∧
                      (∀ p ∈ pairs, ∀ q ∈ pairs, p ≠ q → Disjoint p q) ∧
                      (G.neighborFinset v = pairs.biUnion id))
  (p q : Finset V) (hp : p ∈ pairs) (hq : q ∈ pairs) (hpq : p ≠ q) :
  (sharing_fibers pairs p q).card = 20 ∧ (disjoint_fibers pairs p q).card = 20 := by
    -- By definition of `sharing_fibers` and `disjoint_fibers`, we can count the number of such pairs.
    have h_sharing : (sharing_fibers pairs p q).card = 20 := by
      -- Let's count the number of pairs of fibers where one fiber is in the image of `p` and the other is in the image of `q`.
      have h_count_fibers : (sharing_fibers pairs p q) = Finset.image (fun r => (p, r)) (pairs \ {p, q}) ∪ Finset.image (fun r => (r, p)) (pairs \ {p, q}) ∪ Finset.image (fun r => (q, r)) (pairs \ {p, q}) ∪ Finset.image (fun r => (r, q)) (pairs \ {p, q}) := by
        ext ⟨a, b⟩
        simp [sharing_fibers];
        grind;
      rw [ h_count_fibers, Finset.card_union_of_disjoint, Finset.card_union_of_disjoint, Finset.card_union_of_disjoint ] <;> norm_num [ Finset.disjoint_left, hpq, hp, hq ];
      · simp_all +decide [ Finset.card_image_of_injective, Function.Injective ];
        rw [ Finset.card_sdiff ] ; simp +decide [ *, Finset.subset_iff ];
      · grind;
      · grind;
      · grind
    have h_disjoint : (disjoint_fibers pairs p q).card = 20 := by
      have h_disjoint : (disjoint_fibers pairs p q).card = (pairs.erase p |>.erase q).card * ((pairs.erase p |>.erase q).card - 1) := by
        have h_disjoint : (disjoint_fibers pairs p q).card = Finset.card (Finset.offDiag (pairs.erase p |>.erase q)) := by
          have h_disjoint : disjoint_fibers pairs p q = Finset.image (fun r => (r.1, r.2)) (Finset.offDiag (pairs.erase p |>.erase q)) := by
            ext ⟨r, s⟩; simp [disjoint_fibers];
            grind;
          rw [ h_disjoint, Finset.card_image_of_injective ] ; aesop_cat;
        simp_all +decide [ Finset.offDiag_card ];
        rw [ Nat.mul_sub_left_distrib, Nat.mul_one ];
      rw [ h_disjoint, Finset.card_erase_of_mem, Finset.card_erase_of_mem ] <;> aesop_cat
    exact ⟨h_sharing, h_disjoint⟩

/-
The number of sharing and disjoint fiber sets is 10 each.
-/
def sharing_fibers_sets {V : Type} [Fintype V] (pairs : Finset (Finset V)) (p q : Finset V) : Finset (Finset (Finset V)) :=
  (sharing_fibers pairs p q).image (fun x => {x.1, x.2})

def disjoint_fibers_sets {V : Type} [Fintype V] (pairs : Finset (Finset V)) (p q : Finset V) : Finset (Finset (Finset V)) :=
  (disjoint_fibers pairs p q).image (fun x => {x.1, x.2})

lemma srg_99_14_1_2_fiber_set_counts {V : Type} [Fintype V] {G : SimpleGraph V}
  (hG : G.IsSRGWith 99 14 1 2) (v : V)
  (pairs : Finset (Finset V))
  (hpairs_partition : pairs.card = 7 ∧ (∀ p ∈ pairs, p.card = 2) ∧ (∀ p ∈ pairs, p ⊆ G.neighborFinset v) ∧
                      (∀ p ∈ pairs, ∀ q ∈ pairs, p ≠ q → Disjoint p q) ∧
                      (G.neighborFinset v = pairs.biUnion id))
  (p q : Finset V) (hp : p ∈ pairs) (hq : q ∈ pairs) (hpq : p ≠ q) :
  (sharing_fibers_sets pairs p q).card = 10 ∧ (disjoint_fibers_sets pairs p q).card = 10 := by
    -- Since these are ordered pairs, we can divide the count by 2 to get the number of sets.
    have h_div : ∀ (S : Finset (Finset V × Finset V)), (∀ (x y : Finset V), (x, y) ∈ S → (y, x) ∈ S) → (∀ (x y : Finset V), (x, y) ∈ S → x ≠ y) → (Finset.image (fun (a, b) => {a, b} : Finset V × Finset V → Finset (Finset V)) S).card = S.card / 2 := by
      intros S hS_symm hS_neq
      have h_div : (Finset.image (fun (a, b) => {a, b} : Finset V × Finset V → Finset (Finset V)) S).card * 2 = S.card := by
        have h_div : ∀ (T : Finset (Finset (Finset V))), (∀ t ∈ T, ∃ x y : Finset V, t = {x, y} ∧ (x, y) ∈ S ∧ (y, x) ∈ S ∧ x ≠ y) → (Finset.biUnion T (fun t => Finset.filter (fun (a, b) => {a, b} = t) S)).card = 2 * T.card := by
          intros T hT
          have h_div : ∀ t ∈ T, (Finset.filter (fun (a, b) => {a, b} = t) S).card = 2 := by
            intros t ht
            obtain ⟨x, y, ht_eq, hxS, hyS, hxy⟩ := hT t ht
            have h_filter : Finset.filter (fun (a, b) => {a, b} = t) S = {(x, y), (y, x)} := by
              ext ⟨ a, b ⟩ ; simp +decide [ ht_eq, hxy ] ;
              constructor <;> intro h;
              · rw [ Finset.ext_iff ] at h ; have := h.2 a ; have := h.2 b ; aesop;
              · grind;
            rw [ h_filter, Finset.card_pair ( by aesop ) ];
          rw [ Finset.card_biUnion ];
          · rw [ Finset.sum_congr rfl h_div, Finset.sum_const, smul_eq_mul, mul_comm ];
          · intros t ht t' ht' h; simp_all +decide [ Finset.disjoint_left ] ;
        convert h_div ( Finset.image ( fun x : Finset V × Finset V => { x.1, x.2 } ) S ) _ |> Eq.symm using 1;
        · ring;
        · rw [ show ( Finset.biUnion ( Finset.image ( fun x : Finset V × Finset V => { x.1, x.2 } ) S ) fun t => Finset.filter ( fun x : Finset V × Finset V => { x.1, x.2 } = t ) S ) = S from ?_ ];
          ext ⟨x, y⟩; simp [Finset.mem_biUnion, Finset.mem_image];
          exact fun h => ⟨ x, y, h, rfl ⟩;
        · grind;
      rw [ ← h_div, Nat.mul_div_cancel _ two_pos ];
    apply And.intro;
    · convert h_div ( sharing_fibers pairs p q ) _ _ using 1 <;> norm_num [ hpq ];
      · have := srg_99_14_1_2_fiber_counts hG v pairs hpairs_partition p q hp hq hpq; norm_num at *; omega;
      · simp +contextual [ sharing_fibers ];
        grind;
      · unfold sharing_fibers; aesop;
    · convert h_div ( disjoint_fibers pairs p q ) _ _ using 1;
      · have := srg_99_14_1_2_fiber_counts hG v pairs hpairs_partition p q hp hq hpq; aesop;
      · simp +contextual [ disjoint_fibers ];
        grind;
      · unfold disjoint_fibers; aesop;

/-
The number of pairs of edges disjoint from two given disjoint pairs of edges is 3.
-/
def third_fibers_edges {V : Type} [Fintype V] (pairs : Finset (Finset V)) (p q r s : Finset V) : Finset (Finset (Finset V)) :=
  (pairs.powersetCard 2).filter (fun K => Disjoint K {p, q} ∧ Disjoint K {r, s})

lemma third_fibers_edges_card {V : Type} [Fintype V] (pairs : Finset (Finset V)) (p q r s : Finset V)
  (hp : p ∈ pairs) (hq : q ∈ pairs) (hpq : p ≠ q)
  (hr : r ∈ pairs) (hs : s ∈ pairs) (hrs : r ≠ s)
  (h_disjoint : Disjoint ({p, q} : Finset (Finset V)) {r, s})
  (hpairs_card : pairs.card = 7) :
  (third_fibers_edges pairs p q r s).card = 3 := by
    have h_third_fibers_card : (pairs \ ({p, q} ∪ {r, s})).card = 3 := by
      rw [ Finset.card_sdiff ] ; simp_all +decide [ Finset.subset_iff ];
    convert Finset.card_powersetCard 2 ( pairs \ ( { p, q } ∪ { r, s } ) ) using 2;
    · ext; simp [third_fibers_edges];
      simp_all +decide [ Finset.subset_iff, Finset.mem_sdiff, Finset.mem_union ];
      grind;
    · exact h_third_fibers_card.symm ▸ rfl

/-
If two sets of subsets of size 2 have intersection size 2 for all pairs, then all subsets are equal.
-/
lemma binary_matrix_dot_product_two {α : Type} [Fintype α] [DecidableEq α] (h_card : Fintype.card α = 4)
  (f g : α → Finset α)
  (hf_card : ∀ i, (f i).card = 2)
  (hg_card : ∀ i, (g i).card = 2)
  (h_dot : ∀ i j, (f i ∩ g j).card = 2) :
  ∀ i j, f i = f j := by
    have h_support_eq : ∀ i j, f i = g j := by
      intro i j;
      have h_support_eq : f i ⊆ g j := by
        have := Finset.eq_of_subset_of_card_le ( Finset.inter_subset_left : f i ∩ g j ⊆ f i ) ; aesop;
      exact Finset.eq_of_subset_of_card_le h_support_eq ( by aesop );
    exact fun i j => by rw [ h_support_eq i j, h_support_eq j j ] ;

/-
Common neighbors in X2 for vertices in X2_sub p q, depending on their shared neighbors in X1 (match case).
-/
lemma srg_99_14_1_2_X2_sub_common_neighbors_X1_match {V : Type} [Fintype V] {G : SimpleGraph V}
  (hG : G.IsSRGWith 99 14 1 2) (v : V)
  (pairs : Finset (Finset V))
  (hpairs_partition : pairs.card = 7 ∧ (∀ p ∈ pairs, p.card = 2) ∧ (∀ p ∈ pairs, p ⊆ G.neighborFinset v) ∧
                      (∀ p ∈ pairs, ∀ q ∈ pairs, p ≠ q → Disjoint p q) ∧
                      (G.neighborFinset v = pairs.biUnion id))
  (hpairs_adj : ∀ p ∈ pairs, ∀ a ∈ p, ∀ b ∈ p, a ≠ b → G.Adj a b)
  (p q : Finset V) (hp : p ∈ pairs) (hq : q ∈ pairs) (hpq : p ≠ q)
  (x y : V) (hx : x ∈ X2_sub G v p q) (hy : y ∈ X2_sub G v p q)
  (h_neq : x ≠ y)
  (h_share_X1 : (G.neighborFinset x ∩ G.neighborFinset y ∩ G.neighborFinset v).card = 1) :
  (G.Adj x y → (G.neighborFinset x ∩ G.neighborFinset y ∩ (Finset.univ \ insert v (G.neighborFinset v))).card = 0) ∧
  (¬ G.Adj x y → (G.neighborFinset x ∩ G.neighborFinset y ∩ (Finset.univ \ insert v (G.neighborFinset v))).card = 1) := by
    have h_common_neighbors_X2 : (G.neighborFinset x ∩ G.neighborFinset y ∩ (Finset.univ \ insert v (G.neighborFinset v))).card + (G.neighborFinset x ∩ G.neighborFinset y ∩ G.neighborFinset v).card = if G.Adj x y then 1 else 2 := by
      have h_common_neighbors_X2 : (G.neighborFinset x ∩ G.neighborFinset y).card = if G.Adj x y then 1 else 2 := by
        have := hG.4;
        split_ifs with h;
        · have := hG.3;
          convert this x y h using 1;
          rw [ Fintype.card_of_subtype ] ; aesop;
        · convert this h_neq h using 1;
          rw [ Fintype.card_of_subtype ] ; aesop;
      rw [ ← h_common_neighbors_X2, ← Finset.card_union_of_disjoint ];
      · congr with z ; by_cases hz : z = v <;> simp +decide [ hz ];
        · intro hxv hyv; have := hG; simp_all +decide [ SimpleGraph.IsSRGWith ] ;
          have := this.2; simp_all +decide [ SimpleGraph.neighborFinset_def ] ;
          unfold X2_sub at hx hy; simp_all +decide [ SimpleGraph.adj_comm ] ;
        · by_cases h : G.Adj v z <;> simp +decide [ h ];
      · exact Finset.disjoint_left.mpr fun z => by aesop;
    grind

/-
Common neighbors in X2 for vertices in X2_sub p q, depending on their shared neighbors in X1 (disjoint case).
-/
lemma srg_99_14_1_2_X2_sub_common_neighbors_X1_disjoint {V : Type} [Fintype V] {G : SimpleGraph V}
  (hG : G.IsSRGWith 99 14 1 2) (v : V)
  (pairs : Finset (Finset V))
  (hpairs_partition : pairs.card = 7 ∧ (∀ p ∈ pairs, p.card = 2) ∧ (∀ p ∈ pairs, p ⊆ G.neighborFinset v) ∧
                      (∀ p ∈ pairs, ∀ q ∈ pairs, p ≠ q → Disjoint p q) ∧
                      (G.neighborFinset v = pairs.biUnion id))
  (hpairs_adj : ∀ p ∈ pairs, ∀ a ∈ p, ∀ b ∈ p, a ≠ b → G.Adj a b)
  (p q : Finset V) (hp : p ∈ pairs) (hq : q ∈ pairs) (hpq : p ≠ q)
  (x y : V) (hx : x ∈ X2_sub G v p q) (hy : y ∈ X2_sub G v p q)
  (h_neq : x ≠ y)
  (h_disjoint_X1 : (G.neighborFinset x ∩ G.neighborFinset y ∩ G.neighborFinset v).card = 0) :
  (G.Adj x y → (G.neighborFinset x ∩ G.neighborFinset y ∩ (Finset.univ \ insert v (G.neighborFinset v))).card = 1) ∧
  (¬ G.Adj x y → (G.neighborFinset x ∩ G.neighborFinset y ∩ (Finset.univ \ insert v (G.neighborFinset v))).card = 2) := by
    have h_common_neighbors_X2 : (G.neighborFinset x ∩ G.neighborFinset y).card = if G.Adj x y then 1 else 2 := by
      split_ifs <;> simp_all +decide [ SimpleGraph.commonNeighbors ];
      · have := hG.of_adj ‹_›;
        convert this x ( by simpa [ SimpleGraph.adj_comm ] using ‹G.Adj x y› ) using 1;
        rw [ Fintype.card_ofFinset ] ; congr ; ext ; simp +decide [ SimpleGraph.commonNeighbors, SimpleGraph.neighborSet ] ; aesop;
      · have := hG;
        obtain ⟨ h1, h2, h3 ⟩ := this; have := h3 x y; simp_all +decide [ SimpleGraph.neighborFinset ] ;
        rename_i h; specialize h; simp_all +decide [ Pairwise ] ;
        convert h h_neq ‹_› using 1;
        congr with z ; simp +decide [ SimpleGraph.commonNeighbors ];
    have h_common_neighbors_X2 : (G.neighborFinset x ∩ G.neighborFinset y ∩ (Finset.univ \ insert v (G.neighborFinset v))).card = (G.neighborFinset x ∩ G.neighborFinset y).card := by
      refine' congr_arg Finset.card ( Finset.ext fun z => _ );
      by_cases hz : z ∈ G.neighborFinset v <;> simp_all +decide [ Finset.ext_iff ];
      · exact fun hxz hyz => h_disjoint_X1 z hxz hyz _ hz.choose_spec.1 hz.choose_spec.2;
      · intro hxz hyz hzv; simp_all +decide [ SimpleGraph.adj_comm ] ;
        simp_all +decide [ X2_sub ];
    split_ifs at * <;> simp_all +decide only

/-
The sum of common neighbors of x with vertices in X1 is 26.
-/
lemma srg_99_14_1_2_X2_sub_X1_contribution {V : Type} [Fintype V] {G : SimpleGraph V}
  (hG : G.IsSRGWith 99 14 1 2) (v : V)
  (pairs : Finset (Finset V))
  (hpairs_partition : pairs.card = 7 ∧ (∀ p ∈ pairs, p.card = 2) ∧ (∀ p ∈ pairs, p ⊆ G.neighborFinset v) ∧
                      (∀ p ∈ pairs, ∀ q ∈ pairs, p ≠ q → Disjoint p q) ∧
                      (G.neighborFinset v = pairs.biUnion id))
  (p q : Finset V) (hp : p ∈ pairs) (hq : q ∈ pairs) (hpq : p ≠ q)
  (x : V) (hx : x ∈ X2_sub G v p q) :
  ∑ y ∈ G.neighborFinset v, (G.commonNeighbors x y).ncard = 26 := by
    -- Since $x \notin G.neighborFinset v$, for each $y \in G.neighborFinset v$, we have $(G.commonNeighbors x y).ncard = if G.Adj x y then 1 else 2$.
    have h_common_neighbors : ∀ y ∈ G.neighborFinset v, (G.commonNeighbors x y).ncard = if G.Adj x y then 1 else 2 := by
      intro y hy;
      split_ifs with h;
      · have := hG.3;
        simpa [ Set.ncard_eq_toFinset_card' ] using this x y h;
      · have h_common_neighbors : ∀ x y : V, x ≠ y → ¬ G.Adj x y → (G.commonNeighbors x y).ncard = 2 := by
          intros x y hxy hxy'; exact (by
          have := hG.3;
          convert hG.4 using 1;
          simp +decide [ Pairwise, Set.ncard_eq_toFinset_card' ];
          exact ⟨ fun h => fun i j hij hij' => by have := hG.4; aesop, fun h => h hxy hxy' ⟩);
        unfold X2_sub at hx; aesop;
    have h_sum : ∑ y ∈ G.neighborFinset v, (if G.Adj x y then 1 else 2) = ∑ y ∈ G.neighborFinset v, 2 - ∑ y ∈ G.neighborFinset v, (if G.Adj x y then 1 else 0) := by
      exact eq_tsub_of_add_eq ( by rw [ ← Finset.sum_add_distrib ] ; exact Finset.sum_congr rfl fun _ _ => by aesop );
    -- Since $x \in X2_sub G v p q$, we know that $x$ has exactly 2 neighbors in $G.neighborFinset v$.
    have h_card_neighbors : (G.neighborFinset x ∩ G.neighborFinset v).card = 2 := by
      have h_adj_count : (G.neighborFinset x ∩ p).card = 1 ∧ (G.neighborFinset x ∩ q).card = 1 ∧ (∀ r ∈ pairs, r ≠ p → r ≠ q → (G.neighborFinset x ∩ r).card = 0) := by
        exact ⟨ Finset.mem_filter.mp hx |>.2.1, Finset.mem_filter.mp hx |>.2.2, fun r hr hrp hrq => srg_99_14_1_2_X2_sub_prop hG v pairs hpairs_partition p q hp hq hpq x hx |>.2.2.2 r hr hrp hrq ⟩;
      have h_adj_count : (G.neighborFinset x ∩ G.neighborFinset v).card = ∑ r ∈ pairs, (G.neighborFinset x ∩ r).card := by
        rw [ hpairs_partition.2.2.2.2, Finset.inter_biUnion ];
        rw [ Finset.card_biUnion ] ; aesop;
        exact fun a ha b hb hab => Disjoint.mono inf_le_right inf_le_right ( hpairs_partition.2.2.2.1 a ha b hb hab );
      rw [ h_adj_count, Finset.sum_eq_add_sum_diff_singleton hp ];
      rw [ Finset.sum_eq_single q ] <;> aesop;
    -- Since $x \in X2_sub G v p q$, we know that $x$ has exactly 2 neighbors in $G.neighborFinset v$, and these neighbors are in $p$ and $q$.
    have h_card_neighbors : ∑ y ∈ G.neighborFinset v, (if G.Adj x y then 1 else 0) = (G.neighborFinset x ∩ G.neighborFinset v).card := by
      simp +decide [ Finset.sum_ite, SimpleGraph.adj_comm ];
      congr 1 with y ; simp +decide [ SimpleGraph.adj_comm ];
      tauto;
    rw [ Finset.sum_congr rfl h_common_neighbors, h_sum, h_card_neighbors, ‹ ( G.neighborFinset x ∩ G.neighborFinset v ).card = 2 › ] ; norm_num [ hG.regular v ]

/-
The sum of common neighbors of x with vertices in X2 is 168.
-/
lemma srg_99_14_1_2_X2_sub_X2_contribution {V : Type} [Fintype V] {G : SimpleGraph V}
  (hG : G.IsSRGWith 99 14 1 2) (v : V)
  (pairs : Finset (Finset V))
  (hpairs_partition : pairs.card = 7 ∧ (∀ p ∈ pairs, p.card = 2) ∧ (∀ p ∈ pairs, p ⊆ G.neighborFinset v) ∧
                      (∀ p ∈ pairs, ∀ q ∈ pairs, p ≠ q → Disjoint p q) ∧
                      (G.neighborFinset v = pairs.biUnion id))
  (p q : Finset V) (hp : p ∈ pairs) (hq : q ∈ pairs) (hpq : p ≠ q)
  (x : V) (hx : x ∈ X2_sub G v p q) :
  ∑ y ∈ (Finset.univ \ insert v (G.neighborFinset v)), (G.commonNeighbors x y).ncard = 168 := by
    have h_common_neighbors_X2 : ∑ y ∈ Finset.univ, (G.commonNeighbors x y).ncard = 196 := by
      -- By definition of $G$, we know that the sum of the number of common neighbors of $x$ with all vertices in $G$ is equal to the sum of the degrees of the neighbors of $x$.
      have h_sum_common_neighbors : ∑ y ∈ Finset.univ, (G.commonNeighbors x y).ncard = ∑ y ∈ G.neighborFinset x, (G.neighborFinset y).card := by
        simp +decide [ SimpleGraph.neighborFinset, SimpleGraph.commonNeighbors, Set.ncard_eq_toFinset_card' ];
        simp +decide only [Finset.card_eq_sum_ones, Finset.sum_filter];
        rw [ Finset.sum_comm ];
        simp +decide [ SimpleGraph.neighborSet ];
        exact Finset.sum_congr rfl fun _ _ => congr_arg Finset.card <| by ext; simp +contextual [ SimpleGraph.adj_comm ] ;
      -- Since $G$ is a strongly regular graph with parameters $(99, 14, 1, 2)$, each vertex has degree $14$.
      have h_deg : ∀ y : V, (G.neighborFinset y).card = 14 := by
        exact fun y => hG.regular y;
      aesop;
    rw [ ← Finset.sum_sdiff ( show insert v ( G.neighborFinset v ) ⊆ Finset.univ from Finset.subset_univ _ ) ] at *;
    have h_common_neighbors_X1 : ∑ y ∈ insert v (G.neighborFinset v), (G.commonNeighbors x y).ncard = 28 := by
      have h_common_neighbors_X1 : ∑ y ∈ G.neighborFinset v, (G.commonNeighbors x y).ncard = 26 := by
        exact?;
      rw [ Finset.sum_insert ] <;> simp_all +decide;
      · have := hG;
        obtain ⟨ _, _, _, _ ⟩ := this;
        rename_i h₁ h₂ h₃ h₄;
        by_cases h : G.Adj x v <;> simp_all +decide [ SimpleGraph.commonNeighbors ];
        · exact False.elim <| Finset.mem_sdiff.mp ( Finset.mem_filter.mp hx |>.1 ) |>.2 <| Finset.mem_insert_of_mem <| Finset.mem_coe.mpr <| h |> fun h => by simpa using h.symm;
        · convert h₄ ( show x ≠ v from by rintro rfl; simp_all +decide [ X2_sub ] ) ( by tauto ) using 1;
          rw [ ← Set.ncard_coe_finset ] ; congr ; aesop;
      · intro p hp; specialize hpairs_partition; have := hpairs_partition.2.2.1 p hp; simp_all +decide [ SimpleGraph.neighborFinset ] ;
        exact fun h => by have := hpairs_partition.2.2.1 p hp h; simp_all +decide [ SimpleGraph.neighborSet ] ;
    linarith

/-
The fiber configuration system has no integer solutions.
-/
structure SRG_99_14_1_2_Fiber_Config where
  n_in : ℕ
  k_S : ℕ
  k_D : ℕ
  h_n_in : n_in ∈ ({0, 2} : Finset ℕ)
  h_sum : n_in + 10 * k_S + 10 * k_D = 12
  h_D : 8 = k_D + 2 * n_in * k_D + 4 * k_S ^ 2 + 12 * k_S * k_D + 3 * k_D ^ 2
  h_S : 4 = k_S + 2 * n_in * k_S + 5 * k_S ^ 2 + 7 * k_S * k_D + 7 * k_D ^ 2

theorem srg_99_14_1_2_fiber_config_impossible : IsEmpty SRG_99_14_1_2_Fiber_Config := by
  constructor;
  rintro ⟨ n_in, k_S, k_D, h_sum, h_S, h_D ⟩;
  rcases k_S with ( _ | _ | k_S ) <;> rcases k_D with ( _ | _ | k_D ) <;> simp +arith +decide at *

#check SRG_99_14_1_2_Fiber_Config

/-
The fiber configuration system has no integer solutions.
-/
lemma srg_conf_imp : IsEmpty SRG_99_14_1_2_Fiber_Config := by
  exact?

/-
Definitions of fiber intersection numbers.
-/
def n_in_val {V : Type} [Fintype V] {G : SimpleGraph V} (v : V) (p q : Finset V) (x : V) : ℕ :=
  (G.neighborFinset x ∩ X2_sub G v p q).card

def k_S_val {V : Type} [Fintype V] {G : SimpleGraph V} (v : V) (pairs : Finset (Finset V)) (p q : Finset V) (x : V) : ℕ :=
  let sharing := sharing_fibers pairs p q
  if h : sharing.Nonempty then
    let rs := Classical.choose h
    (G.neighborFinset x ∩ X2_sub G v rs.1 rs.2).card
  else 0

def k_D_val {V : Type} [Fintype V] {G : SimpleGraph V} (v : V) (pairs : Finset (Finset V)) (p q : Finset V) (x : V) : ℕ :=
  let disjoint := disjoint_fibers pairs p q
  if h : disjoint.Nonempty then
    let rs := Classical.choose h
    (G.neighborFinset x ∩ X2_sub G v rs.1 rs.2).card
  else 0

/-
A clique of size 4 is impossible in a graph with lambda=1.
-/
lemma clique_size_4_impossible_in_lambda_1 {V : Type} [Fintype V] {G : SimpleGraph V}
  (h_lambda : ∀ v w : V, G.Adj v w → (G.commonNeighbors v w).ncard = 1)
  (s : Finset V) (h_card : s.card = 4) (h_clique : ∀ x ∈ s, ∀ y ∈ s, x ≠ y → G.Adj x y) :
  False := by
    rcases Finset.card_eq_succ.mp h_card with ⟨ x, hx ⟩;
    obtain ⟨ t, ht, rfl, ht' ⟩ := hx;
    have := Finset.card_eq_three.mp ht'; obtain ⟨ y, z, w, hy, hz, hw, h ⟩ := this; simp_all +decide [ SimpleGraph.commonNeighbors ] ;
    obtain ⟨ a, ha ⟩ := h_lambda x y h_clique.1.1; obtain ⟨ b, hb ⟩ := h_lambda x z h_clique.1.2.1; obtain ⟨ c, hc ⟩ := h_lambda x w h_clique.1.2.2; simp_all +decide [ Set.eq_singleton_iff_unique_mem ] ;

/-
In an SRG with lambda=1, two vertices sharing 2 or more neighbors cannot be adjacent.
-/
lemma srg_lambda_1_twins_not_adj {V : Type} [Fintype V] {G : SimpleGraph V} {n k m : ℕ}
  (hG : G.IsSRGWith n k 1 m) (x y : V) (h_twins : (G.neighborFinset x ∩ G.neighborFinset y).card ≥ 2) :
  ¬ G.Adj x y := by
    apply srg_lambda_1_implies_not_adj_if_2_common;
    exact hG;
    convert h_twins using 1;
    rw [ ← Set.ncard_coe_finset ] ; congr ; ext ; simp +decide [ SimpleGraph.commonNeighbors ] ;