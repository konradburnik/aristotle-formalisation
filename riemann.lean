/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 3befe360-8bd4-432f-b2a2-37c5daff6e3a

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>

Aristotle's budget for this request has been reached.
If there is partial progress, it will appear in this file.
If you would like to continue working off of this partial progress,
please submit the same prompt, and add this .lean file in "Optional: Attach a Lean file as context" field.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
Check the definition of the Riemann Hypothesis.
-/
#check RiemannHypothesis

/-
Check the functional equation for the Riemann Zeta function.
-/
#check riemannZeta_one_sub

/-
Non-trivial zeros of the Riemann zeta function lie in the critical strip 0 < Re(s) < 1.
-/
lemma critical_strip {s : ℂ} (h_zero : riemannZeta s = 0) (h_not_trivial : ¬ ∃ n : ℕ, s = -2 * (n + 1)) (h_ne_one : s ≠ 1) : 0 < s.re ∧ s.re < 1 := by
  -- First, use `riemannZeta_ne_zero_of_one_le_re` to show `s.re < 1`.
  have h_re_lt_one : s.re < 1 := by
    exact lt_of_not_ge fun h => h_ne_one <| by have := riemannZeta_ne_zero_of_one_le_re h; aesop;
  refine ⟨ lt_of_not_ge fun h => ?_, h_re_lt_one ⟩;
  -- If $s$ is a negative integer, it must be a trivial zero (even) or a non-zero value (odd). Since we assume not trivial, and odd negatives are not zeros, $s$ is not a negative integer.
  by_cases hs_neg_int : ∃ n : ℕ, s = -n;
  · obtain ⟨ n, rfl ⟩ := hs_neg_int; rcases Nat.even_or_odd' n with ⟨ k, rfl | rfl ⟩ <;> norm_num at *;
    · rcases k with ( _ | k ) <;> norm_num at *;
      exact absurd h_zero ( by rw [ riemannZeta_zero ] ; norm_num );
    · -- Use the functional equation to relate ζ(-1 - 2k) to ζ(2 + 2k).
      have h_fun_eq : riemannZeta (-1 - 2 * (k : ℂ)) = 2 * (2 * Real.pi) ^ (-(2 + 2 * (k : ℂ))) * Complex.Gamma (2 + 2 * (k : ℂ)) * Complex.cos (Real.pi * (2 + 2 * (k : ℂ)) / 2) * riemannZeta (2 + 2 * (k : ℂ)) := by
        convert riemannZeta_one_sub _ _ using 2 <;> ring;
        · norm_cast ; aesop;
        · norm_cast ; linarith;
      -- Since $\cos(\pi(2 + 2k)/2) = \cos(\pi + \pi k) = (-1)^{k+1}$, we have:
      have h_cos : Complex.cos (Real.pi * (2 + 2 * (k : ℂ)) / 2) ≠ 0 := by
        ring_nf; norm_cast; norm_num [ mul_assoc, mul_comm Real.pi _, mul_div ];
        norm_num [ Real.cos_add ];
        exact fun h => absurd ( Real.sin_sq_add_cos_sq ( k * Real.pi ) ) ( by norm_num [ h ] );
      -- Since $\Gamma(2 + 2k)$ is non-zero for all $k$, we have:
      have h_gamma : Complex.Gamma (2 + 2 * (k : ℂ)) ≠ 0 := by
        exact Complex.Gamma_ne_zero_of_re_pos ( by norm_cast; linarith );
      -- Since $\zeta(2 + 2k)$ is non-zero for all $k$, we have:
      have h_zeta : riemannZeta (2 + 2 * (k : ℂ)) ≠ 0 := by
        have h_zeta : ∀ s : ℂ, 1 < s.re → riemannZeta s ≠ 0 := by
          exact?;
        exact h_zeta _ ( by norm_num; linarith );
      simp_all +decide [ sub_eq_add_neg, add_assoc ];
  · -- Use the functional equation `riemannZeta (1-s) = ... riemannZeta s`.
    have h_fun_eq : riemannZeta (1 - s) = 2 * (2 * Real.pi) ^ (-s) * Complex.Gamma s * Complex.cos (Real.pi * s / 2) * riemannZeta s := by
      apply riemannZeta_one_sub; aesop;
      assumption;
    simp_all +decide [ Complex.Gamma_eq_zero_iff ];
    exact absurd h_fun_eq ( riemannZeta_ne_zero_of_one_le_re <| by norm_num; linarith )

/-
In the critical strip, ζ(s) = 0 iff ζ(1-s) = 0.
-/
lemma zeros_symm_in_critical_strip {s : ℂ} (hs : 0 < s.re) (hs' : s.re < 1) :
  riemannZeta s = 0 ↔ riemannZeta (1 - s) = 0 := by
    constructor <;> intro H <;> simp_all +decide [ add_comm, add_left_comm, sub_eq_add_neg ];
    · rw [ neg_add_eq_sub, riemannZeta_one_sub ] ; aesop;
      · exact fun n => ne_of_apply_ne Complex.re <| by norm_num; linarith;
      · aesop;
    · -- Apply the functional equation to $s$ and then use the fact that $\zeta(-s + 1) = 0$ to conclude $\zeta(s) = 0$.
      have h_fun_eq : riemannZeta s = 2 * (2 * Real.pi) ^ (-(-s + 1)) * Complex.Gamma (-s + 1) * Complex.cos (Real.pi * (-s + 1) / 2) * riemannZeta (-s + 1) := by
        convert riemannZeta_one_sub _ _ using 1 <;> ring;
        · intro n hn; norm_num [ Complex.ext_iff ] at hn; linarith;
        · aesop;
      aesop

/-
The Riemann zeta function commutes with complex conjugation: ζ(s̄) = ζ(s)̄.
-/
lemma riemannZeta_conj {s : ℂ} : riemannZeta (star s) = star (riemannZeta s) := by
  -- Since the Riemann zeta function is analytic, if it equals its conjugate for all $s$ with $\text{Re}(s) > 1$, then it must equal its conjugate for all $s$ by the identity theorem for analytic functions.
  have h_analytic : ∀ s : ℂ, s ≠ 1 → riemannZeta (star s) = star (riemannZeta s) := by
    have h_analytic : AnalyticOn ℂ (fun s => riemannZeta s) (Set.univ \ {1}) := by
      apply_rules [ DifferentiableOn.analyticOn ];
      · refine' fun s hs => DifferentiableAt.differentiableWithinAt _;
        exact differentiableAt_riemannZeta hs.2;
      · exact isOpen_univ.sdiff isClosed_singleton;
    have h_analytic_conj : AnalyticOn ℂ (fun s => star (riemannZeta (star s))) (Set.univ \ {1}) := by
      apply_rules [ DifferentiableOn.analyticOn ];
      · intro s hs;
        have h_diff : DifferentiableAt ℂ (fun s => riemannZeta s) (star s) := by
          apply_rules [ h_analytic.differentiableOn.differentiableAt ];
          exact Filter.mem_of_superset ( isOpen_ne.mem_nhds <| show Star.star s ≠ 1 from by simpa [ Complex.ext_iff ] using hs.2 ) fun x hx => ⟨ Set.mem_univ _, hx ⟩;
        have h_diff_conj : HasDerivAt (fun s => star (riemannZeta (star s))) (star (deriv (fun s => riemannZeta s) (star s))) s := by
          rw [ hasDerivAt_iff_tendsto_slope_zero ];
          have := h_diff.hasDerivAt.tendsto_slope_zero;
          convert Complex.continuous_conj.continuousAt.tendsto.comp ( this.comp ( show Filter.Tendsto ( fun t : ℂ => star t ) ( nhdsWithin 0 { 0 } ᶜ ) ( nhdsWithin 0 { 0 } ᶜ ) from Filter.Tendsto.inf ( Continuous.tendsto' ( by continuity ) _ _ <| by norm_num ) <| by norm_num ) ) using 2 ; norm_num;
        exact h_diff_conj.differentiableAt.differentiableWithinAt;
      · exact isOpen_univ.sdiff isClosed_singleton;
    have h_identity : ∀ s : ℂ, s ≠ 1 → riemannZeta s = star (riemannZeta (star s)) := by
      intro s hs
      have h_eq : ∀ s : ℂ, 1 < s.re → riemannZeta s = star (riemannZeta (star s)) := by
        intro s hs
        have h_eq : riemannZeta s = ∑' n : ℕ, (1 : ℂ) / (n + 1) ^ s := by
          exact?;
        have h_eq_conj : riemannZeta (star s) = ∑' n : ℕ, (1 : ℂ) / (n + 1) ^ (star s) := by
          exact?;
        rw [ h_eq, h_eq_conj, ← tsum_congr ];
        rw [ ← Complex.conj_tsum ];
        congr! 1;
        intro n; simp +decide [ Complex.cpow_def ];
        norm_cast ; norm_num [ Complex.ext_iff, Complex.exp_re, Complex.exp_im, Complex.log_re, Complex.log_im ]
      have h_identity : AnalyticOnNhd ℂ (fun s => riemannZeta s - star (riemannZeta (star s))) (Set.univ \ {1}) := by
        apply_rules [ AnalyticOnNhd.sub, h_analytic, h_analytic_conj ];
        · apply_rules [ DifferentiableOn.analyticOnNhd ];
          · exact h_analytic.differentiableOn;
          · exact isOpen_univ.sdiff isClosed_singleton;
        · apply_rules [ DifferentiableOn.analyticOnNhd ];
          · exact h_analytic_conj.differentiableOn;
          · exact isOpen_univ.sdiff isClosed_singleton;
      have h_identity : ∀ s : ℂ, s ≠ 1 → riemannZeta s - star (riemannZeta (star s)) = 0 := by
        intro s hs;
        apply h_identity.eqOn_zero_of_preconnected_of_frequently_eq_zero;
        any_goals exact Complex.I + 1;
        · have h_preconnected : IsPreconnected (Set.univ \ {0} : Set ℂ) := by
            have h_preconnected : IsConnected (Set.univ \ {0} : Set ℂ) := by
              have h_preconnected : IsConnected (Set.range (fun z : ℂ => Complex.exp z)) := by
                exact isConnected_range ( Complex.continuous_exp );
              convert h_preconnected using 1;
              ext; simp [Complex.exp_ne_zero];
            exact h_preconnected.isPreconnected;
          convert h_preconnected.image ( fun x => x + 1 ) ( Continuous.continuousOn ( by continuity ) ) using 1 ; ext ; simp +decide [ Set.diff_eq ];
        · norm_num [ Complex.ext_iff ];
        · rw [ Metric.nhdsWithin_basis_ball.frequently_iff ];
          intro ε ε_pos;
          refine' ⟨ Complex.I + 1 + ε / 2, _, _ ⟩ <;> norm_num [ Complex.ext_iff, ε_pos.ne' ];
          · linarith [ abs_of_pos ε_pos ];
          · have := h_eq ( Complex.I + 1 + ε / 2 ) ( by norm_num; linarith ) ; have := h_eq ( -Complex.I + 1 + ε / 2 ) ( by norm_num; linarith ) ; norm_num [ Complex.ext_iff ] at * ; aesop;
        · grind;
      exact eq_of_sub_eq_zero <| h_identity s hs;
    exact?;
  by_cases h : s = 1 <;> simp_all +decide;
  rw [ riemannZeta_one ] ; norm_num;
  norm_num [ Complex.ext_iff, Complex.log_re, Complex.log_im ];
  norm_num [ Complex.normSq, Complex.div_re, Complex.div_im, Complex.log_re, Complex.log_im, abs_of_pos Real.pi_pos ];
  norm_num [ Complex.arg ] ; ring;
  split_ifs <;> norm_num ; linarith [ Real.pi_pos ]

/-
The Riemann Hypothesis is false if and only if there is a zero in the strip 1/2 < Re(s) < 1.
-/
lemma counterexample_reduction : ¬ RiemannHypothesis ↔ ∃ s, riemannZeta s = 0 ∧ 1 / 2 < s.re ∧ s.re < 1 := by
  constructor;
  · contrapose!;
    intro h;
    contrapose! h;
    -- By definition of RiemannHypothesis, if it is false, then there exists a zero $s$ of $\zeta(s)$ such that $s.re \neq 1/2$.
    obtain ⟨s, hs⟩ : ∃ s : ℂ, riemannZeta s = 0 ∧ s.re ≠ 1 / 2 ∧ 0 < s.re ∧ s.re < 1 := by
      contrapose! h with h_contra;
      intro s hs h_not_trivial h_ne_one
      have h_critical : 0 < s.re ∧ s.re < 1 := by
        exact?;
      exact Classical.not_not.1 fun h => by linarith [ h_contra s hs h h_critical.1 ] ;
    cases lt_or_gt_of_ne hs.2.1 <;> [ refine' ⟨ 1 - s, _, _, _ ⟩ ; refine' ⟨ s, _, _, _ ⟩ ] <;> norm_num at * <;> try linarith;
    · rw [ ← zeros_symm_in_critical_strip ] <;> aesop;
    · exact hs.1;
  · rintro ⟨ s, hs ⟩;
    unfold RiemannHypothesis;
    push_neg;
    refine' ⟨ s, hs.1, _, _, _ ⟩ <;> norm_num [ Complex.ext_iff ] at *;
    · intros; linarith;
    · aesop;
    · linarith

/-
ζ(s) = 0 if and only if ζ(s̄) = 0.
-/
lemma zeros_conj_iff {s : ℂ} : riemannZeta s = 0 ↔ riemannZeta (star s) = 0 := by
  have := @riemannZeta_conj s;
  aesop

/-
The alternating series 1 - 1/2^x + 1/3^x - ... converges for x > 0.
-/
lemma alternating_series_converges {x : ℝ} (hx : 0 < x) :
  ∃ l, Filter.Tendsto (fun k => ∑ n ∈ Finset.range k, (-1 : ℝ) ^ n / (n + 1 : ℝ) ^ x) Filter.atTop (nhds l) := by
    -- The sequence $a_n = 1/(n+1)^x$ is antitone because $x > 0$ and $n \mapsto n+1$ is increasing.
    have h_antitone : Antitone (fun n : ℕ => 1 / ((n + 1 : ℝ) ^ x)) := by
      exact fun n m hnm => one_div_le_one_div_of_le ( by positivity ) ( by gcongr );
    -- The sequence $a_n = 1/(n+1)^x$ tends to 0 because $x > 0$.
    have h_tendsto_zero : Filter.Tendsto (fun n : ℕ => 1 / ((n + 1 : ℝ) ^ x)) Filter.atTop (nhds 0) := by
      exact tendsto_const_nhds.div_atTop ( tendsto_rpow_atTop ( by positivity ) |> Filter.Tendsto.comp <| Filter.tendsto_atTop_add_const_right _ _ tendsto_natCast_atTop_atTop );
    -- The alternating series test (Leibniz's test) states that if the sequence $a_n$ is antitone and tends to 0, then the alternating series $\sum_{n=0}^{\infty} (-1)^n a_n$ converges.
    have h_alt_series_test : ∀ {a : ℕ → ℝ}, Antitone a → Filter.Tendsto a Filter.atTop (nhds 0) → ∃ l : ℝ, Filter.Tendsto (fun k : ℕ => ∑ n ∈ Finset.range k, (-1 : ℝ) ^ n * a n) Filter.atTop (nhds l) := by
      exact?;
    simpa only [ one_div, mul_one ] using h_alt_series_test h_antitone h_tendsto_zero

/-
For Re(s) > 1, the alternating zeta series equals (1 - 2^(1-s)) * ζ(s).
-/
lemma eta_eq_zeta_mul_factor_of_gt_one {s : ℂ} (hs : 1 < s.re) :
  ∑' n : ℕ, (-1 : ℂ) ^ n / (n + 1 : ℂ) ^ s = (1 - 2 ^ (1 - s)) * riemannZeta s := by
    -- Applying the definition of the Riemann zeta function and the alternating series
    have h_alt_series : ∑' n : ℕ, (-1 : ℂ) ^ n / (n + 1 : ℂ) ^ s = ∑' n : ℕ, (1 : ℂ) ^ n / (n + 1 : ℂ) ^ s - 2 * ∑' n : ℕ, (1 : ℂ) ^ n / (2 * (n + 1) : ℂ) ^ s := by
      rw [ ← tsum_even_add_odd ];
      · rw [ eq_comm, ← tsum_even_add_odd ] ; norm_num [ neg_div, tsum_neg, tsum_mul_left ] ; ring;
        · have h_summable : Summable (fun n : ℕ => (1 : ℂ) / (n : ℂ) ^ s) := by
            exact?;
          convert h_summable.comp_injective ( show Function.Injective ( fun k : ℕ => 2 * k + 1 ) from fun a b h => by simpa using h ) using 2 ; norm_num;
        · have h_summable : Summable (fun n : ℕ => (1 : ℂ) / (n : ℂ) ^ s) := by
            exact?;
          convert h_summable.comp_injective ( show Function.Injective ( fun k : ℕ ↦ 2 * k + 1 + 1 ) from fun a b h ↦ by simpa using h ) using 2 ; norm_num;
      · -- The series $\sum_{n=1}^\infty \frac{1}{n^s}$ is a p-series with $p = s > 1$, so it converges.
        have h_pseries : Summable (fun n : ℕ => (1 : ℂ) / (n : ℂ) ^ s) := by
          exact?;
        convert h_pseries.comp_injective ( show Function.Injective ( fun k : ℕ ↦ 2 * k + 1 ) from fun a b h ↦ by simpa using h ) using 2 ; norm_num;
      · have h_summable : Summable (fun n : ℕ => (1 : ℂ) / (n + 1 : ℂ) ^ s) := by
          have h_summable : Summable (fun n : ℕ => (1 : ℂ) / (n : ℂ) ^ s) := by
            exact?;
          exact_mod_cast h_summable.comp_injective Nat.succ_injective;
        convert h_summable.comp_injective ( show Function.Injective ( fun k : ℕ => 2 * k + 1 ) from fun a b h => by simpa using h ) |> Summable.neg using 2 ; norm_num;
        ring;
    -- Using the definition of the Riemann zeta function, we can rewrite the sums in h_alt_series.
    have h_zeta : ∑' n : ℕ, (1 : ℂ) ^ n / (n + 1 : ℂ) ^ s = riemannZeta s ∧ ∑' n : ℕ, (1 : ℂ) ^ n / (2 * (n + 1) : ℂ) ^ s = (1 / 2 ^ s) * riemannZeta s := by
      rw [ zeta_eq_tsum_one_div_nat_add_one_cpow hs ];
      norm_num [ div_eq_mul_inv, mul_comm, tsum_mul_left ];
      rw [ ← tsum_mul_left ] ; congr ; ext n ; rw [ mul_comm, Complex.cpow_def_of_ne_zero, Complex.cpow_def_of_ne_zero ] <;> norm_num ; ring;
      · rw [ show ( 2 + n * 2 : ℂ ) = 2 * ( 1 + n ) by ring, Complex.log_mul ] <;> norm_num ; ring;
        · rw [ Complex.cpow_def_of_ne_zero ( by norm_cast; linarith ), Complex.exp_add ] ; ring;
        · exact mod_cast by positivity;
        · exact ⟨ by linarith [ Real.pi_pos, Complex.neg_pi_lt_arg ( 1 + n : ℂ ) ], by linarith [ Real.pi_pos, Complex.arg_le_pi ( 1 + n : ℂ ) ] ⟩;
      · exact Nat.cast_add_one_ne_zero _;
    rw [ h_alt_series, h_zeta.1, h_zeta.2, Complex.cpow_sub ] <;> norm_num ; ring

/-
Define the real Dirichlet eta function as the limit of the alternating series for x > 0.
-/
noncomputable def eta_real (x : ℝ) : ℝ :=
  if h : 0 < x then Classical.choose (alternating_series_converges h) else 0

/-
The real Dirichlet eta function is positive for x > 0.
-/
lemma eta_real_pos {x : ℝ} (hx0 : 0 < x) : 0 < eta_real x := by
  have := Classical.choose_spec ( alternating_series_converges hx0 );
  -- Since $a_n = 1/(n+1)^x$ is decreasing and tends to 0, the partial sums $S_{2k}$ and $S_{2k+1}$ are bounded.
  have h_bounds : ∀ k : ℕ, ∑ i ∈ Finset.range (2 * k), (-1 : ℝ) ^ i / ((i + 1 : ℝ) ^ x) ≤ ∑ i ∈ Finset.range (2 * k + 2), (-1 : ℝ) ^ i / ((i + 1 : ℝ) ^ x) ∧ ∑ i ∈ Finset.range (2 * k + 1), (-1 : ℝ) ^ i / ((i + 1 : ℝ) ^ x) ≥ ∑ i ∈ Finset.range (2 * k + 3), (-1 : ℝ) ^ i / ((i + 1 : ℝ) ^ x) := by
    norm_num [ Finset.sum_range_succ ];
    norm_num [ pow_add, div_eq_mul_inv ];
    exact fun k => ⟨ inv_anti₀ ( by positivity ) ( by gcongr ; linarith ), by linarith [ inv_anti₀ ( by positivity ) ( by gcongr ; linarith : ( 2 * k + 1 + 1 : ℝ ) ^ x ≤ ( 2 * k + 2 + 1 : ℝ ) ^ x ) ] ⟩;
  -- Since the partial sums are bounded, the limit must be positive.
  have h_pos : ∑ i ∈ Finset.range (2 * 1), (-1 : ℝ) ^ i / ((i + 1 : ℝ) ^ x) ≤ Classical.choose (alternating_series_converges hx0) := by
    exact le_of_tendsto_of_tendsto tendsto_const_nhds ( this.comp ( Filter.tendsto_id.nsmul_atTop two_pos ) ) ( Filter.eventually_atTop.mpr ⟨ 1, fun n hn => by induction hn <;> [ norm_num; linarith! [ h_bounds ‹_› ] ] ⟩ );
  norm_num [ Finset.sum_range_succ ] at *;
  exact lt_of_lt_of_le ( by ring_nf; nlinarith [ Real.rpow_lt_rpow_of_exponent_lt one_lt_two hx0, mul_inv_cancel₀ ( ne_of_gt ( Real.rpow_pos_of_pos zero_lt_two x ) ) ] ) ( show eta_real x ≥ 1 + -1 / 2 ^ x from by unfold eta_real; aesop )