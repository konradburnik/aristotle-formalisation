/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 74e6766f-f3a0-4191-8451-7dfb781bfa6e

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

/-
We define a binary search algorithm `binarySearch` that mirrors the provided C implementation. We then prove its correctness in `binarySearch_correct`, showing that if it returns an index, the element is present at that index, and if it returns -1, the element is not present in the array (assuming the array is sorted).
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
Helper loop for binary search with corrected termination measure.
-/
def binarySearchLoop (arr : Array Int) (x : Int) (low high : Int) : Int :=
  if h : low <= high then
    let mid := low + (high - low) / 2
    let midVal := if h_idx : mid.toNat < arr.size then arr[mid.toNat] else 0
    if midVal == x then mid
    else if midVal < x then binarySearchLoop arr x (mid + 1) high
    else binarySearchLoop arr x low (mid - 1)
  else -1
termination_by (high - low + 1).toNat
decreasing_by
  omega
  grind

/-
Main binary search function.
-/
def binarySearch (arr : Array Int) (n : Int) (x : Int) : Int :=
  binarySearchLoop arr x 0 (n - 1)

/-
Correctness of binary search: if it returns an index, the element is there; if it returns -1, the element is not in the array (assuming sorted). Using `!` for array access to avoid proof obligations in the statement.
-/
theorem binarySearch_correct (arr : Array Int) (n : Int) (x : Int)
  (h_sorted : ∀ (i j : Nat), i ≤ j → j < arr.size → arr[i]! ≤ arr[j]!)
  (hn : n = arr.size) :
  let res := binarySearch arr n x
  (res ≠ -1 → 0 ≤ res ∧ res.toNat < arr.size ∧ arr[res.toNat]! = x) ∧
  (res = -1 → ∀ (i : Nat), i < arr.size → arr[i]! ≠ x) := by
  unfold binarySearch;
  -- By definition of binary search, we know that if the element is found, it must be within the bounds of the array.
  have h_bounds : ∀ (low high : ℤ), low ≥ 0 → high < arr.size → (let res := binarySearchLoop arr x low high; (res ≠ -1 → low ≤ res ∧ res ≤ high ∧ arr[res.toNat]! = x) ∧ (res = -1 → ∀ i : ℕ, low ≤ i → i ≤ high → arr[i]! ≠ x)) := by
    intros low high hlow hhigh
    induction' h : (high - low + 1).toNat using Nat.strong_induction_on with k ih generalizing low high;
    unfold binarySearchLoop;
    by_cases h : low ≤ high <;> simp +decide [ h ];
    · split_ifs;
      any_goals omega;
      · grind;
      · specialize ih ( Int.toNat ( high - ( low + ( high - low ) / 2 + 1 ) + 1 ) ) ?_ ( low + ( high - low ) / 2 + 1 ) high ?_ ?_ ?_ <;> norm_num at *;
        · omega;
        · omega;
        · linarith;
        · constructor;
          · grind;
          · intro h₁ i hi₁ hi₂ hi₃;
            by_cases hi₄ : i ≤ low + (high - low) / 2;
            · have := h_sorted i ( Int.toNat ( low + ( high - low ) / 2 ) ) ( by linarith [ Int.toNat_of_nonneg ( by linarith : 0 ≤ low + ( high - low ) / 2 ) ] ) ( by linarith [ Int.toNat_of_nonneg ( by linarith : 0 ≤ low + ( high - low ) / 2 ) ] ) ; simp_all +decide [ Int.toNat_of_nonneg ( by linarith : 0 ≤ low + ( high - low ) / 2 ) ] ;
              linarith;
            · exact ih.2 h₁ i ( by linarith ) ( by linarith ) hi₃;
      · specialize ih ( Int.toNat ( ( low + ( high - low ) / 2 - 1 ) - low + 1 ) ) ?_ low ( low + ( high - low ) / 2 - 1 ) hlow ?_ ?_ <;> norm_num at *;
        · omega;
        · omega;
        · constructor;
          · exact fun h => ⟨ ih.1 h |>.1, by omega, ih.1 h |>.2.2 ⟩;
          · intro h i hi₁ hi₂ hi₃;
            by_cases hi₄ : i ≤ (low + (high - low) / 2).toNat;
            · by_cases hi₅ : i < (low + (high - low) / 2).toNat;
              · exact ih.2 h i hi₁ ( by omega ) hi₃;
              · grind;
            · have := h_sorted ( Int.toNat ( low + ( high - low ) / 2 ) ) i ( by linarith ) ( by linarith ) ; simp_all +decide;
              exact ‹¬arr[(low + (high - low) / 2).toNat] = x› ( le_antisymm ‹_› ‹_› );
    · intros; linarith;
  specialize h_bounds 0 ( arr.size - 1 );
  simp_all +decide;
  constructor;
  · grind;
  · intro h i hi; specialize h_bounds; have := h_bounds.2 h i ( by linarith ) ; aesop;