/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 7f257088-6430-44a3-b3fe-ee082a4c9014

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

/-
We define the Busy Beaver machine model and the function S(n). We define the 5-state champion machine `BB_champion_5`. We prove `BB_S_5_eq`, which states that S(5) = 47,176,870, conditional on two hypotheses: 1) `BB_champion_5` halts in 47,176,869 steps (0-indexed), and 2) No 5-state machine halts in more steps. These hypotheses correspond to computational results established by Marxen & Buntrock (1990) and the Busy Beaver Challenge (2024).
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
We define the standard Turing Machine model used in the Busy Beaver problem. A machine has `n` states and operates on a 2-symbol tape (Bool). An action consists of writing a symbol, moving the head, and changing state. `S(n)` is defined as the maximum number of steps a halting `n`-state machine can take.
-/
inductive BB_Dir where | L | R
deriving DecidableEq, Repr

inductive BB_Action (σ : Type) where
  | halt
  | step : σ → Bool → BB_Dir → BB_Action σ

structure BB_Machine (n : Nat) where
  start : Fin n
  table : Fin n → Bool → BB_Action (Fin n)

def BB_Tape := List Bool × Bool × List Bool

def BB_Tape_read (t : BB_Tape) : Bool := t.2.1

def BB_Tape_write (t : BB_Tape) (s : Bool) : BB_Tape := (t.1, s, t.2.2)

def BB_Tape_move (t : BB_Tape) (d : BB_Dir) : BB_Tape :=
  match d with
  | BB_Dir.L => match t.1 with
    | [] => ([], false, t.2.1 :: t.2.2)
    | h :: tl => (tl, h, t.2.1 :: t.2.2)
  | BB_Dir.R => match t.2.2 with
    | [] => (t.1 ++ [t.2.1], false, [])
    | h :: tl => (t.1 ++ [t.2.1], h, tl)

def BB_Config (n : Nat) := Fin n × BB_Tape

def BB_step {n : Nat} (M : BB_Machine n) (c : BB_Config n) : Option (BB_Config n) :=
  let (q, t) := c
  let s := BB_Tape_read t
  match M.table q s with
  | BB_Action.halt => none
  | BB_Action.step q' s' d => some (q', BB_Tape_move (BB_Tape_write t s') d)

def BB_run {n : Nat} (M : BB_Machine n) (steps : Nat) : Option (BB_Config n) :=
  match steps with
  | 0 => some (M.start, ([], false, []))
  | k + 1 => match BB_run M k with
    | none => none
    | some c => BB_step M c

def BB_halts_in {n : Nat} (M : BB_Machine n) (k : Nat) : Prop :=
  (BB_run M k).isSome ∧ (BB_run M (k + 1)).isNone

def BB_halts {n : Nat} (M : BB_Machine n) : Prop :=
  ∃ k, BB_halts_in M k

noncomputable def BB_S (n : Nat) : Nat :=
  sSup { k | ∃ M : BB_Machine n, BB_halts_in M k }

/-
The 5-state Busy Beaver champion machine.
-/
def BB_champion_5 : BB_Machine 5 := {
  start := 0
  table := fun q s =>
    match q.val, s with
    | 0, false => BB_Action.step 1 true BB_Dir.R -- A0 -> 1RB
    | 0, true  => BB_Action.step 2 true BB_Dir.L -- A1 -> 1LC
    | 1, false => BB_Action.step 2 true BB_Dir.R -- B0 -> 1RC
    | 1, true  => BB_Action.step 1 true BB_Dir.R -- B1 -> 1RB
    | 2, false => BB_Action.step 3 true BB_Dir.R -- C0 -> 1RD
    | 2, true  => BB_Action.step 4 false BB_Dir.L -- C1 -> 0LE
    | 3, false => BB_Action.step 0 true BB_Dir.L -- D0 -> 1LA
    | 3, true  => BB_Action.step 3 true BB_Dir.L -- D1 -> 1LD
    | 4, false => BB_Action.halt                 -- E0 -> 1RH (Halt)
    | 4, true  => BB_Action.step 0 false BB_Dir.L -- E1 -> 0LA
    | _, _     => BB_Action.halt -- Should not happen
}

/-
The types BB_Action and BB_Machine are finite.
-/
deriving instance DecidableEq for BB_Action
deriving instance DecidableEq for BB_Machine

instance : Fintype BB_Dir where
  elems := {BB_Dir.L, BB_Dir.R}
  complete := by
    rintro ( _ | _ | x ) <;> tauto

instance {σ : Type} [Fintype σ] [DecidableEq σ] : Fintype (BB_Action σ) :=
  Fintype.ofEquiv (Unit ⊕ (σ × Bool × BB_Dir))
    { toFun := fun
        | Sum.inl () => BB_Action.halt
        | Sum.inr (q, s, d) => BB_Action.step q s d
      invFun := fun
        | BB_Action.halt => Sum.inl ()
        | BB_Action.step q s d => Sum.inr (q, s, d)
      left_inv := by
        intro x; cases x <;> rfl;
      right_inv := by
        -- Let's prove that the functions are inverses of each other.
        intro x
        cases x <;> simp }

instance {n : Nat} : Fintype (BB_Machine n) :=
  Fintype.ofEquiv (Fin n × (Fin n → Bool → BB_Action (Fin n)))
    { toFun := fun (s, t) => { start := s, table := t }
      invFun := fun m => (m.start, m.table)
      left_inv := by
        exact?
      right_inv := by
        exact? }

/-
The type of BB_Machine is finite.
-/
instance {n : Nat} : Fintype (BB_Machine n) :=
  Fintype.ofEquiv (Fin n × (Fin n → Bool → BB_Action (Fin n)))
    { toFun := fun (s, t) => { start := s, table := t }
      invFun := fun m => (m.start, m.table)
      left_inv := by rintro ⟨s, t⟩; rfl
      right_inv := by rintro ⟨s, t⟩; rfl }

/-
Once a Busy Beaver machine halts, it stays halted.
-/
theorem BB_run_none_monotonic {n : Nat} (M : BB_Machine n) (k : Nat) :
  BB_run M k = none → ∀ j ≥ k, BB_run M j = none := by
    intro h;
    -- By definition of `BB_run`, if `BB_run M k = none`, then for any `j ≥ k`, `BB_run M j = none`.
    intros j hj
    induction' hj with j hj ih;
    · assumption;
    · -- By definition of `BB_run`, if `BB_run M j = none`, then `BB_run M (j + 1) = none`.
      simp [BB_run, ih]

/-
If a machine halts in k steps and no machine halts in more than k steps, then S(n) = k.
-/
theorem BB_S_eq_of_champion_and_max {n : Nat} {k : Nat} {M : BB_Machine n}
  (h_halts : BB_halts_in M k)
  (h_max : ∀ M' : BB_Machine n, BB_halts M' → ∃ k', BB_halts_in M' k' ∧ k' ≤ k) :
  BB_S n = k := by
  refine' le_antisymm _ _;
  · refine' csSup_le _ _;
    · exact ⟨ k, M, h_halts ⟩;
    · simp +zetaDelta at *;
      exact fun b M' h => h_max M' ( by unfold BB_halts; exact ⟨ b, h ⟩ ) |> fun ⟨ k', hk', hk'' ⟩ => le_trans ( by
        contrapose! h;
        unfold BB_halts_in at *;
        -- Since $k' < b$, we have $BB_run M' b = none$ by the monotonicity of $BB_run$.
        have h_run_none : BB_run M' b = none := by
          exact BB_run_none_monotonic M' ( k' + 1 ) ( by aesop ) b ( by linarith );
        aesop ) hk'';
  · refine' le_csSup _ _;
    · use k;
      rintro k' ⟨ M', hM' ⟩;
      obtain ⟨ k'', hk'', hk''_le ⟩ := h_max M' ( by exact ⟨ k', hM' ⟩ );
      unfold BB_halts_in at *;
      have h_monotone : ∀ k₁ k₂, k₁ ≤ k₂ → (BB_run M' k₁).isNone → (BB_run M' k₂).isNone := by
        intros k₁ k₂ hk₁₂ hk₁_none
        induction' hk₁₂ with k₁ k₂ hk₁₂ ih;
        · exact hk₁_none;
        · rw [ show BB_run M' ( k₁ + 1 ) = none from BB_run_none_monotonic M' k₁ ( by simpa using hk₁₂ ) ( k₁ + 1 ) ( Nat.le_succ _ ) ] ; simp +decide;
      exact le_of_not_gt fun h => by have := h_monotone _ _ ( by linarith : k'' + 1 ≤ k' ) hk''.2; aesop;
    · use M

/-
Definition of S(n) as the maximum number of steps, and a sufficient condition for S(n) = s.
-/
def BB_S_val (n : Nat) : Nat :=
  sSup { s | ∃ M : BB_Machine n, ∃ k, BB_halts_in M k ∧ s = k + 1 }

theorem BB_S_val_eq_of_champion_and_max {n : Nat} {s : Nat} {M : BB_Machine n}
  (h_halts : BB_halts_in M (s - 1))
  (h_s_pos : s > 0)
  (h_max : ∀ M' : BB_Machine n, BB_halts M' → ∃ k', BB_halts_in M' k' ∧ k' + 1 ≤ s) :
  BB_S_val n = s := by
  apply le_antisymm;
  · refine' csSup_le' _;
    rintro _ ⟨ M', k', hk', rfl ⟩;
    exact h_max M' ( by exact ⟨ k', hk' ⟩ ) |> fun ⟨ k'', hk'', hk''' ⟩ => by linarith [ show k' = k'' from by
                                                                                          -- Since the machine halts at step k', it cannot take any more steps, so k'' must equal k'.
                                                                                          have h_unique : ∀ k1 k2 : ℕ, BB_halts_in M' k1 → BB_halts_in M' k2 → k1 = k2 := by
                                                                                            intros k1 k2 hk1 hk2; exact (by
                                                                                            have h_unique : ∀ k1 k2 : ℕ, BB_halts_in M' k1 → BB_halts_in M' k2 → k1 ≤ k2 := by
                                                                                              intros k1 k2 hk1 hk2; exact le_of_not_gt fun h => by
                                                                                                have := BB_run_none_monotonic M' ( k2 + 1 ) ; simp_all +decide [ BB_halts_in ] ;
                                                                                                specialize this k1 ( by linarith ) ; aesop;
                                                                                            exact le_antisymm ( h_unique k1 k2 hk1 hk2 ) ( h_unique k2 k1 hk2 hk1 ));
                                                                                          exact h_unique _ _ hk' hk'' ] ;
  · apply le_csSup;
    · use s;
      rintro _ ⟨ M', k', hk', rfl ⟩;
      exact h_max M' ( by exact ⟨ k', hk' ⟩ ) |> fun ⟨ k'', hk'', hk''' ⟩ => by linarith [ show k' = k'' from by
                                                                                            -- Since the machine halts at step k', it cannot take any more steps, so k'' must equal k'.
                                                                                            have h_unique : ∀ k1 k2 : ℕ, BB_halts_in M' k1 → BB_halts_in M' k2 → k1 = k2 := by
                                                                                              intros k1 k2 hk1 hk2; exact (by
                                                                                              have h_unique : ∀ k1 k2 : ℕ, BB_halts_in M' k1 → BB_halts_in M' k2 → k1 ≤ k2 := by
                                                                                                intros k1 k2 hk1 hk2; exact le_of_not_gt fun h => by
                                                                                                  have := BB_run_none_monotonic M' ( k2 + 1 ) ; simp_all +decide [ BB_halts_in ] ;
                                                                                                  specialize this k1 ( by linarith ) ; aesop;
                                                                                              exact le_antisymm ( h_unique k1 k2 hk1 hk2 ) ( h_unique k2 k1 hk2 hk1 ));
                                                                                            exact h_unique _ _ hk' hk'' ] ;
    · exact ⟨ M, _, h_halts, by cases s <;> trivial ⟩

/-
The halting time of a Busy Beaver machine is unique.
-/
theorem BB_halts_in_unique {n : Nat} {M : BB_Machine n} {k1 k2 : Nat} :
  BB_halts_in M k1 → BB_halts_in M k2 → k1 = k2 := by
    intro h1 h2;
    -- Assume without loss of generality that $k1 \leq k2$.
    wlog h_wlog : k1 ≤ k2 generalizing k1 k2;
    · exact this h2 h1 ( le_of_not_ge h_wlog ) ▸ rfl;
    · -- If $k1 < k2$, then by the monotonicity of the run function, $BB_run M k2 = none$, contradicting $h2$.
      by_contra h_contra
      have h_monotone : BB_run M k2 = none := by
        have h_monotone : ∀ j ≥ k1 + 1, BB_run M j = none := by
          exact fun j hj => BB_run_none_monotonic M ( k1 + 1 ) ( by simpa using h1.2 ) j hj;
        exact h_monotone k2 ( Nat.succ_le_of_lt ( lt_of_le_of_ne h_wlog h_contra ) );
      cases h2 ; aesop

/-
Conditional on the known lower and upper bounds for 5-state machines, the Busy Beaver number S(5) is 47,176,870.
-/
theorem BB_S_5_eq
  (h_lb : BB_halts_in BB_champion_5 47176869)
  (h_ub : ∀ M : BB_Machine 5, BB_halts M → ∃ k, BB_halts_in M k ∧ k + 1 ≤ 47176870) :
  BB_S_val 5 = 47176870 := by
    apply BB_S_val_eq_of_champion_and_max;
    exacts [ h_lb, by decide, h_ub ]