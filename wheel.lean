/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 6b681237-0c39-44e4-851d-7be8ee6cdf8a

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

/-
We define the number of spanning trees for a Wheel Graph with N spokes, w(N), as the determinant of a specific Laplacian minor. We prove that w(1)=1, w(2)=5, and w(N)=3*w(N-1) - w(N-2) + 2 for N > 2. This is achieved by expanding the determinant using multilinearity and relating it to the determinant of a tridiagonal matrix A(N) which satisfies A(N) = 3*A(N-1) - A(N-2).
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
Define the Laplacian minor for the Wheel Graph W_n (rim part) and the number of spanning trees w(n).
-/
def wheelRimMatrix (n : ℕ) : Matrix (Fin n) (Fin n) ℤ :=
  fun i j =>
    (if i = j then 3 else 0) -
    (if j.val = (i.val + 1) % n then 1 else 0) -
    (if j.val = (i.val + n - 1) % n then 1 else 0)

def w (n : ℕ) : ℤ := (wheelRimMatrix n).det

/-
The number of spanning trees for a Wheel Graph with 1 spoke is 1.
-/
theorem w_1 : w 1 = 1 := by
  native_decide +revert

/-
The number of spanning trees for a Wheel Graph with 2 spokes is 5.
-/
theorem w_2 : w 2 = 5 := by
  native_decide

/-
Define the tridiagonal matrix A_n and its determinant A(n).
-/
def tridiagonalMatrix (n : ℕ) : Matrix (Fin n) (Fin n) ℤ :=
  fun i j =>
    if i = j then 3
    else if (i.val + 1 = j.val) ∨ (j.val + 1 = i.val) then -1
    else 0

def A (n : ℕ) : ℤ := (tridiagonalMatrix n).det

/-
The determinant of the tridiagonal matrix A(n) satisfies the recurrence A(n) = 3A(n-1) - A(n-2).
-/
theorem A_recurrence (n : ℕ) (h : n ≥ 3) : A n = 3 * A (n - 1) - A (n - 2) := by
  rcases n with ( _ | _ | n ) <;> simp_all +decide [ Matrix.det_succ_row_zero ];
  unfold A;
  rw [ Matrix.det_succ_column_zero ];
  simp +decide [ Fin.sum_univ_succ, tridiagonalMatrix ];
  congr 2;
  · congr! 1;
    ext i j; simp +decide [ tridiagonalMatrix ] ;
  · rw [ Matrix.det_succ_row_zero ];
    simp +decide [ Fin.sum_univ_succ, Matrix.submatrix, tridiagonalMatrix ];
    simp +decide [ Fin.ext_iff, Matrix.det_apply' ];
    congr! 3;
    unfold tridiagonalMatrix; aesop;

/-
Define term2 as the matrix A(n) with the last row replaced by (-1, 0, ..., 0).
-/
def term2 (n : ℕ) (h : n ≥ 3) : Matrix (Fin n) (Fin n) ℤ :=
  Matrix.updateRow (tridiagonalMatrix n) ⟨n - 1, by
    omega⟩ (fun j => if j = ⟨0, by
    grind⟩ then -1 else 0)

/-
Define term3 as A(n) with the first row replaced by (0, ..., 0, -1), and term4 as term3 with the last row replaced by (-1, 0, ..., 0).
-/
def term3 (n : ℕ) (h : n ≥ 3) : Matrix (Fin n) (Fin n) ℤ :=
  Matrix.updateRow (tridiagonalMatrix n) ⟨0, by omega⟩ (fun j => if j = ⟨n - 1, by omega⟩ then -1 else 0)

def term4 (n : ℕ) (h : n ≥ 3) : Matrix (Fin n) (Fin n) ℤ :=
  Matrix.updateRow (term3 n h) ⟨n - 1, by omega⟩ (fun j => if j = ⟨0, by omega⟩ then -1 else 0)

/-
The determinant of term2 is -1.
-/
theorem det_term2 (n : ℕ) (h : n ≥ 3) : (term2 n h).det = -1 := by
  rcases n with ( _ | _ | n ) <;> norm_num at *;
  · contradiction;
  · contradiction;
  · erw [ Matrix.det_succ_row _ ⟨ n + 1, by linarith ⟩ ];
    simp_all +decide [ Fin.sum_univ_succ, Matrix.submatrix, term2 ];
    unfold tridiagonalMatrix;
    induction' n with n ih <;> norm_num [ Fin.ext_iff, Fin.val_add, Nat.mod_eq_of_lt ] at *;
    erw [ Matrix.det_succ_column_zero ] ; norm_num [ Fin.sum_univ_succ, Matrix.det_succ_row_zero ];
    simp +decide [ Fin.succAbove, Fin.ext_iff ] at *;
    rcases n with ( _ | _ | n ) <;> simp +decide [ Fin.lt_iff_val_lt_val ] at *;
    convert ih using 1;
    erw [ Matrix.det_succ_row_zero ] ; norm_num [ Fin.sum_univ_succ, Matrix.det_succ_row_zero ];
    simp +decide [ Nat.mod_eq_of_lt, Fin.ext_iff, Fin.val_add, Fin.val_one, Fin.val_zero, Nat.mod_eq_of_lt ] at *;
    norm_num [ pow_succ', Matrix.submatrix ]

/-
The determinant of term3 is -1.
-/
theorem det_term3 (n : ℕ) (h : n ≥ 3) : (term3 n h).det = -1 := by
  induction' h with n hn ih <;> norm_num [ Nat.succ_eq_add_one ] at *;
  · native_decide +revert;
  · unfold term3; simp_all +decide [ Matrix.det_succ_row_zero ] ;
    erw [ Matrix.det_of_upperTriangular ];
    · unfold tridiagonalMatrix; simp +decide [ Fin.prod_univ_succ, Fin.succAbove ] ;
      simp_all +decide [ Fin.lt_iff_val_lt_val, Nat.mod_eq_of_lt ];
      norm_num [ Fin.ext_iff, pow_succ' ];
      norm_num [ ← mul_pow, Nat.mod_eq_of_lt ];
    · intro i j hij; simp_all +decide [ Fin.forall_fin_succ, Matrix.submatrix ] ;
      simp +decide [ Fin.succAbove, tridiagonalMatrix ];
      split_ifs <;> simp_all +decide [ Fin.ext_iff, Fin.val_add ];
      · linarith [ show ( j : ℕ ) < i from hij ];
      · omega;
      · exact hij.not_le ( Nat.le_of_lt_succ <| by linarith [ Fin.is_lt i, Fin.is_lt j ] );
      · exact not_lt_of_ge ‹_› ( Fin.castSucc_lt_last _ )

/-
The determinant of term4 is -A(n-2).
-/
theorem det_term4 (n : ℕ) (h : n ≥ 3) : (term4 n h).det = -A (n - 2) := by
  rcases n with ( _ | _ | n ) <;> simp +arith +decide at *;
  · contradiction;
  · contradiction;
  · unfold term4;
    rw [ Matrix.det_succ_row _ ⟨ n + 1, by linarith ⟩ ];
    unfold term3; simp +decide [ Matrix.det_succ_row _ ⟨ 0, by linarith ⟩ ] ;
    simp_all +decide [ Fin.sum_univ_castSucc, Fin.succAbove ];
    simp_all +decide [ Fin.ext_iff, Fin.val_add ];
    simp_all +decide [ ne_of_lt, Finset.sum_ite ];
    simp_all +decide [ Matrix.submatrix, Fin.succAbove ];
    ring;
    unfold tridiagonalMatrix; simp +decide [ Matrix.det_succ_row_zero ] ;
    rw [ sub_eq_zero ];
    refine' congr_arg Matrix.det _;
    ext i j; simp +decide [ Fin.lt_iff_val_lt_val, Nat.mod_eq_of_lt ] ;
    unfold tridiagonalMatrix; simp +decide [ Matrix.updateRow_apply ] ;
    split_ifs <;> simp_all +decide [ Fin.ext_iff, Nat.mod_eq_of_lt ];
    · linarith [ Fin.is_lt i, Fin.is_lt j ];
    · linarith [ Fin.is_lt i, Fin.is_lt j ];
    · linarith [ Fin.is_lt i, Fin.is_lt j ];
    · omega

/-
Linear expansion of determinant when two rows are perturbed.
det(M with row i += u and row j += v) = det(M) + det(M with row i replaced by u) + det(M with row j replaced by v) + det(M with row i replaced by u and row j replaced by v).
-/
theorem det_linear_expansion_2 {n : ℕ} [DecidableEq (Fin n)] {R : Type*} [CommRing R] (M : Matrix (Fin n) (Fin n) R) (i j : Fin n) (u v : Fin n → R) (h_ne : i ≠ j) :
  (Matrix.updateRow (Matrix.updateRow M i (M i + u)) j (M j + v)).det =
  M.det +
  (Matrix.updateRow M i u).det +
  (Matrix.updateRow M j v).det +
  (Matrix.updateRow (Matrix.updateRow M i u) j v).det := by
    have h_expand : ∀ (M : Matrix (Fin n) (Fin n) R) (i : Fin n) (u : Fin n → R), (Matrix.updateRow M i (M i + u)).det = M.det + (Matrix.updateRow M i u).det := by
      intro M i u; rw [ Matrix.det_updateRow_add ] ; simp +decide ;
    have h_expand2 : ∀ (M : Matrix (Fin n) (Fin n) R) (i j : Fin n) (u v : Fin n → R), i ≠ j → ((M.updateRow i u).updateRow j (M j + v)).det = ((M.updateRow i u).updateRow j v).det + (M.updateRow i u).det := by
      intro M i j u v hij; specialize h_expand ( M.updateRow i u ) j v; simp_all +decide [ Matrix.updateRow_apply ] ;
      convert h_expand using 1 <;> ring;
      simp +decide [ add_comm, Matrix.updateRow_apply, hij ];
      exact congr_arg Matrix.det ( by ext x y; by_cases hi : x = i <;> by_cases hj : x = j <;> aesop );
    have := h_expand ( M.updateRow j v ) i u; simp_all +decide [ add_comm, add_left_comm, add_assoc ] ;
    convert this using 1;
    · congr 1 with k l ; by_cases hk : k = i <;> by_cases hl : l = j <;> simp +decide [ *, Matrix.updateRow_apply ];
    · rw [ Matrix.updateRow_comm ];
      exact h_ne

/-
Expand w(n) using multilinearity of the determinant.
w(n) = det(A) + det(term2) + det(term3) + det(term4).
-/
theorem w_expansion (n : ℕ) (h : n ≥ 3) :
  w n = A n + (term2 n h).det + (term3 n h).det + (term4 n h).det := by
    -- Express the wheelRimMatrix A as the sum of the tridiagonal matrix A and the perturbations of the first and last rows.
    have h_decomp : wheelRimMatrix n = tridiagonalMatrix n + Matrix.of (fun i j => if i = ⟨0, by linarith⟩ then if j = ⟨n - 1, by
      exact Nat.pred_lt ( ne_bot_of_gt h )⟩ then -1 else 0 else if i = ⟨n - 1, by
      exact Nat.pred_lt ( ne_bot_of_gt h )⟩ then if j = ⟨0, by linarith⟩ then -1 else 0 else 0) := by
      ext i j; simp [wheelRimMatrix, tridiagonalMatrix];
      rcases i with ⟨ _ | i, hi ⟩ <;> rcases j with ⟨ _ | j, hj ⟩ <;> norm_num [ Fin.ext_iff, Nat.mod_eq_of_lt ];
      · rcases n with ( _ | _ | n ) <;> simp_all +decide;
      · rcases n with ( _ | _ | n ) <;> simp_all +decide [ Nat.mod_eq_of_lt ];
        split_ifs <;> ring;
      · rcases n with ( _ | _ | n ) <;> simp_all +arith +decide [ Nat.mod_eq_of_lt ];
        rcases i with ( _ | _ | i ) <;> simp_all +arith +decide [ Nat.mod_eq_of_lt ];
        · rcases n with ( _ | _ | n ) <;> simp_all +arith +decide [ Nat.mod_eq_of_lt ];
        · rcases n with ( _ | _ | n ) <;> simp_all +arith +decide [ Nat.mod_eq_of_lt ];
        · split_ifs <;> norm_num;
          · rw [ eq_comm, Nat.mod_eq_of_lt ] at * <;> linarith;
          · rw [ eq_comm, Nat.mod_eq_of_lt ] at * <;> omega;
          · rw [ eq_comm, Nat.mod_eq_of_lt ] at * <;> omega;
          · rw [ Nat.mod_eq_of_lt ] at * <;> linarith;
          · subst_vars; norm_num [ Nat.mod_eq_of_lt ] at *;
      · split_ifs <;> norm_num;
        all_goals rw [ Nat.mod_eq_of_lt ] at * <;> try linarith;
        any_goals omega;
        · by_contra h_contra;
          norm_num [ show n = i + 2 by linarith ] at *;
        · rcases n with ( _ | _ | n ) <;> simp_all +arith +decide [ Nat.mod_eq_of_lt ];
          cases lt_or_eq_of_le hi <;> aesop;
        · exact lt_of_le_of_ne ( by linarith ) ( by aesop )
    generalize_proofs at *;
    have h_det_expansion : ∀ (M : Matrix (Fin n) (Fin n) ℤ) (i j : Fin n) (u v : Fin n → ℤ), i ≠ j → Matrix.det (M.updateRow i (M i + u) |>.updateRow j (M j + v)) = Matrix.det M + Matrix.det (M.updateRow i u) + Matrix.det (M.updateRow j v) + Matrix.det (M.updateRow i u |>.updateRow j v) := by
      exact?;
    unfold w A term2 term3 term4;
    convert h_det_expansion ( tridiagonalMatrix n ) ⟨ 0, by linarith ⟩ ⟨ n - 1, by linarith [ Nat.sub_add_cancel ( by linarith : 1 ≤ n ) ] ⟩ ( fun j => if j = ⟨ n - 1, by linarith [ Nat.sub_add_cancel ( by linarith : 1 ≤ n ) ] ⟩ then -1 else 0 ) ( fun j => if j = ⟨ 0, by linarith ⟩ then -1 else 0 ) ( by norm_num; linarith [ Nat.sub_add_cancel ( by linarith : 1 ≤ n ) ] ) using 1;
    · congr! 1;
      ext i j; by_cases hi : i = ⟨ 0, by linarith ⟩ <;> by_cases hj : i = ⟨ n - 1, by linarith [ Nat.sub_add_cancel ( by linarith : 1 ≤ n ) ] ⟩ <;> simp +decide [ *, Matrix.updateRow_apply ] ;
      · exact fun h => absurd h ( by omega );
      · exact fun h => absurd h ( by omega );
      · exact fun h => absurd h ( Nat.sub_ne_zero_of_lt ( by linarith ) );
    · unfold term3; ring;

/-
For n >= 3, w(n) = A(n) - A(n-2) - 2.
-/
theorem w_eq_A_sub (n : ℕ) (h : n ≥ 3) : w n = A n - A (n - 2) - 2 := by
  rw [ w_expansion n h, det_term2 n h, det_term3 n h, det_term4 n h ] ; ring

/-
Values of A(0), A(1), A(2) and recurrence check for n=2.
-/
theorem A_0 : A 0 = 1 := by
  rfl
theorem A_1 : A 1 = 3 := by
  native_decide +revert
theorem A_2 : A 2 = 8 := by
  native_decide
theorem A_recurrence_2 : A 2 = 3 * A 1 - A 0 := by
  native_decide +revert

/-
w(2) satisfies the formula A(2) - A(0) - 2.
-/
theorem w_2_eq_A_sub : w 2 = A 2 - A 0 - 2 := by
  native_decide +revert

/-
The number of spanning trees w(n) satisfies the recurrence w(n) = 3w(n-1) - w(n-2) + 2 for n > 2.
-/
theorem w_recurrence (n : ℕ) (h : n > 2) : w n = 3 * w (n - 1) - w (n - 2) + 2 := by
  rcases n with ( _ | _ | _ | n ) <;> simp_all +decide;
  -- By definition of $w$, we know that $w(n) = A(n) - A(n-2) - 2$ for $n > 2$.
  have hw : ∀ n > 2, w n = A n - A (n - 2) - 2 := by
    exact?;
  -- By definition of $A$, we know that $A(n) = 3A(n-1) - A(n-2)$ for $n > 2$.
  have hA : ∀ n > 2, A n = 3 * A (n - 1) - A (n - 2) := by
    exact?;
  rcases n with ( _ | _ | n ) <;> simp_all +decide;
  ring